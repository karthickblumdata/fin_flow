import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' show lerpDouble;
import 'dart:ui' as ui;
import 'package:csv/csv.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path_provider/path_provider.dart';
import 'package:go_router/go_router.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:syncfusion_flutter_xlsio/xlsio.dart' as xlsio;
import '../../models/action_button_setting.dart';
import '../../models/timeline_item.dart';
import '../../services/settings_service.dart';
import '../../theme/app_theme.dart';
import '../../utils/responsive.dart';
import '../../services/socket_service.dart';
import '../../services/wallet_service.dart';
import '../../services/all_wallet_reports_service.dart';
import '../../services/transaction_service.dart';
import '../../services/collection_service.dart';
import '../../services/expense_service.dart';
import '../../services/expense_type_service.dart';
import '../../services/auth_service.dart';
import '../../services/payment_mode_service.dart';
import '../../services/dashboard_service.dart';
import '../../services/user_service.dart';
import '../../services/api_service.dart';
import '../common/wallet_screen.dart';
import '../common/transfer_screen.dart';
import '../common/manage_users_screen.dart';
import '../common/manage_expense_types_screen.dart';
import '../common/collections_screen.dart';
import '../common/all_user_wallets_screen.dart';
import '../common/collection_custom_field_screen.dart';
import '../common/recent_activity_screen.dart';
import '../common/all_transactions_screen.dart';
import '../common/roles_screen.dart';
import '../common/payment_modes_screen.dart';
import '../common/pending_approvals_screen.dart';
import '../../widgets/add_collection_dialog.dart';
import '../../widgets/timeline_item_widget.dart';
import '../../utils/ui_permission_checker.dart';
import '../../utils/permission_action_checker.dart';
import '../../constants/super_admin_menu_constants.dart';
import '../../constants/nav_item.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:intl/intl.dart';
import 'package:image_picker/image_picker.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:provider/provider.dart';
import '../../providers/filter_provider.dart';

enum _ExportFormat { csv, excel, pdf }

class _StatusBadgeStyle {
  final String label;
  final Color color;
  final IconData icon;
  final double backgroundOpacity;
  final double labelLetterSpacing;

  const _StatusBadgeStyle({
    required this.label,
    required this.color,
    required this.icon,
    this.backgroundOpacity = 0.15,
    this.labelLetterSpacing = 0.5,
  });
}

class _TableExportData {
  final List<String> headers;
  final List<List<String>> rows;
  final List<double> amountValues;

  const _TableExportData({
    required this.headers,
    required this.rows,
    required this.amountValues,
  });
}

class _RowActionConfig {
  final bool canApprove;
  final bool canUnapprove;
  final bool canReject;
  final bool canEdit;
  final bool canFlag;
  final bool canDelete;

  const _RowActionConfig({
    required this.canApprove,
    required this.canUnapprove,
    required this.canReject,
    required this.canEdit,
    required this.canFlag,
    required this.canDelete,
  });
}

class _LegendEntry {
  const _LegendEntry({
    required this.icon,
    required this.color,
    required this.label,
  });

  final IconData icon;
  final Color color;
  final String label;
}

class _CollapsedMenuOption {
  const _CollapsedMenuOption({
    required this.id,
    required this.label,
    required this.isSelected,
    required this.onSelected,
  });

  final String id;
  final String label;
  final bool isSelected;
  final VoidCallback onSelected;
}


class _PillIconButton extends StatelessWidget {
  const _PillIconButton({
    required this.label,
    required this.onTap,
    required this.isSelected,
    required this.isCompact,
    required this.selectedGradientColors,
    required this.unselectedBackgroundColor,
    required this.borderColor,
    required this.textStyle,
    required this.iconColor,
    this.leadingIcon,
    this.trailingIcon,
  });

  final String label;
  final VoidCallback onTap;
  final bool isSelected;
  final bool isCompact;
  final List<Color> selectedGradientColors;
  final Color unselectedBackgroundColor;
  final Color borderColor;
  final TextStyle textStyle;
  final Color iconColor;
  final IconData? leadingIcon;
  final IconData? trailingIcon;

  @override
  Widget build(BuildContext context) {
    final double radius = isCompact ? 20 : 24;
    final double horizontalPadding = isCompact ? 12 : 16;
    final double verticalPadding = isCompact ? 8 : 10;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(radius),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: EdgeInsets.symmetric(
            horizontal: horizontalPadding,
            vertical: verticalPadding,
          ),
          decoration: BoxDecoration(
            gradient: isSelected
                ? LinearGradient(
                    colors: selectedGradientColors,
                    begin: Alignment.centerLeft,
                    end: Alignment.centerRight,
                  )
                : null,
            color: isSelected ? null : unselectedBackgroundColor,
            borderRadius: BorderRadius.circular(radius),
            border: Border.all(color: borderColor),
            boxShadow: isSelected
                ? [
                    BoxShadow(
                      color: selectedGradientColors.last.withOpacity(0.4),
                      blurRadius: 12,
                      offset: const Offset(0, 4),
                    ),
                  ]
                : const [],
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (leadingIcon != null) ...[
                Icon(
                  leadingIcon,
                  size: isCompact ? 16 : 18,
                  color: iconColor,
                ),
                const SizedBox(width: 8),
              ],
              Flexible(
                child: Text(
                  label,
                  overflow: TextOverflow.ellipsis,
                  style: textStyle,
                ),
              ),
              if (trailingIcon != null) ...[
                const SizedBox(width: 8),
                Icon(
                  trailingIcon,
                  size: isCompact ? 16 : 18,
                  color: iconColor,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

}

class SuperAdminDashboard extends StatefulWidget {
  const SuperAdminDashboard({
    super.key,
    this.initialUserId,
    this.initialUserLabel,
    this.initialSelectedItem,
    this.initialSelectedType,
    this.initialSelectedStatus,
    this.initialSelectedExpenseTypeCategory,
  });

  final String? initialUserId;
  final String? initialUserLabel;
  final NavItem? initialSelectedItem;
  final String? initialSelectedType;
  final String? initialSelectedStatus;
  final String? initialSelectedExpenseTypeCategory;

  @override
  State<SuperAdminDashboard> createState() => _SuperAdminDashboardState();
}

class _SuperAdminDashboardState extends State<SuperAdminDashboard>
    with TickerProviderStateMixin {
  NavItem _selectedItem = NavItem.dashboard;
  final GlobalKey<PendingApprovalsScreenState> _pendingApprovalsRefreshKey = GlobalKey<PendingApprovalsScreenState>();
  final GlobalKey<CollectionCustomFieldScreenState> _collectionCustomFieldRefreshKey = GlobalKey<CollectionCustomFieldScreenState>();
  String? _highlightRole; // Role to highlight when navigating to Roles screen
  bool _walletExpanded = false;
  bool _usersExpanded = false;
  bool _accountExpanded = false;
  bool _expensesExpanded = false;
  bool _settingsExpanded = false;
  bool _isRefreshing = false;
  bool _isSidebarCollapsed = false;
  bool _isDrawerOpen = false;
  late AnimationController _hamburgerAnimationController;
  late Animation<double> _hamburgerRotationAnimation;
  
  // Local FilterProvider instance - private to this screen
  late FilterProvider _filterProvider;
  
  // Permission state variables
  bool _canViewDashboard = true;
  bool _canViewWalletSelf = false;
  bool _isNonWalletUser = false; // Track if current user is non-wallet user
  bool _canViewWalletAll = false;
  bool _canViewWalletOverview = false;
  bool _canViewSmartApprovals = false;
  bool _canViewUsers = false;
  bool _canViewRoles = false;
  bool _canViewPaymentModes = false;
  bool _canViewAccountReports = false;
  bool _canViewExpenseType = false;
  bool _canViewExpenseReport = false;
  bool _canViewWalletMenu = false;
  bool _canViewUsersMenu = false;
  bool _canViewPaymentAccountsMenu = false;
  bool _canViewExpensesMenu = false;
  bool _canViewSettingsMenu = false;
  bool _canEnableQuickActions = false;
  bool _canAddAmount = false;
  bool _canWithdraw = false;
  bool _canViewFlaggedFinancialFlow = false;
  bool _canViewStatusCountTable = false;
  bool _isSuperAdmin = false;
  bool _permissionsLoaded = false;
  
  // Self Wallet sub-permissions
  bool _canViewSelfWalletTransaction = false;
  bool _canViewSelfWalletCollection = false;
  bool _canViewSelfWalletExpenses = false;
  
  // Self Wallet Transaction action permissions
  bool _canCreateTransaction = false;
  bool _canEditTransaction = false;
  bool _canDeleteTransaction = false;
  bool _canRejectTransaction = false;
  bool _canFlagTransaction = false;
  bool _canApproveTransaction = false;
  bool _canUnapproveTransaction = false;
  bool _canExportTransaction = false;
  
  // Self Wallet Expenses action permissions
  bool _canCreateExpenses = false;
  bool _canEditExpenses = false;
  bool _canDeleteExpenses = false;
  bool _canRejectExpenses = false;
  bool _canFlagExpenses = false;
  bool _canApproveExpenses = false;
  bool _canUnapproveExpenses = false;
  bool _canExportExpenses = false;
  
  // Self Wallet Collection action permissions
  bool _canCreateCollection = false;
  bool _canEditCollection = false;
  bool _canDeleteCollection = false;
  bool _canRejectCollection = false;
  bool _canFlagCollection = false;
  bool _canApproveCollection = false;
  bool _canUnapproveCollection = false;
  bool _canExportCollection = false;
  
  // All Wallet Report Transaction action permissions
  bool _canApproveReportTransaction = false;
  bool _canEditReportTransaction = false;
  bool _canDeleteReportTransaction = false;
  bool _canRejectReportTransaction = false;
  bool _canFlagReportTransaction = false;
  
  // All Wallet Report Collection action permissions
  bool _canApproveReportCollection = false;
  bool _canEditReportCollection = false;
  bool _canDeleteReportCollection = false;
  bool _canRejectReportCollection = false;
  bool _canFlagReportCollection = false;
  
  // All Wallet Report Expenses action permissions
  bool _canApproveReportExpenses = false;
  bool _canEditReportExpenses = false;
  bool _canDeleteReportExpenses = false;
  bool _canRejectReportExpenses = false;
  bool _canFlagReportExpenses = false;
  
  // All User Wallets action permissions (top-level)
  bool _canAddExpenseAll = false;
  bool _canAddAmountAll = false;
  bool _canAddCollectionAll = false;
  bool _canAddTransactionAll = false;
  bool _canWithdrawAll = false;
  
  
  static const Map<String, ActionButtonSetting> _defaultActionButtonSettings = {
    'approve': ActionButtonSetting(key: 'approve', showButton: true, enablePopup: true),
    'reject': ActionButtonSetting(key: 'reject', showButton: true, enablePopup: true),
    'unapprove': ActionButtonSetting(key: 'unapprove', showButton: true, enablePopup: false),
    'delete': ActionButtonSetting(key: 'delete', showButton: true, enablePopup: true),
    'edit': ActionButtonSetting(key: 'edit', showButton: true, enablePopup: false),
    'flag': ActionButtonSetting(key: 'flag', showButton: true, enablePopup: true),
  };

  static const double _sidebarExpandedWidth = 280;
  static const double _sidebarCollapsedWidth = 80;

  static const Map<String, String> _actionConfirmationMessages = {
    'approve': 'approve this item',
    'reject': 'reject this item',
    'unapprove': 'mark this item as unapproved',
    'delete': 'delete this item permanently',
    'edit': 'open the edit dialog for this item',
    'flag': 'flag this item for review',
  };

  Map<String, ActionButtonSetting> _actionButtonSettings =
      Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
  bool _isLoadingActionButtons = false;

  // Dashboard data
  Map<String, dynamic>? _wallet;
  int _pendingCollections = 0;
  int _pendingTransactions = 0;
  int _pendingExpenses = 0;
  bool _isLoadingDashboard = true;
  
  // Recent activities
  List<dynamic>? _recentActivities;
  
  // Recent transactions and expenses
  List<dynamic> _recentTransactions = [];
  List<dynamic> _recentExpenses = [];
  
  // Financial Dashboard state
  // Note: Global filters (type, status, mode, date range, user) are now managed by FilterProvider
  // Access via: _filterProvider (local instance)
  final Set<String> _selectedStatusSet = <String>{}; // Screen-specific: multiple status selection
  bool _pendingApprovalsMode = false;
  String? _selectedExpenseTypeCategory; // Expense type category filter for expense report (screen-specific)
  // _selectedUserStatus is now in FilterProvider
  List<dynamic> _allData = [];
  List<dynamic> _filteredData = [];
  bool _isExpenseReportMode = false; // Track if we're in expense report only mode
  // _selectedQuickRange and _selectedQuarter are now in FilterProvider
  Set<int> _expandedRows = {}; // For expandable table rows
  Set<String> _expandedReasonCards = {}; // For expandable reason text in flagged cards
  bool _isFiltersExpanded = false; // For collapsible filter bar
  bool _isFilterBreakdownExpanded = false; // For collapsible filter breakdown
  double _cashIn = 0.0;
  double _cashOut = 0.0;
  double _balance = 0.0;
  Map<String, Map<String, Map<String, dynamic>>> _filterBreakdown = {
    'Expenses': {
      'Approved': {'count': 0, 'amount': 0.0},
      'Unapproved': {'count': 0, 'amount': 0.0},
      'Flagged': {'count': 0, 'amount': 0.0},
      'Rejected': {'count': 0, 'amount': 0.0},
    },
    'Transactions': {
      'Approved': {'count': 0, 'amount': 0.0},
      'Unapproved': {'count': 0, 'amount': 0.0},
      'Flagged': {'count': 0, 'amount': 0.0},
      'Rejected': {'count': 0, 'amount': 0.0},
    },
    'Collections': {
      'Accounted': {'count': 0, 'amount': 0.0},
      'Unaccounted': {'count': 0, 'amount': 0.0},
      'Flagged': {'count': 0, 'amount': 0.0},
      'Rejected': {'count': 0, 'amount': 0.0},
    },
  };
  _ExportFormat? _exportInProgress;

  // Add Amount/Withdraw form state
  final GlobalKey<FormState> _addAmountWithdrawFormKey = GlobalKey<FormState>();
  final TextEditingController _amountController = TextEditingController();
  final TextEditingController _remarkController = TextEditingController();
  String? _selectedAccountId;
  bool _isSubmitting = false;
  bool _isAddAmountMode = true; // Toggle between Add Amount and Withdraw

  // Add Expenses form state
  final GlobalKey<FormState> _addExpenseFormKey = GlobalKey<FormState>();
  final TextEditingController _expenseAmountController = TextEditingController();
  final TextEditingController _expenseDescriptionController = TextEditingController();
  final TextEditingController _expenseRemarkController = TextEditingController();
  String? _selectedExpenseAccountId;
  String _selectedExpenseCategory = 'Office';
  String _selectedExpenseMode = 'Cash';
  String? _selectedExpensePaymentAccountId; // For UPI/Bank mode
  XFile? _selectedExpenseProofImage;
  List<String> _expenseCategories = ['Office', 'Travel', 'Marketing', 'Maintenance', 'Misc']; // Will be loaded from API
  // Full expense type objects with image URLs for dropdown display
  List<Map<String, dynamic>> _expenseTypesWithImages = [];
  // Two-step dialog state
  int _expenseDialogStep = 1; // 1 = Select Type, 2 = Enter Details
  Map<String, dynamic>? _selectedExpenseTypeForDialog; // Selected expense type with image
  String? _userName; // Current user's name for dialog reference

  // Add Collection form state
  final GlobalKey<FormState> _addCollectionFormKey = GlobalKey<FormState>();
  
  // Height matching for Status Count Table and Flagged Financial Flow
  double? _statusTableHeight;
  final _statusTableKey = GlobalKey();
  final TextEditingController _collectionCustomerNameController = TextEditingController();
  final TextEditingController _collectionAmountController = TextEditingController();
  final TextEditingController _collectionNotesController = TextEditingController();
  String? _selectedCollectionAccountId;
  String? _selectedCollectionUserId; // User selection for collection
  String _selectedCollectionMode = 'Cash';
  String? _selectedCollectionPaymentAccountId; // For UPI/Bank mode

  // Add Transaction form state
  final GlobalKey<FormState> _addTransactionFormKey = GlobalKey<FormState>();
  final TextEditingController _transactionAmountController = TextEditingController();
  final TextEditingController _transactionPurposeController = TextEditingController();
  String? _selectedTransactionAccountId;
  String? _selectedTransactionSenderId;
  String? _selectedTransactionReceiverId;
  String _selectedTransactionMode = 'Cash';
  List<Map<String, String>> _accountList = [
    {'id': 'acc1', 'name': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234'},
    {'id': 'acc2', 'name': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678'},
    {'id': 'acc3', 'name': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012'},
  ];

  // All Accounts state variables
  List<Map<String, dynamic>> _allAccountsList = [];
  bool _isLoadingAccounts = false;
  bool _hasAccountLoadError = false;
  String? _accountLoadErrorMessage;
  String? _selectedAccountFilterId; // Single account selection for filter
  // Account filter search/suggestion related
  String _accountFilterSearchText = '';
  List<String> _recentAccountIds = []; // Store recently used account IDs

  List<Map<String, String>> _userOptions = [];
  // Note: _selectedUserIds and _selectedUserDisplayLabels are now in FilterProvider
  final Set<String> _selectedUserLabelMatchers = <String>{}; // Screen-specific: for label matching
  bool _isLoadingUsers = false;
  bool _routeArgumentsApplied = false;

  // Payment Modes state
  List<Map<String, dynamic>> _paymentModes = [];
  bool _isLoadingPaymentModes = false;
  final ValueNotifier<bool> _paymentModesLoadedNotifier = ValueNotifier<bool>(false);

  // Optimization: Caching and debouncing
  Map<String, dynamic>? _cachedWalletData;
  DateTime? _cacheTimestamp;
  static const Duration _cacheDuration = Duration(seconds: 30);
  Timer? _debounceTimer;
  Timer? _filterChangeTimer; // Separate timer for filter change auto-refresh
  bool _isLoadingFinancialData = false;
  bool _isApplyingFilters = false;
  bool _accountReportsDataLoaded = false; // Track if Account Reports data has been loaded
  bool _accountReportsInitialized = false; // Track if Account Reports has been initialized
  bool _isInitializingAccountReports = false; // Track if Account Reports is currently initializing
  bool _accountReportsCallbackScheduled = false; // Track if post-frame callback is already scheduled

  // Dashboard Header Features - State Variables
  String? _dashboardUserName;
  String _greeting = '';
  String _dailyQuote = '';
  String _quoteAuthor = '';
  bool _isLoadingQuote = false;
  
  // Financial Summary (for logged-in user)
  double _userCashIn = 0.0;
  double _userCashOut = 0.0;
  double _userBalance = 0.0;
  bool _isLoadingFinancialSummary = false;
  
  // Status Cards
  Map<String, dynamic> _statusCounts = {
    'expenses': {
      'approved': 0,
      'unapproved': 0,
      'flagged': 0,
      'total': 0,
    },
    'transactions': {
      'approved': 0,
      'unapproved': 0,
      'flagged': 0,
      'total': 0,
    },
    'collections': {
      'accounted': 0,
      'unaccounted': 0,
      'flagged': 0,
      'total': 0,
    },
  };
  bool _isLoadingStatusCounts = false;
  
  // Timeline
  List<dynamic> _timelineItems = [];
  bool _isLoadingTimeline = false;
  /// Track resubmitted item IDs to filter them out during reload (safeguard)
  final Set<String> _resubmittedItemIds = <String>{};

  static const Map<String, String> _statusAliases = {
    'approved': 'approved',
    'approved‚úÖ': 'approved',
    'completed': 'approved',
    'complete': 'approved',
    'done': 'approved',
    'verified': 'accounted',
    'verify': 'accounted',
    'verified‚úÖ': 'accounted',
    'approvedandverified': 'accounted',
    'accounted': 'unaccounted',
    'unaccounted': 'unaccounted',
    'notaccounted': 'unaccounted',
    'un_accounted': 'unaccounted',
    'un-accounted': 'unaccounted',
    'un accounted': 'unaccounted',
    'unaccounted‚úÖ': 'unaccounted',
    'pending': 'unaccounted',
    'pendingreview': 'unaccounted',
    'pending review': 'unaccounted',
    'pending-review': 'unaccounted',
    'pending_review': 'unaccounted',
    'awaitingapproval': 'unaccounted',
    'awaiting approval': 'unaccounted',
    'awaiting-review': 'unaccounted',
    'awaiting_review': 'unaccounted',
    'awaiting review': 'unaccounted',
    'awaiting-approval': 'unaccounted',
    'awaiting_approval': 'unaccounted',
    'pending approval': 'unaccounted',
    'pending-approval': 'unaccounted',
    'pending_approval': 'unaccounted',
    'viewed': 'unaccounted',
    'seen': 'unaccounted',
    'processing': 'unaccounted',
    'inprogress': 'unaccounted',
    'in progress': 'unaccounted',
    'in-progress': 'unaccounted',
    'processing...': 'unaccounted',
    'flagged': 'flagged',
    'flag': 'flagged',
    'rejected': 'rejected',
    'reject': 'rejected',
    'declined': 'rejected',
    'decline': 'rejected',
    'denied': 'rejected',
    'denied‚ùå': 'rejected',
    'rejected‚ùå': 'rejected',
  };


  static const Map<String, _StatusBadgeStyle> _statusBadgeStyles = {
    'approved': _StatusBadgeStyle(label: 'Approve', color: AppTheme.secondaryColor, icon: Icons.check_circle),
    'unapproved': _StatusBadgeStyle(label: 'Unapprove', color: AppTheme.warningColor, icon: Icons.undo),
    'accounted': _StatusBadgeStyle(label: 'Accounted', color: AppTheme.accentBlue, icon: Icons.verified),
    'unaccounted': _StatusBadgeStyle(label: 'Unaccounted', color: AppTheme.primaryColor, icon: Icons.account_circle),
    'flagged': _StatusBadgeStyle(label: 'Flagged', color: AppTheme.warningColor, icon: Icons.flag),
    'rejected': _StatusBadgeStyle(label: 'Rejected', color: AppTheme.errorColor, icon: Icons.block),
  };

  static const Map<int, Map<String, int>> _quarterConfig = {
    1: {'startMonth': 4, 'endMonth': 6, 'yearOffset': 0},
    2: {'startMonth': 7, 'endMonth': 9, 'yearOffset': 0},
    3: {'startMonth': 10, 'endMonth': 12, 'yearOffset': 0},
    4: {'startMonth': 1, 'endMonth': 3, 'yearOffset': 1},
  };

  static const List<String> _modeOptions = ['All', 'Cash', 'UPI', 'Bank', 'Sales UPI', 'Purchase UPI', 'Bank Transfer'];
  static const List<String> _accountReportsModeOptions = ['All', 'Cash', 'UPI', 'Bank'];

  // Get active mode options from payment modes - show actual payment mode names
  /// Get mode options from actual data (only modes used in transactions)
  List<String> _getModeOptionsFromData({bool isAccountReports = false}) {
    // Always include 'All' as first option
    final List<String> modeOptions = ['All'];
    
    // Get data source - use _allData to show all available modes
    final dataSource = _allData;
    
    if (dataSource.isEmpty) {
      debugPrint('‚ö†Ô∏è [MODE DROPDOWN] No data available, showing only "All"');
      return modeOptions;
    }
    
    // Extract unique modes from actual transaction data
    final Set<String> uniqueModes = {};
    
    debugPrint('üîç [MODE DROPDOWN] Extracting modes from ${dataSource.length} items');
    
    for (var item in dataSource) {
      String? itemMode;
      
      // Try multiple fields for mode
      if (item['mode'] != null) {
        itemMode = item['mode'].toString().trim();
      } else if (item['paymentMode'] != null) {
        if (item['paymentMode'] is Map) {
          itemMode = (item['paymentMode'] as Map)['name']?.toString().trim() ?? 
                     (item['paymentMode'] as Map)['modeName']?.toString().trim();
        } else {
          itemMode = item['paymentMode'].toString().trim();
        }
      }
      
      if (itemMode != null && itemMode.isNotEmpty) {
        uniqueModes.add(itemMode);
      }
    }
    
    // Sort mode names alphabetically
    final List<String> sortedModes = uniqueModes.toList()..sort();
    
    debugPrint('üìã [MODE DROPDOWN] Found ${sortedModes.length} unique modes from data: $sortedModes');
    
    // Add all unique modes to dropdown
    modeOptions.addAll(sortedModes);
    
    debugPrint('‚úÖ [MODE DROPDOWN] Final mode options from data: $modeOptions');
    return modeOptions;
  }

  /// Get mode options from payment modes database (all active modes)
  List<String> _getActiveModeOptions({bool isAccountReports = false}) {
    // Always include 'All' as first option
    final List<String> activeModes = ['All'];
    
    // If payment modes haven't loaded yet, return empty (only 'All')
    if (_paymentModes.isEmpty) {
      debugPrint('‚ö†Ô∏è [MODE DROPDOWN] Payment modes not loaded yet, showing only "All"');
      return activeModes;
    }
    
    // Extract actual payment mode names (modeName) from active payment modes
    final Set<String> uniqueModeNames = {};
    
    debugPrint('üîç [MODE DROPDOWN] Processing ${_paymentModes.length} payment modes');
    
    for (var paymentMode in _paymentModes) {
      final modeName = paymentMode['modeName']?.toString() ?? '';
      if (modeName.isNotEmpty) {
        uniqueModeNames.add(modeName);
        debugPrint('   ‚úÖ Added payment mode: $modeName');
      } else {
        debugPrint('   ‚ö†Ô∏è Skipping payment mode with empty modeName');
      }
    }
    
    // Sort mode names alphabetically
    final List<String> sortedModeNames = uniqueModeNames.toList()..sort();
    
    debugPrint('üìã [MODE DROPDOWN] Found ${sortedModeNames.length} payment mode names: $sortedModeNames');
    
    // Add all payment mode names to dropdown
    activeModes.addAll(sortedModeNames);
    
    debugPrint('‚úÖ [MODE DROPDOWN] Final mode options: $activeModes');
    return activeModes;
  }

  // Extract filter mode name from payment mode name
  String? _extractFilterModeFromName(String modeName) {
    final lowerName = modeName.toLowerCase();
    
    // Check for specific modes first
    if (lowerName.contains('sales') && lowerName.contains('upi')) {
      return 'Sales UPI';
    }
    if (lowerName.contains('purchase') && lowerName.contains('upi')) {
      return 'Purchase UPI';
    }
    if (lowerName.contains('bank') && lowerName.contains('transfer')) {
      return 'Bank Transfer';
    }
    
    // Check for base modes
    if (lowerName.contains('cash')) {
      return 'Cash';
    }
    if (lowerName.contains('upi')) {
      return 'UPI';
    }
    if (lowerName.contains('bank')) {
      return 'Bank';
    }
    
    return null;
  }

  List<Widget> _buildAllQuickButtons(BuildContext context, bool isMobile) {
    return [
      _buildQuickDateButton(
        context,
        'This Month',
        'thisMonth',
        () => _setQuickDateRange('thisMonth'),
        isMobile,
      ),
      _buildQuickDateButton(
        context,
        'Last Month',
        'lastMonth',
        () => _setQuickDateRange('lastMonth'),
        isMobile,
      ),
      _buildQuickDateButton(
        context,
        'This FY',
        'thisFinancialYear',
        () => _setQuickDateRange('thisFinancialYear'),
        isMobile,
      ),
      _buildQuickDateButton(
        context,
        'Previous FY',
        'previousFinancialYear',
        () => _setQuickDateRange('previousFinancialYear'),
        isMobile,
      ),
      _buildQuarterButton('Q1 (Apr - Jun)', 'April, May, June', 1, isMobile),
      _buildQuarterButton('Q2 (Jul - Sep)', 'July, August, September', 2, isMobile),
      _buildQuarterButton('Q3 (Oct - Dec)', 'October, November, December', 3, isMobile),
      _buildQuarterButton('Q4 (Jan - Mar)', 'January, February, March', 4, isMobile),
    ];
  }

  @override
  void initState() {
    super.initState();
    _hamburgerAnimationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _hamburgerRotationAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _hamburgerAnimationController,
      curve: Curves.easeInOut,
    ));
    
    // Create local FilterProvider instance for this screen
    _filterProvider = FilterProvider();
    
    // Load user info and menu permissions
    _loadUserInfo();
    _loadMenuPermissions();
    
    final initialUserId = widget.initialUserId;
    final initialUserLabel = widget.initialUserLabel;

    // Use local FilterProvider instance
    final filterProvider = _filterProvider;
    
    if (initialUserId != null && initialUserId.isNotEmpty) {
      filterProvider.addUser(initialUserId, label: initialUserLabel);
      if (initialUserLabel != null && initialUserLabel.isNotEmpty) {
        _selectedUserLabelMatchers.add(initialUserLabel.toLowerCase());
      }
    } else if (initialUserLabel != null && initialUserLabel.isNotEmpty) {
      final String labelKey = _labelOnlyKey(initialUserLabel);
      filterProvider.addUser(labelKey, label: initialUserLabel);
      _selectedUserLabelMatchers.add(initialUserLabel.toLowerCase());
    }

    if (filterProvider.selectedUserIds.isNotEmpty || _selectedUserLabelMatchers.isNotEmpty) {
      _selectedItem = NavItem.walletOverview;
    }

    // Apply initial filters if provided
    if (widget.initialSelectedItem != null) {
      _selectedItem = widget.initialSelectedItem!;
    } else {
      // For non-wallet users, default to All User Wallets view
      _checkAndSetDefaultForNonWalletUser();
    }
    if (widget.initialSelectedType != null) {
      filterProvider.setType(widget.initialSelectedType);
    }
    if (widget.initialSelectedStatus != null) {
      filterProvider.setStatus(widget.initialSelectedStatus);
      _selectedStatusSet.clear();
      _selectedStatusSet.add(widget.initialSelectedStatus!);
    }
    // Handle expense type category filter
    if (widget.initialSelectedExpenseTypeCategory != null) {
      _selectedExpenseTypeCategory = widget.initialSelectedExpenseTypeCategory;
    } else {
      // Explicitly clear expense type category filter if not provided
      // This ensures filters don't persist when navigating to other screens
      _selectedExpenseTypeCategory = null;
    }
    
    // If initial selected item is NOT expense report, ensure expense report filters are cleared
    if (widget.initialSelectedItem != NavItem.expenseReport) {
      _selectedExpenseTypeCategory = null;
      _isExpenseReportMode = false;
    } else {
      // If initial selected item IS expense report, set expense report mode immediately
      _isExpenseReportMode = true;
    }

    _initializeSocket();
    
    // Ensure socket is initialized for self wallet updates (all users, not just SuperAdmin)
    if (_selectedItem == NavItem.walletSelf) {
      SocketService.initialize();
    }
    
    // Listen to FilterProvider changes to auto-refresh All Wallet Report when filters change
    filterProvider.addListener(_onFilterChanged);
    
    _loadDashboardData();
    _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
    _loadActionButtonSettings();
    _loadAllUsers();
    _loadExpenseTypes();
    _loadPaymentModes();
    _loadUserInfo();
    _loadMenuPermissions();
    
    // Initialize dashboard header features
    _initializeDashboardHeader();

    // Start auto-refresh timer for automatic dashboard updates
    // Auto-refresh removed - only refresh on socket events (changes occur)

    // Apply filters after data is loaded if initial filters were provided
    if (widget.initialSelectedItem != null ||
        widget.initialSelectedType != null ||
        widget.initialSelectedStatus != null ||
        widget.initialSelectedExpenseTypeCategory != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        // Check mounted before accessing context or calling setState
        if (mounted && context.mounted) {
          _applyFilters(debounce: false);
        }
      });
    }
  }

  Future<void> _loadUserInfo() async {
    final userName = await AuthService.getUserName();
    if (mounted) {
      setState(() {
        _userName = userName;
      });
    }
  }

  /// Check if user is non-wallet user and set default view to All User Wallets
  Future<void> _checkAndSetDefaultForNonWalletUser() async {
    try {
      final isNonWallet = await AuthService.isNonWalletUser();
      final userRole = await AuthService.getUserRole();
      
      // Only apply default for non-wallet users (not SuperAdmin)
      // And only if no initialSelectedItem was provided
      if (isNonWallet && 
          userRole != 'SuperAdmin' && 
          userRole != 'Super Admin' &&
          widget.initialSelectedItem == null) {
        if (mounted) {
          setState(() {
            _selectedItem = NavItem.walletAll; // Default to All User Wallets
          });
        }
      }
    } catch (e) {
      print('Error checking non-wallet user for default view: $e');
    }
  }

  /// Load menu permissions and update state
  Future<void> _loadMenuPermissions() async {
    try {
      // Check if user is non-wallet user
      final isNonWallet = await AuthService.isNonWalletUser();
      
      // Check if user is Super Admin first
      final isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
      
      // Load individual menu item permissions
      // For non-wallet users, dashboard and walletSelf should be false
      final canViewDashboard = isNonWallet ? false : await UIPermissionChecker.canViewMenuItem('dashboard');
      final canViewWalletSelf = isNonWallet ? false : await UIPermissionChecker.canViewMenuItem('walletSelf');
      final canViewWalletAll = await UIPermissionChecker.canViewMenuItem('walletAll');
      final canViewWalletOverview = await UIPermissionChecker.canViewMenuItem('walletOverview');
      
      // Debug logging for walletOverview permission
      debugPrint('üîê [PERMISSIONS] All Wallet Report menu access: $canViewWalletOverview');
      if (!canViewWalletOverview) {
        final userPermissions = await AuthService.getUserPermissions();
        final walletReportPermissions = userPermissions.where((p) => 
          p.startsWith('wallet.report.') || p == 'wallet.report' || p == 'wallet.report.view'
        ).toList();
        debugPrint('üîê [PERMISSIONS] User has wallet.report.* permissions: $walletReportPermissions');
      }
      final canViewSmartApprovals = await UIPermissionChecker.canViewMenuItem('smartApprovals');
      final canViewUsers = await UIPermissionChecker.canViewMenuItem('users');
      final canViewRoles = await UIPermissionChecker.canViewMenuItem('roles');
      final canViewPaymentModes = await UIPermissionChecker.canViewMenuItem('paymentModes');
      final canViewAccountReports = await UIPermissionChecker.canViewMenuItem('accountReports');
      final canViewExpenseType = await UIPermissionChecker.canViewMenuItem('expenseType');
      final canViewExpenseReport = await UIPermissionChecker.canViewMenuItem('expenseReport');
      
      // Load parent menu permissions
      final canViewWalletMenu = await UIPermissionChecker.canViewWalletMenu();
      final canViewUsersMenu = await UIPermissionChecker.canViewUsersMenu();
      final canViewPaymentAccountsMenu = await UIPermissionChecker.canViewPaymentAccountsMenu();
      final canViewExpensesMenu = await UIPermissionChecker.canViewExpensesMenu();
      final canViewSettingsMenu = await UIPermissionChecker.canViewSettingsMenu();
      
      // Load Quick Actions permission - check for enable permission
      final canEnableQuickActions = await UIPermissionChecker.hasPermission('dashboard.quick_actions.enable') ||
                                     await UIPermissionChecker.hasPermission('dashboard.quick_actions');
      
      // Load Add Amount and Withdraw permissions
      final canAddAmount = await UIPermissionChecker.hasPermission('dashboard.quick_actions.add_amount');
      final canWithdraw = await UIPermissionChecker.hasPermission('dashboard.quick_actions.withdraw');
      
      // Load Flagged Financial Flow permission
      final canViewFlaggedFinancialFlow = await UIPermissionChecker.hasPermission('dashboard.flagged_financial_flow.enable') ||
                                          await UIPermissionChecker.hasPermission('dashboard.flagged_financial_flow');
      
      // Load Status Count Table permission
      final canViewStatusCountTable = await UIPermissionChecker.hasPermission('dashboard.status_count.view') ||
                                      await UIPermissionChecker.hasPermission('dashboard.status_count.enable') ||
                                      await UIPermissionChecker.hasPermission('dashboard.status_count');
      
      // Load Self Wallet sub-permissions
      final canViewSelfWalletTransaction = await PermissionActionChecker.canView('wallet.self.transaction');
      final canViewSelfWalletCollection = await PermissionActionChecker.canView('wallet.self.collection');
      final canViewSelfWalletExpenses = await PermissionActionChecker.canView('wallet.self.expenses');
      
      // Load Self Wallet Transaction action permissions
      final canCreateTransaction = await PermissionActionChecker.canCreate('wallet.self.transaction');
      final canEditTransaction = await PermissionActionChecker.canEdit('wallet.self.transaction');
      final canDeleteTransaction = await PermissionActionChecker.canDelete('wallet.self.transaction');
      final canRejectTransaction = await PermissionActionChecker.canReject('wallet.self.transaction');
      final canFlagTransaction = await PermissionActionChecker.canFlag('wallet.self.transaction');
      final canApproveTransaction = await PermissionActionChecker.canApprove('wallet.self.transaction');
      final canExportTransaction = await PermissionActionChecker.canExport('wallet.self.transaction');
      
      // Load Self Wallet Expenses action permissions
      final canCreateExpenses = await PermissionActionChecker.canCreate('wallet.self.expenses');
      final canEditExpenses = await PermissionActionChecker.canEdit('wallet.self.expenses');
      final canDeleteExpenses = await PermissionActionChecker.canDelete('wallet.self.expenses');
      final canRejectExpenses = await PermissionActionChecker.canReject('wallet.self.expenses');
      final canFlagExpenses = await PermissionActionChecker.canFlag('wallet.self.expenses');
      final canApproveExpenses = await PermissionActionChecker.canApprove('wallet.self.expenses');
      final canExportExpenses = await PermissionActionChecker.canExport('wallet.self.expenses');
      
      // Load Self Wallet Collection action permissions
      final canCreateCollection = await PermissionActionChecker.canCreate('wallet.self.collection');
      final canEditCollection = await PermissionActionChecker.canEdit('wallet.self.collection');
      final canDeleteCollection = await PermissionActionChecker.canDelete('wallet.self.collection');
      final canRejectCollection = await PermissionActionChecker.canReject('wallet.self.collection');
      final canFlagCollection = await PermissionActionChecker.canFlag('wallet.self.collection');
      final canApproveCollection = await PermissionActionChecker.canApprove('wallet.self.collection');
      final canExportCollection = await PermissionActionChecker.canExport('wallet.self.collection');
      
      // Load All Wallet Report Transaction action permissions
      // Check both wallet.report.* and wallet.all.* (wallet.all.* is used in backend)
      final canApproveReportTransaction = await PermissionActionChecker.canApprove('wallet.report.transaction') ||
                                          await PermissionActionChecker.canApprove('wallet.all.transaction');
      final canEditReportTransaction = await PermissionActionChecker.canEdit('wallet.report.transaction') ||
                                       await PermissionActionChecker.canEdit('wallet.all.transaction');
      final canDeleteReportTransaction = await PermissionActionChecker.canDelete('wallet.report.transaction') ||
                                         await PermissionActionChecker.canDelete('wallet.all.transaction');
      final canRejectReportTransaction = await PermissionActionChecker.canReject('wallet.report.transaction') ||
                                        await PermissionActionChecker.canReject('wallet.all.transaction');
      final canFlagReportTransaction = await PermissionActionChecker.canFlag('wallet.report.transaction') ||
                                       await PermissionActionChecker.canFlag('wallet.all.transaction');
      
      // Load All Wallet Report Collection action permissions
      // Check both wallet.report.* and wallet.all.* (wallet.all.* is used in backend)
      final canApproveReportCollection = await PermissionActionChecker.canApprove('wallet.report.collection') ||
                                         await PermissionActionChecker.canApprove('wallet.all.collection');
      final canEditReportCollection = await PermissionActionChecker.canEdit('wallet.report.collection') ||
                                      await PermissionActionChecker.canEdit('wallet.all.collection');
      final canDeleteReportCollection = await PermissionActionChecker.canDelete('wallet.report.collection') ||
                                        await PermissionActionChecker.canDelete('wallet.all.collection');
      final canRejectReportCollection = await PermissionActionChecker.canReject('wallet.report.collection') ||
                                        await PermissionActionChecker.canReject('wallet.all.collection');
      final canFlagReportCollection = await PermissionActionChecker.canFlag('wallet.report.collection') ||
                                      await PermissionActionChecker.canFlag('wallet.all.collection');
      
      // Load All Wallet Report Expenses action permissions
      // Check both wallet.report.* and wallet.all.* (wallet.all.* is used in backend)
      final canApproveReportExpenses = await PermissionActionChecker.canApprove('wallet.report.expenses') ||
                                       await PermissionActionChecker.canApprove('wallet.all.expenses');
      final canEditReportExpenses = await PermissionActionChecker.canEdit('wallet.report.expenses') ||
                                    await PermissionActionChecker.canEdit('wallet.all.expenses');
      final canDeleteReportExpenses = await PermissionActionChecker.canDelete('wallet.report.expenses') ||
                                      await PermissionActionChecker.canDelete('wallet.all.expenses');
      final canRejectReportExpenses = await PermissionActionChecker.canReject('wallet.report.expenses') ||
                                      await PermissionActionChecker.canReject('wallet.all.expenses');
      final canFlagReportExpenses = await PermissionActionChecker.canFlag('wallet.report.expenses') ||
                                    await PermissionActionChecker.canFlag('wallet.all.expenses');
      
      // Load All User Wallets action permissions (top-level)
      final canAddExpenseAll = await UIPermissionChecker.hasPermission('wallet.all.add_expense');
      final canAddAmountAll = await UIPermissionChecker.hasPermission('wallet.all.add_amount');
      final canAddCollectionAll = await UIPermissionChecker.hasPermission('wallet.all.add_collection');
      final canAddTransactionAll = await UIPermissionChecker.hasPermission('wallet.all.add_transaction');
      final canWithdrawAll = await UIPermissionChecker.hasPermission('wallet.all.withdraw');
      
      // Debug logging for All Wallet Report permissions
      if (isSuperAdmin) {
        debugPrint('üîê [PERMISSIONS] All Wallet Report - SuperAdmin: All permissions enabled');
      } else {
        // Get user permissions for detailed debugging
        final userPermissions = await AuthService.getUserPermissions();
        final walletReportPermissions = userPermissions.where((p) => 
          p.startsWith('wallet.report.') || p == 'wallet.report' || p == 'wallet.report.view'
        ).toList();
        
        debugPrint('üîê [PERMISSIONS] All Wallet Report - User Permissions Check:');
        debugPrint('   Total user permissions: ${userPermissions.length}');
        debugPrint('   Wallet.report.* permissions found: $walletReportPermissions');
        debugPrint('   Checking for: wallet.report.transaction, wallet.report.collection, wallet.report.expenses');
        debugPrint('üîê [PERMISSIONS] All Wallet Report - Transaction: approve=$canApproveReportTransaction, edit=$canEditReportTransaction, delete=$canDeleteReportTransaction, reject=$canRejectReportTransaction, flag=$canFlagReportTransaction');
        debugPrint('üîê [PERMISSIONS] All Wallet Report - Collection: approve=$canApproveReportCollection, edit=$canEditReportCollection, delete=$canDeleteReportCollection, reject=$canRejectReportCollection, flag=$canFlagReportCollection');
        debugPrint('üîê [PERMISSIONS] All Wallet Report - Expenses: approve=$canApproveReportExpenses, edit=$canEditReportExpenses, delete=$canDeleteReportExpenses, reject=$canRejectReportExpenses, flag=$canFlagReportExpenses');
        
        // Check specific permission names
        debugPrint('üîê [PERMISSIONS] Checking specific permission names:');
        debugPrint('   wallet.report.transaction: ${await UIPermissionChecker.hasPermission('wallet.report.transaction')}');
        debugPrint('   wallet.report.transaction.approve: ${await UIPermissionChecker.hasPermission('wallet.report.transaction.approve')}');
        debugPrint('   wallet.report.collection: ${await UIPermissionChecker.hasPermission('wallet.report.collection')}');
        debugPrint('   wallet.report.collection.approve: ${await UIPermissionChecker.hasPermission('wallet.report.collection.approve')}');
        debugPrint('   wallet.report.expenses: ${await UIPermissionChecker.hasPermission('wallet.report.expenses')}');
        debugPrint('   wallet.report.expenses.approve: ${await UIPermissionChecker.hasPermission('wallet.report.expenses.approve')}');
      }
      
      if (mounted) {
        setState(() {
          _isNonWalletUser = isNonWallet;
          _canViewDashboard = canViewDashboard;
          _canViewWalletSelf = canViewWalletSelf;
          _canViewWalletAll = canViewWalletAll;
          _canViewWalletOverview = canViewWalletOverview;
          debugPrint('üîê [PERMISSIONS] Setting _canViewWalletOverview=$canViewWalletOverview in setState');
          _canViewSmartApprovals = canViewSmartApprovals;
          _canViewUsers = canViewUsers;
          _canViewRoles = canViewRoles;
          _canViewPaymentModes = canViewPaymentModes;
          _canViewAccountReports = canViewAccountReports;
          _canViewExpenseType = canViewExpenseType;
          _canViewExpenseReport = canViewExpenseReport;
          _canViewWalletMenu = canViewWalletMenu;
          _canViewUsersMenu = canViewUsersMenu;
          _canViewPaymentAccountsMenu = canViewPaymentAccountsMenu;
          _canViewExpensesMenu = canViewExpensesMenu;
          _canViewSettingsMenu = canViewSettingsMenu;
          _canEnableQuickActions = canEnableQuickActions;
          _canAddAmount = canAddAmount;
          _canWithdraw = canWithdraw;
          _canViewFlaggedFinancialFlow = canViewFlaggedFinancialFlow;
          _canViewStatusCountTable = canViewStatusCountTable;
          _isSuperAdmin = isSuperAdmin;
          _canViewSelfWalletTransaction = canViewSelfWalletTransaction;
          _canViewSelfWalletCollection = canViewSelfWalletCollection;
          _canViewSelfWalletExpenses = canViewSelfWalletExpenses;
          
          // Set Transaction action permissions
          _canCreateTransaction = canCreateTransaction;
          _canEditTransaction = canEditTransaction;
          _canDeleteTransaction = canDeleteTransaction;
          _canRejectTransaction = canRejectTransaction;
          _canFlagTransaction = canFlagTransaction;
          _canApproveTransaction = canApproveTransaction;
          _canExportTransaction = canExportTransaction;
          
          // Set Expenses action permissions
          _canCreateExpenses = canCreateExpenses;
          _canEditExpenses = canEditExpenses;
          _canDeleteExpenses = canDeleteExpenses;
          _canRejectExpenses = canRejectExpenses;
          _canFlagExpenses = canFlagExpenses;
          // ALL users can approve expenses (not just SuperAdmin)
          _canApproveExpenses = true;
          _canExportExpenses = canExportExpenses;
          
          // Set Collection action permissions
          _canCreateCollection = canCreateCollection;
          _canEditCollection = canEditCollection;
          _canDeleteCollection = canDeleteCollection;
          _canRejectCollection = canRejectCollection;
          _canFlagCollection = canFlagCollection;
          _canApproveCollection = canApproveCollection;
          _canExportCollection = canExportCollection;
          
          // Set All Wallet Report Transaction action permissions
          _canApproveReportTransaction = canApproveReportTransaction;
          _canEditReportTransaction = canEditReportTransaction;
          _canDeleteReportTransaction = canDeleteReportTransaction;
          _canRejectReportTransaction = canRejectReportTransaction;
          _canFlagReportTransaction = canFlagReportTransaction;
          
          // Set All Wallet Report Collection action permissions
          _canApproveReportCollection = canApproveReportCollection;
          _canEditReportCollection = canEditReportCollection;
          _canDeleteReportCollection = canDeleteReportCollection;
          _canRejectReportCollection = canRejectReportCollection;
          _canFlagReportCollection = canFlagReportCollection;
          
          // Set All Wallet Report Expenses action permissions
          // ALL users can approve expenses (not just SuperAdmin)
          _canApproveReportExpenses = true;
          _canEditReportExpenses = canEditReportExpenses;
          _canDeleteReportExpenses = canDeleteReportExpenses;
          _canRejectReportExpenses = canRejectReportExpenses;
          _canFlagReportExpenses = canFlagReportExpenses;
          
          // Set All User Wallets action permissions (top-level)
          _canAddExpenseAll = canAddExpenseAll;
          _canAddAmountAll = canAddAmountAll;
          _canAddCollectionAll = canAddCollectionAll;
          _canAddTransactionAll = canAddTransactionAll;
          _canWithdrawAll = canWithdrawAll;
          
          _permissionsLoaded = true;
        });
        
        // Check if current selected item is accessible, if not redirect to dashboard
        _checkAndRedirectIfNeeded();
      }
    } catch (e) {
      print('Error loading menu permissions: $e');
      // On error, allow all access (fail open for backwards compatibility)
      if (mounted) {
        setState(() {
          _canViewDashboard = true;
          _canViewWalletSelf = true;
          _canViewWalletAll = true;
          _canViewWalletOverview = true;
          _canViewSmartApprovals = true;
          _canViewUsers = true;
          _canViewRoles = true;
          _canViewPaymentModes = true;
          _canViewAccountReports = true;
          _canViewExpenseType = true;
          _canViewExpenseReport = true;
          _canViewWalletMenu = true;
          _canViewUsersMenu = true;
          _canViewPaymentAccountsMenu = true;
          _canViewExpensesMenu = true;
          _isSuperAdmin = true; // On error, assume Super Admin (fail open)
          _canViewSelfWalletTransaction = true;
          _canViewSelfWalletCollection = true;
          _canViewSelfWalletExpenses = true;
          
          // Set all action permissions to true for SuperAdmin
          _canCreateTransaction = true;
          _canEditTransaction = true;
          _canDeleteTransaction = true;
          _canRejectTransaction = true;
          _canFlagTransaction = true;
          _canApproveTransaction = true;
          _canExportTransaction = true;
          
          _canCreateExpenses = true;
          _canEditExpenses = true;
          _canDeleteExpenses = true;
          _canRejectExpenses = true;
          _canFlagExpenses = true;
          _canApproveExpenses = true;
          _canExportExpenses = true;
          
          _canCreateCollection = true;
          _canEditCollection = true;
          _canDeleteCollection = true;
          _canRejectCollection = true;
          _canFlagCollection = true;
          _canApproveCollection = true;
          _canExportCollection = true;
          
          // Set All Wallet Report action permissions to true for SuperAdmin
          _canApproveReportTransaction = true;
          _canEditReportTransaction = true;
          _canDeleteReportTransaction = true;
          _canRejectReportTransaction = true;
          _canFlagReportTransaction = true;
          _canApproveReportCollection = true;
          _canEditReportCollection = true;
          _canDeleteReportCollection = true;
          _canRejectReportCollection = true;
          _canFlagReportCollection = true;
          _canApproveReportExpenses = true;
          _canEditReportExpenses = true;
          _canDeleteReportExpenses = true;
          _canRejectReportExpenses = true;
          _canFlagReportExpenses = true;
          
          // Set All User Wallets action permissions to true for SuperAdmin
          _canAddExpenseAll = true;
          _canAddAmountAll = true;
          _canAddCollectionAll = true;
          _canAddTransactionAll = true;
          _canWithdrawAll = true;
          
          _permissionsLoaded = true;
        });
      }
    }
  }
  
  /// Check if current selected item is accessible, redirect to dashboard if not
  void _checkAndRedirectIfNeeded() {
    bool canAccess = false;
    
    switch (_selectedItem) {
      case NavItem.dashboard:
        canAccess = _canViewDashboard;
        break;
      case NavItem.walletSelf:
        canAccess = _canViewWalletSelf;
        break;
      case NavItem.walletAll:
        canAccess = _canViewWalletAll;
        break;
      case NavItem.walletOverview:
        canAccess = _canViewWalletOverview;
        debugPrint('üîç [ACCESS CHECK] walletOverview - _canViewWalletOverview=$_canViewWalletOverview, canAccess=$canAccess');
        break;
      case NavItem.smartApprovals:
        canAccess = _canViewSmartApprovals;
        break;
      case NavItem.users:
        canAccess = _canViewUsers;
        break;
      case NavItem.roles:
        canAccess = _canViewRoles;
        break;
      case NavItem.assignWallets:
        // Allow access to Assign Wallets (coming soon screen)
        canAccess = _canViewUsersMenu;
        break;
      case NavItem.paymentModes:
        canAccess = _canViewPaymentModes;
        break;
      case NavItem.accountReports:
        canAccess = _canViewAccountReports;
        break;
      case NavItem.expenseType:
        canAccess = _canViewExpenseType;
        break;
      case NavItem.expenseReport:
        canAccess = _canViewExpenseReport;
        break;
      default:
        // For other items (transactionCollection, transactionTransfer, etc.)
        // Allow access for now (they might be accessed through dashboard)
        canAccess = true;
        break;
    }
    
          if (!canAccess && _canViewDashboard) {
      // Redirect to dashboard if current item is not accessible
      if (mounted) {
        _navigateToRoute(NavItem.dashboard);
      }
    }
  }

  // Dashboard Header Features - Initialization and Helper Methods
  void _initializeDashboardHeader() {
    // Set greeting based on time
    _greeting = _getGreeting();
    
    // Load user name for dashboard
    _loadDashboardUserName();
    
    // Load all dashboard header data
    _loadDashboardHeaderData();
  }

  String _getGreeting() {
    final hour = DateTime.now().hour;
    if (hour >= 5 && hour < 12) return 'Good Morning';
    if (hour >= 12 && hour < 17) return 'Good Afternoon';
    if (hour >= 17 && hour < 21) return 'Good Evening';
    return 'Good Night';
  }

  Future<void> _loadDashboardUserName() async {
    try {
      final userName = await AuthService.getUserName();
      if (mounted) {
        setState(() {
          _dashboardUserName = userName;
        });
      }
    } catch (e) {
      // Handle error silently, use default
      if (mounted) {
        setState(() {
          _dashboardUserName = 'User';
        });
      }
    }
  }

  Future<void> _loadDashboardHeaderData() async {
    await Future.wait([
      _fetchDailyQuote(),
      _loadUserFinancialSummary(),
      _loadStatusCounts(),
      _loadTimelineEntries(),
    ]);
  }

  Future<void> _fetchDailyQuote() async {
    if (!mounted) return;
    setState(() {
      _isLoadingQuote = true;
    });

    try {
      // Try to fetch from API
      final response = await Future.any([
        _fetchQuoteFromAPI(),
        Future.delayed(const Duration(seconds: 3), () => null),
      ]);

      if (!mounted) return;
      
      if (response != null) {
        setState(() {
          _dailyQuote = response['quote'] ?? '';
          _quoteAuthor = response['author'] ?? '';
          _isLoadingQuote = false;
        });
      } else {
        // Use fallback quote
        if (mounted) {
          _setFallbackQuote();
        }
      }
    } catch (e) {
      // Use fallback quote on error
      if (mounted) {
        _setFallbackQuote();
      }
    }
  }

  Future<Map<String, String>?> _fetchQuoteFromAPI() async {
    try {
      final response = await Future.any([
        // Try Quotable API
        _fetchQuotableAPI(),
        // Fallback to ZenQuotes
        _fetchZenQuotesAPI(),
      ]);
      return response;
    } catch (e) {
      return null;
    }
  }

  Future<Map<String, String>?> _fetchQuotableAPI() async {
    try {
      final client = HttpClient();
      final uri = Uri.parse('https://api.quotable.io/random?tags=business,money,success');
      final request = await client.getUrl(uri);
      final response = await request.close();
      
      if (response.statusCode == 200) {
        final jsonString = await response.transform(utf8.decoder).join();
        final json = jsonDecode(jsonString) as Map<String, dynamic>;
        return {
          'quote': json['content'] as String? ?? '',
          'author': json['author'] as String? ?? '',
        };
      }
    } catch (e) {
      // Silently fail and try next API
    }
    return null;
  }

  Future<Map<String, String>?> _fetchZenQuotesAPI() async {
    try {
      final client = HttpClient();
      final uri = Uri.parse('https://zenquotes.io/api/today');
      final request = await client.getUrl(uri);
      final response = await request.close();
      
      if (response.statusCode == 200) {
        final jsonString = await response.transform(utf8.decoder).join();
        final jsonList = jsonDecode(jsonString) as List<dynamic>;
        if (jsonList.isNotEmpty) {
          final quote = jsonList[0] as Map<String, dynamic>;
          return {
            'quote': quote['q'] as String? ?? '',
            'author': quote['a'] as String? ?? '',
          };
        }
      }
    } catch (e) {
      // Silently fail
    }
    return null;
  }

  void _setFallbackQuote() {
    // Curated financial quotes
    final quotes = [ 
            {'quote': '‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ§‡Øä‡Æü‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Øà‡Æ∞‡Æø‡ÆØ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡ÆÆ‡Øç ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡ØÅ ‡Æâ‡ÆØ‡Æø‡Æ∞‡Æø‡Æ©‡Øç ‡Æí‡Æ≥‡Æø.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 31'},
      {'quote': '‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æï‡Øä‡Æ£‡Øç‡Æü ‡ÆÆ‡Æ©‡ÆÆ‡Øç ‡ÆÖ‡Æö‡Ææ‡Æ§‡Øç‡ÆØ‡Æ§‡Øç‡Æ§‡Øà ‡Æö‡Ææ‡Æ§‡Æø‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æâ‡Æ£‡Øç‡ÆÆ‡Øà ‡Æ™‡Øá‡Æ£‡ØÅ‡Æµ‡Æ§‡ØÅ ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡ØÅ ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 298'},
      {'quote': '‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø ‡Æµ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡ÆÖ‡Æ§‡ØÅ ‡Æï‡Æ±‡Øç‡Æ±‡Æ≤‡Øç ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æö‡Øä‡Æ≤‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æü‡ØÅ ‡Æö‡Øä‡Æ≤‡Øç‡Æ≤‡Æ≤‡Øç ‡Æö‡Æø‡Æ±‡Æ™‡Øç‡Æ™‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 648'},
      {'quote': '‡Æï‡Æ©‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æö‡Æï‡Øç‡Æ§‡Æø ‡Æâ‡Æ¥‡Øà‡Æ™‡Øç‡Æ™‡Øá.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ©‡Øç‡Æ™‡Øá ‡Æâ‡ÆØ‡Æø‡Æ∞‡Æø‡Æ©‡ÆÆ‡Øç ‡Æµ‡Ææ‡Æ¥‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æü‡Æø‡Æ§‡Øç‡Æ§‡Æ≥‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 80'},
      {'quote': '‡Æö‡Ææ‡Æ§‡Æ©‡Øà ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æ§‡ØÅ‡Æ£‡Æø‡Æµ‡ØÅ ‡ÆÖ‡Æµ‡Æö‡Æø‡ÆØ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ®‡Æ≤‡Øç ‡Æé‡Æ£‡Øç‡Æ£‡ÆÆ‡Øç ‡Æ®‡Æ©‡Øç‡ÆÆ‡Øà‡ÆØ‡Øà ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 204'},
      {'quote': '‡Æâ‡Æ¥‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ©‡Æø‡Æ§‡Æ©‡Øà ‡Æö‡ØÜ‡ÆÆ‡Øç‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Øã‡Æ™‡ÆÆ‡Øç ‡Æï‡ØÜ‡Æü‡ØÅ‡Æ§‡Æ≤‡Øç ‡Æ™‡ÆØ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 305'},
      {'quote': '‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æ≤‡Øç‡Æ≤; ‡ÆÖ‡Æ§‡ØÅ ‡Æ§‡Øä‡Æü‡Æï‡Øç‡Æï‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡Æø‡Æµ‡Æø‡Æ©‡Øç ‡ÆÆ‡Øá‡Æ©‡Øç‡ÆÆ‡Øà ‡Æâ‡Æ≤‡Æï‡Øà ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 393'},
      {'quote': '‡Æâ‡Æ©‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡Øà ‡Æ®‡ØÄ‡ÆØ‡Øá ‡ÆÆ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øá ‡Æ§‡Æü‡ØÅ‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ®‡Æ©‡Øç‡Æ±‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ™‡Æµ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡ÆÆ‡Øà ‡Æ™‡Æø‡Æ±‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 106'},
      {'quote': '‡Æ™‡ÆØ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Ææ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Ææ‡Æ©‡Øç ‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Æ¥‡Æø.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æí‡Æ¥‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡Æø‡Æ©‡Øç ‡ÆÖ‡Æü‡Æø‡Æ§‡Øç‡Æ§‡Æ≥‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 138'},
      {'quote': '‡Æ®‡ØÄ ‡ÆÆ‡Ææ‡Æ±‡Æø‡Æ©‡Ææ‡Æ≤‡Øç ‡Æâ‡Æ≤‡Æï‡ÆÆ‡Øç ‡ÆÆ‡Ææ‡Æ±‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æµ‡Ææ ‡Æá‡Æ≤‡Øç‡Æ≤‡Ææ ‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà ‡Æá‡Æ©‡Øç‡Æ™‡ÆÆ‡Ææ‡Æ©‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 369'},
      {'quote': '‡Æâ‡ÆØ‡Æ∞‡ÆÆ‡Ææ‡Æï ‡Æ®‡Æø‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡Æâ‡ÆØ‡Æ∞‡ÆÆ‡Øç ‡Æâ‡Æ©‡Øç‡Æ©‡Øà‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Æø‡Æ±‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æ™‡Æï‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æµ‡Æ§‡Øá ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 213'},
      {'quote': '‡Æé‡Æ§‡Æø‡Æ∞‡Øç‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡Øà ‡Æµ‡Æø‡Æü ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø ‡ÆÖ‡Æ§‡Æø‡Æï‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æá‡Æ±‡Øà ‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡ÆÆ‡Æ©‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ ‡Æ§‡ØÅ‡Æ£‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 110'},
      {'quote': '‡Æ®‡Æü‡Øà‡Æ™‡ØÜ‡Æ±‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Æ∞‡Øà ‡Æ®‡ØÄ ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Øä‡Æ±‡ØÅ‡ÆÆ‡Øà ‡Æé‡Æ≤‡Øç‡Æ≤‡Ææ‡Æ™‡Øç ‡Æ™‡Æ≤‡Æ©‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Ææ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 150'},
      {'quote': '‡Æ®‡Æ≤‡Øç‡Æ≤ ‡ÆÆ‡Æ©‡ÆÆ‡Øç ‡Æ®‡Æ≤‡Øç‡Æ≤ ‡Æé‡Æ§‡Æø‡Æ∞‡Øç‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Æï‡Øà ‡Æ™‡Æ¥‡Æø ‡Æ™‡ÆØ‡Æ©‡Øç ‡Æ§‡Æ∞‡Ææ‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 154'},
      {'quote': '‡Æâ‡Æ¥‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡Æá‡Æ©‡Æø‡ÆÆ‡Øà ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æâ‡Æ£‡Øç‡ÆÆ‡Øà‡ÆØ‡Øà ‡Æ™‡Øá‡Æ£‡ØÅ‡Æ§‡Æ≤‡Øç ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡Æø‡Æ©‡Øç ‡Æö‡Æø‡Æ±‡Æ™‡Øç‡Æ™‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 298'},
      {'quote': '‡Æ®‡Æ≤‡Øç‡Æ≤ ‡Æé‡Æ£‡Øç‡Æ£‡ÆÆ‡Øç ‡Æí‡Æ∞‡ØÅ ‡Æ™‡ØÜ‡Æ∞‡Æø‡ÆØ ‡Æö‡Æï‡Øç‡Æ§‡Æø.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡ÆÆ‡Øç ‡Æ™‡Æø‡Æ¥‡Øà ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Ææ‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 30'},
      {'quote': '‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø ‡ÆÆ‡Æ≤‡Øà‡Æï‡Æ≥‡Øà ‡Æ®‡Æï‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Æø‡Æ±‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡Æï‡Øá‡Æü‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Ææ‡Æ§‡Æø‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ£‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 318'},
      {'quote': '‡Æ™‡ØÅ‡Æ§‡ØÅ ‡Æö‡Æø‡Æ®‡Øç‡Æ§‡Æ©‡Øà ‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æµ‡Ææ‡ÆØ‡Øç‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡Æ§‡Øç ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æµ‡Æö‡Æ∞‡ÆÆ‡Øç ‡Æ§‡ØÄ‡ÆØ‡Æø‡Æ©‡Øà ‡Æö‡ØÜ‡ÆØ‡Øç‡Æµ‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 675'},
      {'quote': '‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç ‡Æ™‡Øã‡Æ§‡Ææ‡Æ§‡ØÅ ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡Øá ‡Æ§‡Æµ‡Æ±‡ØÅ; ‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø ‡Æ™‡Øã‡Æ§‡Ææ‡Æ§‡ØÅ ‡Æ§‡Ææ‡Æ©‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æá‡Æï‡Æ¥‡Øç‡Æö‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Ææ‡Æ§‡Æø‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æ§‡ØÅ ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 449'},
      {'quote': '‡Æ®‡Øá‡Æ∞‡Øç‡ÆÆ‡Øà ‡Æé‡Æ®‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ≥‡Æø‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡Æí‡Æ≥‡Æø.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ®‡Æ≤‡Øç‡Æ≤ ‡Æö‡Øä‡Æ≤‡Øç ‡Æ®‡Æ≤‡Øç‡Æ≤ ‡Æ™‡ÆØ‡Æ©‡Øç ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 65'},
      {'quote': '‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç ‡Æ§‡Ææ‡Æ©‡Øç ‡Æï‡Æ©‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà ‡Æ®‡Æ©‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Æ±‡Øç‡Æ±‡Æµ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡Æï‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡Øá ‡Æ§‡Æ≤‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 393'},
      {'quote': '‡Æí‡Æ∞‡ØÅ ‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø ‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà‡ÆØ‡Æø‡Æ©‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ ‡ÆÖ‡Æ≤‡Øç‡Æ≤.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Øã‡Æ™‡Æ§‡Øç‡Æ§‡Øà ‡ÆÖ‡Æï‡Æ±‡Øç‡Æ±‡Æø ‡ÆÖ‡Æ©‡Øç‡Æ™‡Øà ‡Æµ‡Æ≥‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡ØÅ ‡Æï‡Øä‡Æ≥‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 315'},
      {'quote': '‡Æâ‡Æ©‡Øç‡Æ©‡Ææ‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ©‡Øç‡Æ± ‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æé‡Æ≤‡Øç‡Æ≤‡Ææ‡Æµ‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Æü‡Øà.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ‡Æü‡Øà‡ÆØ‡Ææ‡Æ∞‡Øç ‡Æ™‡Øá‡Æö‡ØÅ‡Æµ‡Æ§‡ØÅ ‡ÆÖ‡Æ¥‡Æï‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 421'},
      {'quote': '‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø ‡Æ™‡ØÜ‡Æ± ‡Æâ‡Æ©‡Øç ‡ÆÆ‡Æ©‡ÆÆ‡Øç ‡Æé‡Æ∞‡Æø‡ÆØ ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ®‡Æ≤‡Øç‡Æ≤ ‡Æö‡Øä‡Æ≤‡Øç ‡Æï‡Øá‡Æü‡Øç‡Æï ‡Æá‡Æ©‡Æø‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 64'},
      {'quote': '‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡ØÅ ‡Æ™‡ØÜ‡Æ± ‡Æâ‡Æ©‡Øç ‡ÆÆ‡Æ©‡Æ§‡Øà ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡Æø‡Æï‡Øç ‡Æï‡Øä‡Æ≥‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ©‡Øç‡Æ™‡ØÅ ‡Æâ‡Æ≤‡Æï‡Æ§‡Øç‡Æ§‡Øà ‡Æí‡Æ©‡Øç‡Æ±‡Ææ‡Æï‡Æ™‡Øç ‡Æ™‡Æø‡Æü‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 72'},    
      {'quote': '‡Æï‡Æ©‡Æµ‡ØÅ ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ§‡ØÇ‡Æô‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æ™‡Øã‡Æ§‡ØÅ ‡Æï‡Ææ‡Æ£‡Øç‡Æ™‡Æ§‡ØÅ ‡ÆÖ‡Æ≤‡Øç‡Æ≤; ‡Æµ‡Æø‡Æ¥‡Æø‡Æï‡Øç‡Æï ‡Æµ‡Øà‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ£‡Øç‡Æ£‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ§‡ØÄ‡ÆØ‡Æø‡Æ©‡Ææ‡Æ≤‡Øç ‡Æö‡ØÅ‡Æü‡Øç‡Æü ‡Æ™‡ØÅ‡Æ£‡Øç ‡ÆÜ‡Æ±‡ØÅ‡ÆÆ‡Øç; ‡Æ®‡Ææ‡Æµ‡Æø‡Æ©‡Ææ‡Æ≤‡Øç ‡Æö‡ØÅ‡Æü‡Øç‡Æü ‡Æµ‡Æü‡ØÅ ‡ÆÜ‡Æ±‡Ææ‡Æ§‡Øá.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 129'},
      {'quote': '‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø ‡Æµ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡Æï‡ØÇ‡Æü ‡Æµ‡Æø‡Æü‡Ææ‡ÆÆ‡Æ≤‡Øç ‡Æ®‡Æø‡ÆÆ‡Æø‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÅ ‡Æ®‡Æø‡Æ≤‡Øç; ‡ÆÖ‡Æ§‡ØÅ‡Æµ‡Øá ‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡Æ§‡Øç‡Æ§‡Øä‡Æü‡ØÅ ‡Æ®‡Æü‡ØÅ‡Æµ‡ØÅ ‡Æ®‡Æü‡Æï‡Øç‡Æï‡Æø‡Æ©‡Øç ‡Æá‡Æ≤‡Øç‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà ‡Æé‡Æ≤‡Øç‡Æ≤‡Ææ‡ÆÆ‡Øç ‡Æá‡Æ©‡Æø‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 985'},
      {'quote': '‡Æ®‡ØÄ ‡Æâ‡ÆØ‡Æ∞ ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ©‡Øç‡Æ±‡Ææ‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç ‡Æ®‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æ®‡Æü‡ØÅ‡Æï.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æé‡Æ£‡Øç‡Æ™‡Æ§‡ØÅ ‡Æé‡Æ£‡Øç‡Æ™‡Æ§‡Ææ‡ÆØ‡Æø‡Æ©‡ØÅ‡ÆÆ‡Øç ‡Æï‡Æ≤‡Øç‡Æµ‡Æø ‡Æá‡Æ≤‡Øç‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà ‡Æá‡Æ©‡Æø‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 400'},
      {'quote': '‡Æ®‡Ææ‡Æ≥‡Øà ‡Æ®‡Æ≤‡Øç‡Æ≤‡Æ§‡Ææ‡Æï‡Øç‡Æï ‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æ™‡Ææ‡Æü‡ØÅ‡Æ™‡Æü‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æâ‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æ£‡Øç‡Æü‡ØÅ ‡Æµ‡Ææ‡Æ¥‡Øç‡Æµ‡Ææ‡Æ∞‡Øá ‡Æµ‡Ææ‡Æ¥‡Øç‡Æµ‡Ææ‡Æ∞‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 1035'},
      {'quote': '‡Æö‡Æø‡Æ±‡Æø‡ÆØ ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Øà‡Æ§‡Øç‡Æ§‡ØÅ ‡Æµ‡Ææ‡Æ¥‡Øç‡Æµ‡Æ§‡ØÅ ‡Æ™‡ØÜ‡Æ∞‡Æø‡ÆØ ‡Æ§‡Æµ‡Æ±‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ©‡Øç‡Æ™‡ØÅ ‡ÆÖ‡ÆÆ‡Æ∞‡Æ∞‡Øç ‡Æ™‡Æ£‡Øç‡Æ™‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 72'},
      {'quote': '‡Æâ‡Æ©‡Æ§‡ØÅ ‡Æ§‡Æµ‡Æ±‡ØÅ ‡Æ§‡Ææ‡Æ©‡Øç ‡Æâ‡Æ©‡Æï‡Øç‡Æï‡ØÅ‡Æ™‡Øç ‡Æ™‡ØÜ‡Æ∞‡Æø‡ÆØ ‡ÆÜ‡Æö‡Æø‡Æ∞‡Æø‡ÆØ‡Æ∞‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Øá‡Æü‡Æø‡Æ≤‡Øç ‡Æµ‡Æø‡Æ¥‡ØÅ‡Æö‡Øç‡Æö‡ØÜ‡Æ≤‡Øç‡Æµ‡ÆÆ‡Øç ‡Æï‡Æ≤‡Øç‡Æµ‡Æø.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 400'},
      {'quote': '‡Æï‡Æ∑‡Øç‡Æü‡ÆÆ‡Øç ‡Æµ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øá ‡Æ®‡ÆÆ‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Æ≤‡Øç‡Æ≤‡ÆÆ‡Øà ‡ÆÖ‡Æ§‡Æø‡Æï‡Æ∞‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ®‡Æ©‡Øç‡Æ±‡Æø ‡ÆÆ‡Æ±‡Æ™‡Øç‡Æ™‡Ææ‡Æ©‡Øç ‡Æ®‡Æ©‡Øç‡ÆÆ‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 102'},
      {'quote': '‡Æï‡Ææ‡Æ≤‡Æ§‡Øç‡Æ§‡Øà ‡ÆÆ‡Æ§‡Æø‡Æ§‡Øç‡Æ§‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ™‡Æü‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æí‡Æ¥‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡Æâ‡Æü‡Øà‡ÆÆ‡Øà ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æµ‡ØÅ ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 131'},
      {'quote': '‡Æö‡Æø‡Æ®‡Øç‡Æ§‡Æ©‡Øà ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æø‡Æ©‡Ææ‡Æ≤‡Øç ‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ§‡Øã‡Æ±‡Øç‡Æ±‡Ææ‡Æ∞‡ØÅ‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æ±‡Øç‡Æ±‡Æø‡Æ©‡Øç ‡Æ§‡Øã‡Æ±‡Øç‡Æ™‡Ææ‡Æ∞‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 667'},
      {'quote': '‡Æí‡Æµ‡Øç‡Æµ‡Øä‡Æ∞‡ØÅ ‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø‡Æï‡Øç‡Æï‡Ææ‡Æ© ‡Æ™‡Æü‡Æø‡Æï‡Øç‡Æï‡Æü‡Øç‡Æü‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ∞‡ØÅ‡Æ≥‡Øç‡Æö‡ØÜ‡ÆØ‡Øç‡Æµ‡Ææ‡Æ©‡Øç ‡ÆÜ‡ÆØ‡ØÅ‡Æ≥‡Øç ‡Æ™‡ØÜ‡Æ±‡ØÅ‡Æµ‡Ææ‡Æ©‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 34'},
      {'quote': '‡Æâ‡Æ¥‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡ÆÆ‡Øç ‡Æ™‡Øä‡Æ±‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡Æ©‡Æø‡Æ§‡Æ©‡Øà ‡Æâ‡ÆØ‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç ‡Æö‡Æï‡Øç‡Æ§‡Æø.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æü‡Æø‡ÆØ‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡ÆÖ‡Æ§‡Æ∞‡ÆÆ‡Øç ‡Æï‡Øä‡Æ≤‡Øç‡Æ≤‡Ææ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 251'},
      {'quote': '‡Æ™‡Æü‡Øà‡Æ™‡Øç‡Æ™‡Ææ‡Æ±‡Øç‡Æ±‡Æø ‡Æï‡Øä‡Æ£‡Øç‡Æü‡Æµ‡Æ©‡Øç ‡Æé‡Æ§‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æö‡Ææ‡Æ§‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ±‡Ææ‡Æ©‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æö‡Øä‡Æ≤‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç ‡Æï‡ØÇ‡Æü‡Æø ‡Æö‡Øä‡Æ≤‡Øç‡Æ≤‡Æ≤‡Øç ‡Æ®‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 642'},
      {'quote': '‡Æ™‡ÆØ‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æá‡Æü‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡ØÅ ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æû‡Øç‡Æö‡Ææ‡ÆÆ‡Øà ‡Æ®‡Æ≤‡Øç‡Æ≤‡Ææ‡Æ£‡Øç‡ÆÆ‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 626'},
      {'quote': '‡Æâ‡Æ≤‡Æï‡ÆÆ‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç ‡Æ™‡ØÜ‡Æ± ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ©‡Øç‡Æ±‡Ææ‡Æ≤‡Øç ‡ÆÆ‡Æ©‡ÆÆ‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Øá‡Æü‡Øç‡Æü‡ØÅ ‡Æï‡Æ≤‡Øç‡Æµ‡Æø ‡Æï‡Æ±‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ®‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 411'},
      {'quote': '‡ÆÆ‡Æ©‡ÆÆ‡Øç ‡Æ§‡Ææ‡Æ©‡Øç ‡ÆÆ‡Æ©‡Æø‡Æ§‡Æ©‡Øà ‡ÆÜ‡Æ≥‡Øç‡Æï‡Æø‡Æ±‡Æ§‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ©‡Øç‡Æ™‡ØÅ‡Æü‡Øà‡ÆÆ‡Øà ‡ÆÆ‡Æ©‡Æø‡Æ§‡Æ©‡Øç ‡ÆÆ‡Øá‡Æ©‡Øç‡ÆÆ‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 76'},
      {'quote': '‡Æá‡Æ≥‡Øà‡Æû‡Æ©‡Øç ‡Æï‡Æ©‡Æµ‡ØÅ ‡Æï‡Ææ‡Æ£ ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç; ‡ÆÖ‡Æ§‡ØÅ ‡Æ®‡Ææ‡Æü‡Øç‡Æü‡Øà‡Æ™‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Øä‡Æ±‡Øà ‡Æâ‡Æ≤‡Æï‡Æ§‡Øç‡Æ§‡Øà ‡Æµ‡ØÜ‡Æ≤‡Øç‡Æ≤‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 151'},
      {'quote': '‡Æ™‡ØÅ‡Æ§‡Øç‡Æ§‡Æï‡ÆÆ‡Øç ‡Æ®‡ÆÆ‡Øç ‡Æµ‡Ææ‡Æ¥‡Øç‡Æµ‡Æø‡Æ©‡Øç ‡Æ™‡Øä‡Æï‡Øç‡Æï‡Æø‡Æ∑‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æá‡Æï‡Æ≤‡Æø‡Æ©‡Øç ‡Æá‡Æ©‡Øç‡ÆÆ‡Øà ‡Æá‡Æ©‡Øç‡Æ™‡ÆÆ‡Ææ‡Æ©‡Æ§‡ØÅ.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 160'},
      {'quote': '‡Æ®‡ØÄ ‡Æµ‡Æø‡Æ¥‡ØÅ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡Æ™‡Æ∞‡Æµ‡Ææ‡ÆØ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà; ‡Æé‡Æ¥‡Ææ‡ÆÆ‡Æ≤‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æ§‡Øá ‡Æ§‡Æµ‡Æ±‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æï‡Æ±‡Øç‡Æ±‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æ§‡Æø‡Æ≤‡Øç‡Æ≤‡Øà; ‡ÆÖ‡Æ§‡ØÅ ‡Æµ‡Ææ‡Æ¥‡Øç‡Æï‡Øç‡Æï‡Øà‡ÆØ‡Øá.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ‡Æü‡Øà‡ÆÆ‡Øà ‡ÆÜ‡Æ±‡Øç‡Æ±‡Æ≤‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 431'},
      {'quote': '‡Æí‡Æ∞‡Øá ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡Æø‡Æ≤‡Øç ‡ÆÆ‡Æ©‡Æ§‡Øà ‡Æ®‡Æø‡Æ≤‡Øà‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ§‡Æ≤‡Øà‡ÆÆ‡Øà ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ§‡Ææ‡Æô‡Øç‡Æï‡Æ≤‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 384'},
      {'quote': '‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø ‡Æ™‡ØÜ‡Æ± ‡Æí‡Æ∞‡Øá ‡Æµ‡Æ¥‡Æø: ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡Ææ‡Æ§‡Øá.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ§‡Æµ‡Æ±‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Ææ‡Æ§‡Æ§‡Øá ‡Æ®‡Æ≤‡Øç‡Æ≤‡Øä‡Æ¥‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 467'},
      {'quote': '‡Æá‡Æ≤‡Æü‡Øç‡Æö‡Æø‡ÆØ‡ÆÆ‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡Æ™‡Ææ‡Æ§‡Øà ‡Æ§‡Ææ‡Æ©‡Ææ‡Æï ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ™‡Æø‡Æ±‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÅ ‡Æá‡Æ©‡Øç‡Æ™‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Ææ‡ÆÆ‡Øç ‡Æá‡Æï‡Æ¥‡Øç‡Æö‡Øç‡Æö‡Æø ‡ÆÖ‡Æ≤‡Øç‡Æ≤.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 574'},
      {'quote': '‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æö‡Æø‡Æ®‡Øç‡Æ§‡Æ©‡Øà ‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æâ‡Æ≤‡Æï‡Øà ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡ÆÖ‡Æ∞‡Æø‡ÆØ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç ‡ÆÖ‡Æ∞‡Æø‡ÆØ‡Ææ‡Æ∞‡Ææ‡Æ≤‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 618'},
      {'quote': '‡Æï‡Æ£‡Øç‡ÆÆ‡ØÅ‡Æ©‡Øç ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Æü‡Øà ‡Æâ‡Æ©‡Øç‡Æ©‡Øà ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡Ææ‡Æ§‡ØÅ; ‡ÆÆ‡Æ©‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æ§‡Æü‡Øà ‡Æ§‡Ææ‡Æ©‡Øç ‡ÆÜ‡Æü‡ØÅ‡ÆÆ‡Øç.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æö‡Æø‡Æ±‡ØÅ ‡Æ§‡ØÅ‡Æ≥‡Æø ‡Æö‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÅ ‡Æ™‡ØÜ‡Æ∞‡ØÅ ‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡ÆÆ‡Øç.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 754'},
      {'quote': '‡Æâ‡Æ©‡Æï‡Øç‡Æï‡ØÅ‡Æ≥‡Øç‡Æ≥‡Øá ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æö‡Æï‡Øç‡Æ§‡Æø‡ÆØ‡Øà ‡Æ®‡ÆÆ‡Øç‡Æ™‡ØÅ.', 'author': '‡ÆÖ‡Æ™‡Øç‡Æ§‡ØÅ‡Æ≤‡Øç ‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç'},
      {'quote': '‡Æ§‡Æ©‡Øç‡Æ©‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Øà ‡ÆÆ‡Æ©‡Æø‡Æ§‡Æ©‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡ÆÜ‡Æ£‡Øà.', 'author': '‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ±‡Æ≥‡Øç 603'},
    ];
    
    // Rotate based on day of year
    final dayOfYear = DateTime.now().difference(DateTime(DateTime.now().year, 1, 1)).inDays;
    final selectedQuote = quotes[dayOfYear % quotes.length];
    
    if (mounted) {
      setState(() {
        _dailyQuote = selectedQuote['quote']!;
        _quoteAuthor = selectedQuote['author']!;
        _isLoadingQuote = false;
      });
    }
  }

  Future<void> _loadUserFinancialSummary() async {
    if (!mounted) return;
    
    // Skip updating _userCashIn, _userCashOut, _userBalance if in Self Wallet mode
    // These values are managed by _loadFinancialData() instead
    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    final bool isDashboard = _selectedItem == NavItem.dashboard;
    
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    debugPrint('üí∞ [LOAD SUMMARY] _loadUserFinancialSummary() - START');
    debugPrint('   _isExpenseReportMode=$_isExpenseReportMode');
    debugPrint('   _selectedItem=$_selectedItem');
    debugPrint('   Current values BEFORE:');
    debugPrint('      _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
    debugPrint('      _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
    
    // Early return: Don't run this function at all if in Self Wallet mode
    // _loadFinancialData() handles the values for Self Wallet
    if (isSelfWallet) {
      debugPrint('[SELF WALLET] ‚è≠Ô∏è  Skipping _loadUserFinancialSummary() - Self Wallet mode');
      debugPrint('üí∞ [LOAD SUMMARY] _loadUserFinancialSummary() - END (skipped)');
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return;
    }
    
    // Early return: Don't run this function if in Expense Report mode
    // _loadFinancialData() handles the values for Expense Report (calculates from filtered expenses)
    if (_isExpenseReportMode) {
      debugPrint('[EXPENSE REPORT] ‚è≠Ô∏è  Skipping _loadUserFinancialSummary() - Expense Report mode (values managed by _loadFinancialData)');
      debugPrint('üí∞ [LOAD SUMMARY] _loadUserFinancialSummary() - END (skipped)');
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return;
    }
    
    setState(() {
      _isLoadingFinancialSummary = true;
    });

    try {
      // If on dashboard, load self wallet report to get self wallet values for dashboard cards
      if (isDashboard) {
        debugPrint('[DASHBOARD] üìä Loading self wallet summary for dashboard cards...');
        
        // Load self wallet report (use current filter dates if available)
        final selfWalletResult = await WalletService.getSelfWalletReport(
          startDate: _filterProvider.startDate,
          endDate: _filterProvider.endDate,
          // No mode/status/type filters - get all data for dashboard summary
        );
        
        if (!mounted) return;
        
        if (selfWalletResult['success'] == true && selfWalletResult['summary'] != null) {
          // Extract summary from self wallet report (same structure as _loadFinancialData)
          final summaryRaw = selfWalletResult['summary'];
          final summaryMap = summaryRaw is Map<String, dynamic>
              ? Map<String, dynamic>.from(summaryRaw)
              : (summaryRaw is Map
                  ? Map<String, dynamic>.from(summaryRaw as Map)
                  : <String, dynamic>{});
          
          if (summaryMap.isNotEmpty) {
            // Parse values using same logic as _loadFinancialData (lines 2729-2773)
            double summaryCashIn = 0.0;
            double summaryCashOut = 0.0;
            double summaryBalance = 0.0;
            
            final cashInRaw = summaryMap['cashIn'];
            final cashOutRaw = summaryMap['cashOut'];
            final balanceRaw = summaryMap['balance'];
            
            // Parse Cash In
            try {
              if (cashInRaw != null) {
                summaryCashIn = (cashInRaw is num) ? cashInRaw.toDouble() : double.tryParse(cashInRaw.toString()) ?? 0.0;
              } else {
                summaryCashIn = 0.0;
              }
            } catch (e) {
              debugPrint('[DASHBOARD] ‚ùå Error parsing Cash In: $e');
              summaryCashIn = 0.0;
            }
            
            // Parse Cash Out
            try {
              if (cashOutRaw != null) {
                summaryCashOut = (cashOutRaw is num) ? cashOutRaw.toDouble() : double.tryParse(cashOutRaw.toString()) ?? 0.0;
              } else {
                summaryCashOut = 0.0;
              }
            } catch (e) {
              debugPrint('[DASHBOARD] ‚ùå Error parsing Cash Out: $e');
              summaryCashOut = 0.0;
            }
            
            // Parse Balance
            try {
              if (balanceRaw != null) {
                summaryBalance = (balanceRaw is num) ? balanceRaw.toDouble() : double.tryParse(balanceRaw.toString()) ?? 0.0;
              } else {
                summaryBalance = 0.0;
              }
            } catch (e) {
              debugPrint('[DASHBOARD] ‚ùå Error parsing Balance: $e');
              summaryBalance = 0.0;
            }
            
            debugPrint('[DASHBOARD] ‚úÖ Self wallet summary loaded: CashIn=$summaryCashIn, CashOut=$summaryCashOut, Balance=$summaryBalance');
            
            if (mounted) {
              setState(() {
                _userCashIn = summaryCashIn;
                _userCashOut = summaryCashOut;
                _userBalance = summaryBalance;
                _isLoadingFinancialSummary = false;
              });
            }
            return; // Successfully loaded self wallet values, exit early
          } else {
            debugPrint('[DASHBOARD] ‚ö†Ô∏è  Self wallet summary map is empty, falling back to dashboard summary');
          }
        } else {
          debugPrint('[DASHBOARD] ‚ö†Ô∏è  Self wallet report failed or no summary, falling back to dashboard summary');
        }
      }
      
      // Fallback: Use dashboard summary endpoint for all users data (original logic)
      final summaryResult = await DashboardService.getDashboardSummary();
      if (!mounted) return;
      
      if (summaryResult['success'] == true && summaryResult['data'] != null) {
        final data = summaryResult['data'] as Map<String, dynamic>;
        final financialSummary = data['financialSummary'] as Map<String, dynamic>? ?? {};
        
        final cashIn = (financialSummary['cashIn'] as num?)?.toDouble() ?? 0.0;
        final cashOut = (financialSummary['cashOut'] as num?)?.toDouble() ?? 0.0;
        final balance = (financialSummary['balance'] as num?)?.toDouble() ?? 0.0;
        
        if (mounted) {
          setState(() {
            // Only update financial summary values if NOT in Self Wallet mode
            // In Self Wallet mode, _loadFinancialData() handles these values
            if (!isSelfWallet) {
            _userBalance = balance;
            _userCashIn = cashIn;
            _userCashOut = cashOut;
            }
            _isLoadingFinancialSummary = false;
          });
          debugPrint('üí∞ [LOAD SUMMARY] _loadUserFinancialSummary() - END');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
      } else {
        // Fallback to wallet if summary fails
        final walletResult = await WalletService.getWallet();
        if (!mounted) return;
        
        if (walletResult['success'] == true && walletResult['wallet'] != null) {
          final wallet = walletResult['wallet'] as Map<String, dynamic>;
          final cashBalance = (wallet['cashBalance'] as num?)?.toDouble() ?? 0.0;
          final upiBalance = (wallet['upiBalance'] as num?)?.toDouble() ?? 0.0;
          final bankBalance = (wallet['bankBalance'] as num?)?.toDouble() ?? 0.0;
          final balance = cashBalance + upiBalance + bankBalance;
          
          if (mounted) {
            setState(() {
              // Only update financial summary values if NOT in Self Wallet mode
              if (!isSelfWallet) {
              _userBalance = balance;
              _userCashIn = balance;
              _userCashOut = 0.0;
              }
              _isLoadingFinancialSummary = false;
            });
          }
        } else {
          if (mounted) {
            setState(() {
              // Only reset to zero if NOT in Self Wallet mode
              if (!isSelfWallet) {
              _userBalance = 0.0;
              _userCashIn = 0.0;
              _userCashOut = 0.0;
              }
              _isLoadingFinancialSummary = false;
            });
          }
        }
      }
    } catch (e) {
      debugPrint('[DASHBOARD] ‚ùå Error loading financial summary: $e');
      // On error, start fresh with 0.0 values (only if NOT in Self Wallet mode)
      if (mounted) {
        setState(() {
          // Only reset to zero if NOT in Self Wallet mode
          if (!isSelfWallet) {
          _userBalance = 0.0;
          _userCashIn = 0.0;
          _userCashOut = 0.0;
          }
          _isLoadingFinancialSummary = false;
        });
      }
    }
  }

  Future<void> _loadStatusCounts() async {
    if (!mounted) return;
    setState(() {
      _isLoadingStatusCounts = true;
    });

    try {
      // Use new dashboard summary endpoint
      final summaryResult = await DashboardService.getDashboardSummary();
      if (!mounted) return;
      
      debugPrint('[DASHBOARD] üìä Dashboard summary result: ${summaryResult['success']}');
      debugPrint('[DASHBOARD] üìä Dashboard summary data: ${summaryResult['data']}');
      
      if (summaryResult['success'] == true && summaryResult['data'] != null) {
        final data = summaryResult['data'] as Map<String, dynamic>;
        final statusCounts = data['statusCounts'] as Map<String, dynamic>? ?? {};
        
        debugPrint('[DASHBOARD] üìä Status counts received: $statusCounts');
        
        // Transform backend format to frontend format
        final expenses = (statusCounts['expenses'] is Map) ? (statusCounts['expenses'] as Map<String, dynamic>) : <String, dynamic>{};
        final transactions = (statusCounts['transactions'] is Map) ? (statusCounts['transactions'] as Map<String, dynamic>) : <String, dynamic>{};
        final collections = (statusCounts['collections'] is Map) ? (statusCounts['collections'] as Map<String, dynamic>) : <String, dynamic>{};
        
        debugPrint('[DASHBOARD] üìä Expenses: $expenses');
        debugPrint('[DASHBOARD] üìä Transactions: $transactions');
        debugPrint('[DASHBOARD] üìä Collections: $collections');
        
        if (mounted) {
          setState(() {
            // Store both count and amount for each status (backend sends {count: X, amount: Y})
            _statusCounts = {
              'expenses': {
                'approved': expenses['approved'] ?? {'count': 0, 'amount': 0},
                'unapproved': expenses['unapproved'] ?? {'count': 0, 'amount': 0},
                'flagged': expenses['flagged'] ?? {'count': 0, 'amount': 0},
                'total': expenses['total'] ?? {'count': 0, 'amount': 0},
              },
              'transactions': {
                'approved': transactions['approved'] ?? {'count': 0, 'amount': 0},
                'unapproved': transactions['unapproved'] ?? {'count': 0, 'amount': 0},
                'flagged': transactions['flagged'] ?? {'count': 0, 'amount': 0},
                'total': transactions['total'] ?? {'count': 0, 'amount': 0},
              },
              'collections': {
                'accounted': collections['accounted'] ?? {'count': 0, 'amount': 0},
                'unaccounted': collections['unaccounted'] ?? {'count': 0, 'amount': 0},
                'flagged': collections['flagged'] ?? {'count': 0, 'amount': 0},
                'total': collections['total'] ?? {'count': 0, 'amount': 0},
              },
            };
            
            debugPrint('[DASHBOARD] üìä Final _statusCounts set to: $_statusCounts');
            _isLoadingStatusCounts = false;
          });
        }
      } else {
        // Fallback to calculating from _allData if available
        if (_allData.isNotEmpty) {
          _calculateStatusCountsFromData(_allData);
        } else {
          if (mounted) {
            setState(() {
              _isLoadingStatusCounts = false;
            });
          }
        }
      }
    } catch (e) {
      // Fallback to calculating from _allData
      if (_allData.isNotEmpty) {
        _calculateStatusCountsFromData(_allData);
      } else {
        if (mounted) {
          setState(() {
            _isLoadingStatusCounts = false;
          });
        }
      }
    }
  }

  void _calculateStatusCountsFromData(List<dynamic> data) {
    final expenses = data.where((item) => item['type'] == 'Expenses').toList();
    final transactions = data.where((item) => item['type'] == 'Transactions').toList();
    final collections = data.where((item) => item['type'] == 'Collections').toList();

    // Calculate expenses counts and amounts
    int expensesApprovedCount = 0;
    double expensesApprovedAmount = 0.0;
    int expensesUnapprovedCount = 0;
    double expensesUnapprovedAmount = 0.0;
    int expensesFlaggedCount = 0;
    double expensesFlaggedAmount = 0.0;
    for (var expense in expenses) {
      final status = (expense['status'] as String? ?? '').toLowerCase();
      final amount = (expense['amount'] as num?)?.toDouble() ?? 0.0;
      if (status == 'approved' || status == 'completed') {
        expensesApprovedCount++;
        expensesApprovedAmount += amount;
      } else if (status == 'flagged') {
        expensesFlaggedCount++;
        expensesFlaggedAmount += amount;
      } else {
        expensesUnapprovedCount++;
        expensesUnapprovedAmount += amount;
      }
    }

    // Calculate transactions counts and amounts
    int transactionsApprovedCount = 0;
    double transactionsApprovedAmount = 0.0;
    int transactionsUnapprovedCount = 0;
    double transactionsUnapprovedAmount = 0.0;
    int transactionsFlaggedCount = 0;
    double transactionsFlaggedAmount = 0.0;
    for (var transaction in transactions) {
      final status = (transaction['status'] as String? ?? '').toLowerCase();
      final amount = (transaction['amount'] as num?)?.toDouble() ?? 0.0;
      if (status == 'approved' || status == 'completed') {
        transactionsApprovedCount++;
        transactionsApprovedAmount += amount;
      } else if (status == 'flagged') {
        transactionsFlaggedCount++;
        transactionsFlaggedAmount += amount;
      } else {
        transactionsUnapprovedCount++;
        transactionsUnapprovedAmount += amount;
      }
    }

    // Calculate collections counts and amounts
    int collectionsAccountedCount = 0;
    double collectionsAccountedAmount = 0.0;
    int collectionsUnaccountedCount = 0;
    double collectionsUnaccountedAmount = 0.0;
    int collectionsFlaggedCount = 0;
    double collectionsFlaggedAmount = 0.0;
    for (var collection in collections) {
      final status = (collection['status'] as String? ?? '').toLowerCase();
      final amount = (collection['amount'] as num?)?.toDouble() ?? 0.0;
      if (status == 'verified' || status == 'approved') {
        collectionsAccountedCount++;
        collectionsAccountedAmount += amount;
      } else if (status == 'flagged') {
        collectionsFlaggedCount++;
        collectionsFlaggedAmount += amount;
      } else {
        collectionsUnaccountedCount++;
        collectionsUnaccountedAmount += amount;
      }
    }

    if (mounted) {
      setState(() {
        // Store in same format as API response: {count: X, amount: Y}
        _statusCounts = {
          'expenses': {
            'approved': {'count': expensesApprovedCount, 'amount': expensesApprovedAmount},
            'unapproved': {'count': expensesUnapprovedCount, 'amount': expensesUnapprovedAmount},
            'flagged': {'count': expensesFlaggedCount, 'amount': expensesFlaggedAmount},
            'total': {'count': expenses.length, 'amount': expenses.fold<double>(0.0, (sum, e) => sum + ((e['amount'] as num?)?.toDouble() ?? 0.0))},
          },
          'transactions': {
            'approved': {'count': transactionsApprovedCount, 'amount': transactionsApprovedAmount},
            'unapproved': {'count': transactionsUnapprovedCount, 'amount': transactionsUnapprovedAmount},
            'flagged': {'count': transactionsFlaggedCount, 'amount': transactionsFlaggedAmount},
            'total': {'count': transactions.length, 'amount': transactions.fold<double>(0.0, (sum, t) => sum + ((t['amount'] as num?)?.toDouble() ?? 0.0))},
          },
          'collections': {
            'accounted': {'count': collectionsAccountedCount, 'amount': collectionsAccountedAmount},
            'unaccounted': {'count': collectionsUnaccountedCount, 'amount': collectionsUnaccountedAmount},
            'flagged': {'count': collectionsFlaggedCount, 'amount': collectionsFlaggedAmount},
            'total': {'count': collections.length, 'amount': collections.fold<double>(0.0, (sum, c) => sum + ((c['amount'] as num?)?.toDouble() ?? 0.0))},
          },
        };
        debugPrint('[DASHBOARD] üìä Calculated _statusCounts from _allData: $_statusCounts');
      });
    }
  }

  Future<void> _loadTimelineEntries() async {
    if (!mounted) return;
    setState(() {
      _isLoadingTimeline = true;
    });

    try {
      print('üö© [FLAGGED ITEMS] Starting to load flagged items...');
      
      // Get current logged-in user ID
      final currentUserId = await AuthService.getUserId();
      print('üö© [FLAGGED ITEMS] Current User ID: ${currentUserId ?? "NULL"}');
      
      // If no user ID, don't load flagged items
      if (currentUserId == null || currentUserId.isEmpty) {
        print('üö© [FLAGGED ITEMS] ‚ùå No user ID found - cannot load flagged items');
        if (mounted) {
          setState(() {
            _timelineItems = [];
            _isLoadingTimeline = false;
          });
        }
        return;
      }
      
      // Load flagged items from dashboard summary endpoint
      // Pass current user ID so backend filters flagged items that belong to this user
      print('üö© [FLAGGED ITEMS] Calling API with userId: $currentUserId');
      final summaryResult = await DashboardService.getDashboardSummary(userId: currentUserId);
      if (!mounted) return;
      
      print('üö© [FLAGGED ITEMS] API Response - success: ${summaryResult['success']}');
      
      if (summaryResult['success'] == true && summaryResult['data'] != null) {
        final data = summaryResult['data'] as Map<String, dynamic>;
        // Backend already filters by user ownership, so use all flagged items returned
        final flaggedItems = data['flaggedItems'] as List<dynamic>? ?? [];
        
        print('üö© [FLAGGED ITEMS] ‚úÖ Received ${flaggedItems.length} flagged items from API');
        if (flaggedItems.isNotEmpty) {
          print('üö© [FLAGGED ITEMS] First item type: ${flaggedItems[0] is Map ? (flaggedItems[0] as Map)['type'] : 'unknown'}');
        }
        
        // Convert flagged items to timeline format with proper structure
        final convertedFlaggedItems = _convertFlaggedItemsToTimelineFormat(flaggedItems);
        print('üö© [FLAGGED ITEMS] ‚úÖ Converted to ${convertedFlaggedItems.length} timeline items');
        
        // Filter out any items that were just resubmitted (safeguard in case backend hasn't updated yet)
        final filteredItems = convertedFlaggedItems.where((item) {
          final itemData = item as Map<String, dynamic>;
          if (itemData['type'] == 'flagged') {
            final financialData = itemData['financialData'] as Map<String, dynamic>? ?? {};
            final expenseId = financialData['expenseId']?.toString() ?? '';
            final collectionId = financialData['collectionId']?.toString() ?? '';
            final transactionId = financialData['transactionId']?.toString() ?? '';
            final itemId = expenseId.isNotEmpty ? expenseId : (collectionId.isNotEmpty ? collectionId : transactionId);
            
            if (_resubmittedItemIds.contains(itemId)) {
              print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Filtering out resubmitted item: $itemId');
              return false;
            }
          }
          return true;
        }).toList();
        
        // Safe debug logging
        try {
          debugPrint('üö© [FLAGGED ITEMS] ‚úÖ After filtering resubmitted items: ${filteredItems.length} timeline items');
        } catch (e) {
          // Ignore debug errors
        }
        
        if (mounted) {
          setState(() {
            _timelineItems = filteredItems;
            _isLoadingTimeline = false;
          });
          print('üö© [FLAGGED ITEMS] ‚úÖ Timeline items updated in state');
        }
      } else {
        print('üö© [FLAGGED ITEMS] ‚ùå API call failed or no data returned');
        print('üö© [FLAGGED ITEMS] Response message: ${summaryResult['message'] ?? 'No message'}');
        if (mounted) {
          setState(() {
            _timelineItems = [];
            _isLoadingTimeline = false;
          });
        }
      }
    } catch (e) {
      print('üö© [FLAGGED ITEMS] ‚ùå ERROR loading flagged items: $e');
      print('üö© [FLAGGED ITEMS] Stack trace: ${StackTrace.current}');
      if (mounted) {
        setState(() {
          _timelineItems = [];
          _isLoadingTimeline = false;
        });
      }
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_routeArgumentsApplied) {
      return;
    }

    final route = ModalRoute.of(context);
    final arguments = route?.settings.arguments;

    String? routeUserId;
    String? routeUserLabel;

    if (arguments is Map) {
      final dynamic idValue = arguments['initialUserId'];
      final dynamic labelValue = arguments['initialUserLabel'];

      if (idValue != null && idValue.toString().isNotEmpty) {
        routeUserId = idValue.toString();
      }
      if (labelValue != null && labelValue.toString().isNotEmpty) {
        routeUserLabel = labelValue.toString();
      }
    }

    final bool hasRouteId = routeUserId != null && routeUserId.isNotEmpty;
    final bool hasRouteLabel = routeUserLabel != null && routeUserLabel.isNotEmpty;

    if (hasRouteId || hasRouteLabel) {
      // Get FilterProvider for global user filter
      final filterProvider = _filterProvider;
      
      final bool shouldUpdateSelection = (hasRouteId && !filterProvider.selectedUserIds.contains(routeUserId)) ||
          (hasRouteLabel &&
              !_selectedUserLabelMatchers.contains(routeUserLabel!.toLowerCase()));
      final bool shouldUpdateItem = _selectedItem != NavItem.walletOverview;

      if (shouldUpdateSelection || shouldUpdateItem) {
        setState(() {
          filterProvider.clearUserFilter();
          _selectedUserLabelMatchers.clear();

          if (hasRouteId && routeUserId != null && routeUserId.isNotEmpty) {
            filterProvider.addUser(routeUserId, label: hasRouteLabel ? routeUserLabel! : routeUserId);
          }

          if (hasRouteLabel && routeUserLabel != null && routeUserLabel.isNotEmpty) {
            final String labelKey =
                hasRouteId && routeUserId != null && routeUserId.isNotEmpty
                    ? routeUserId
                    : _labelOnlyKey(routeUserLabel);
            filterProvider.addUser(labelKey, label: routeUserLabel);
            _selectedUserLabelMatchers.add(routeUserLabel.toLowerCase());
          }

          if (shouldUpdateItem) {
            _selectedItem = NavItem.walletOverview;
          }
        });
        if (_allData.isNotEmpty) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            // Check mounted before accessing context or calling setState
            if (mounted && context.mounted) {
              _applyFilters();
            }
          });
        }
      }
    }

    _routeArgumentsApplied = true;
  }

  @override
  void dispose() {
    // Remove FilterProvider listener and dispose
    try {
      _filterProvider.removeListener(_onFilterChanged);
      _filterProvider.dispose();
    } catch (e) {
      // Ignore if already disposed
    }
    
    _hamburgerAnimationController.dispose();
    // Clean up form controllers
    _amountController.dispose();
    _remarkController.dispose();
    _expenseAmountController.dispose();
    _expenseDescriptionController.dispose();
    _expenseRemarkController.dispose();
    _collectionCustomerNameController.dispose();
    _collectionAmountController.dispose();
    _collectionNotesController.dispose();
    _transactionAmountController.dispose();
    _transactionPurposeController.dispose();
    // Clean up ValueNotifier
    _paymentModesLoadedNotifier.dispose();
    // Clean up debounce timers
    _debounceTimer?.cancel();
    _filterChangeTimer?.cancel();
    // Clean up socket listeners
    try {
      SocketService.offAllWalletReportsUpdate();
      final socket = SocketService.socket;
      if (socket != null) {
        socket.off('expenseUpdate');
        socket.off('transactionUpdate');
        socket.off('collectionUpdate');
        socket.off('expenseCreated');
        socket.off('transactionCreated');
        socket.off('collectionCreated');
        socket.off('expenseUpdated');
        socket.off('transactionUpdated');
        socket.off('collectionUpdated');
        socket.off('dashboardSummaryUpdate');
        // Clean up new socket listeners
        socket.off('userCreated');
        socket.off('userUpdated');
        socket.off('userDeleted');
        socket.off('roleCreated');
        socket.off('roleUpdated');
        socket.off('roleDeleted');
        socket.off('paymentModeCreated');
        socket.off('paymentModeUpdated');
        socket.off('paymentModeDeleted');
        socket.off('paymentModeStatusChanged');
      }
    } catch (e) {
      print('Error cleaning up socket listeners: $e');
    }
    super.dispose();
  }

  /// Callback when FilterProvider changes - auto-refresh All Wallet Report
  void _onFilterChanged() {
    final bool isAllWalletReport = _selectedItem == NavItem.walletOverview;
    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    debugPrint('üìä [FILTER CHANGED] FilterProvider changed detected');
    debugPrint('   Current screen: $_selectedItem');
    debugPrint('   Is walletOverview: $isAllWalletReport');
    debugPrint('   Is walletSelf: $isSelfWallet');
    debugPrint('   Is mounted: $mounted');
    debugPrint('   _isApplyingFilters: $_isApplyingFilters');
    debugPrint('   _isLoadingFinancialData: $_isLoadingFinancialData');
    
    // Prevent recursive calls - if _applyFilters is running, ignore filter changes
    if (_isApplyingFilters) {
      debugPrint('   ‚ö†Ô∏è  BLOCKED: _isApplyingFilters is true - skipping API reload');
      if (isSelfWallet) {
        debugPrint('   [SELF WALLET] Will wait for _applyFilters to complete');
      }
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return;
    }
    
    // Prevent multiple concurrent API calls - if already loading, skip
    if (_isLoadingFinancialData) {
      debugPrint('   ‚ö†Ô∏è  BLOCKED: _isLoadingFinancialData is true - already loading data');
      if (isSelfWallet) {
        debugPrint('   [SELF WALLET] API call already in progress, skipping duplicate call');
      }
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return;
    }
    
    // Refresh if currently viewing All Wallet Report OR Self Wallet
    if ((isAllWalletReport || isSelfWallet) && mounted) {
      if (isAllWalletReport) {
        debugPrint('üìä [ALL WALLET REPORTS] Conditions met - scheduling refresh...');
      } else {
        debugPrint('üìä [SELF WALLET] ‚úÖ Conditions met - scheduling API reload...');
        final filterProvider = _filterProvider;
        debugPrint('   Active filters:');
        debugPrint('     - Type: ${filterProvider.selectedType ?? "All"}');
        debugPrint('     - Status: ${filterProvider.selectedStatus ?? "All"}');
        debugPrint('     - Mode: ${filterProvider.selectedMode ?? "All"}');
        debugPrint('     - Date Range: ${filterProvider.startDate} to ${filterProvider.endDate}');
      }
      
      // Use separate timer for filter changes to avoid conflicts with _applyFilters debounce
      // Increased delay to debounce multiple rapid filter changes
      _filterChangeTimer?.cancel();
      debugPrint('   ‚è±Ô∏è  Starting 800ms debounce timer for API reload...');
      _filterChangeTimer = Timer(const Duration(milliseconds: 800), () {
        // Triple-check that we're still in the right state before loading
        final bool stillAllWalletReport = _selectedItem == NavItem.walletOverview;
        final bool stillSelfWallet = _selectedItem == NavItem.walletSelf;
        
        debugPrint('   ‚è±Ô∏è  Timer fired - checking conditions...');
        debugPrint('     - stillAllWalletReport: $stillAllWalletReport');
        debugPrint('     - stillSelfWallet: $stillSelfWallet');
        debugPrint('     - mounted: $mounted');
        debugPrint('     - _isApplyingFilters: $_isApplyingFilters');
        debugPrint('     - _isLoadingFinancialData: $_isLoadingFinancialData');
        
        if (mounted && 
            (stillAllWalletReport || stillSelfWallet) && 
            !_isApplyingFilters && 
            !_isLoadingFinancialData) {
          if (stillAllWalletReport) {
            debugPrint('üìä [ALL WALLET REPORTS] ‚úÖ Triggering API reload...');
            _loadFinancialData(forceRefresh: true, isSelfWallet: false);
          } else if (stillSelfWallet) {
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('üìä [SELF WALLET] ‚úÖ ALL CONDITIONS MET - TRIGGERING API RELOAD');
            debugPrint('   Calling _loadFinancialData(forceRefresh: true, isSelfWallet: true)');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            _loadFinancialData(forceRefresh: true, isSelfWallet: true);
          }
        } else {
          if (stillAllWalletReport) {
            debugPrint('üìä [ALL WALLET REPORTS] ‚ùå Skipping refresh - conditions not met');
            debugPrint('   Reason: screen changed, unmounted, applying filters, or already loading');
          } else if (stillSelfWallet) {
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('üìä [SELF WALLET] ‚ùå SKIPPING API RELOAD - CONDITIONS NOT MET');
            if (!mounted) debugPrint('   Reason: Widget not mounted');
            if (!stillSelfWallet) debugPrint('   Reason: Screen changed (no longer Self Wallet)');
            if (_isApplyingFilters) debugPrint('   Reason: _isApplyingFilters is true');
            if (_isLoadingFinancialData) debugPrint('   Reason: _isLoadingFinancialData is true');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          }
        }
      });
    } else {
      if (isAllWalletReport) {
        debugPrint('üìä [ALL WALLET REPORTS] Skipping refresh - not on All Wallet Report screen');
      } else if (isSelfWallet) {
        debugPrint('üìä [SELF WALLET] Skipping refresh - not on Self Wallet screen or not mounted');
        debugPrint('   mounted: $mounted');
      }
    }
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  }

  Future<void> _initializeSocket() async {
    try {
      final bool isAuthenticated = await AuthService.isAuthenticated();
      if (!isAuthenticated) {
        // Silently skip if not authenticated - this is expected before login
        return;
      }

      final prefs = await SharedPreferences.getInstance();
      final role = prefs.getString('user_role');
      if (role == 'SuperAdmin') {
        await SocketService.initialize();

        // Wait a bit for socket to connect
        await Future.delayed(const Duration(milliseconds: 500));
        if (!mounted) return;

        // Listen to real-time updates
        SocketService.onAmountUpdate((data) {
          if (mounted && context.mounted) {
            _loadDashboardData();
            if (_selectedItem == NavItem.accountReports) {
              // Refresh Account Reports when changes occur
              _loadFinancialData(isSelfWallet: false);
            } else {
              _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
            }
          }
        });

        SocketService.onDashboardUpdate((data) {
          if (mounted && context.mounted) {
            _loadDashboardData();
            if (_selectedItem == NavItem.accountReports) {
              // Refresh Account Reports when changes occur
              _loadFinancialData(isSelfWallet: false);
            } else {
              _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
            }
          }
        });

        // Listen to All Wallet Reports updates (for All Wallet Report view)
        SocketService.onAllWalletReportsUpdate((data) {
          print('üìä [ALL WALLET REPORTS] Screen: Socket update received');
          if (mounted && context.mounted) {
            // Only refresh if currently viewing All Wallet Report
            if (_selectedItem == NavItem.walletOverview) {
              // Refresh All Wallet Reports when changes occur
              _loadFinancialData(isSelfWallet: false);
            }
          }
        });

        // Listen to dashboard summary updates (financial summary, status counts, flagged items)
        SocketService.onDashboardSummaryUpdate((data) {
          if (mounted && context.mounted) {
            // Check if this is a refresh signal
            if (data['refresh'] == true) {
              // Fetch fresh data from API
              _loadUserFinancialSummary();
              _loadStatusCounts();
              _loadTimelineEntries();
              return;
            }
            
            // Update financial summary (skip if in Self Wallet mode)
            final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
            if (!isSelfWallet) {
            final financialSummary = data['financialSummary'] as Map<String, dynamic>?;
            if (financialSummary != null) {
              setState(() {
                _userCashIn = (financialSummary['cashIn'] as num?)?.toDouble() ?? 0.0;
                _userCashOut = (financialSummary['cashOut'] as num?)?.toDouble() ?? 0.0;
                _userBalance = (financialSummary['balance'] as num?)?.toDouble() ?? 0.0;
              });
              }
            } else {
              debugPrint('[SELF WALLET] ‚è≠Ô∏è  Skipping socket financial summary update - Self Wallet mode');
              debugPrint('[SELF WALLET] ‚è≠Ô∏è  Location: SocketService.onDashboardSummaryUpdate');
            }
            
            // Update status counts
            // Use same format as _loadStatusCounts() to avoid format mismatch and double counting
            final statusCounts = data['statusCounts'] as Map<String, dynamic>?;
            if (statusCounts != null) {
              final expenses = (statusCounts['expenses'] is Map) ? (statusCounts['expenses'] as Map<String, dynamic>) : <String, dynamic>{};
              final transactions = (statusCounts['transactions'] is Map) ? (statusCounts['transactions'] as Map<String, dynamic>) : <String, dynamic>{};
              final collections = (statusCounts['collections'] is Map) ? (statusCounts['collections'] as Map<String, dynamic>) : <String, dynamic>{};
              
              setState(() {
                // Store in same format as _loadStatusCounts() - object with count and amount
                // This ensures consistency and prevents double counting
                _statusCounts = {
                  'expenses': {
                    'approved': expenses['approved'] ?? {'count': 0, 'amount': 0},
                    'unapproved': expenses['unapproved'] ?? {'count': 0, 'amount': 0},
                    'flagged': expenses['flagged'] ?? {'count': 0, 'amount': 0},
                    'total': expenses['total'] ?? {'count': 0, 'amount': 0},
                  },
                  'transactions': {
                    'approved': transactions['approved'] ?? {'count': 0, 'amount': 0},
                    'unapproved': transactions['unapproved'] ?? {'count': 0, 'amount': 0},
                    'flagged': transactions['flagged'] ?? {'count': 0, 'amount': 0},
                    'total': transactions['total'] ?? {'count': 0, 'amount': 0},
                  },
                  'collections': {
                    'accounted': collections['accounted'] ?? {'count': 0, 'amount': 0},
                    'unaccounted': collections['unaccounted'] ?? {'count': 0, 'amount': 0},
                    'flagged': collections['flagged'] ?? {'count': 0, 'amount': 0},
                    'total': collections['total'] ?? {'count': 0, 'amount': 0},
                  },
                };
              });
            }
            
            // Update flagged items
            final flaggedItems = data['flaggedItems'] as List<dynamic>?;
            print('üö© [FLAGGED ITEMS] Socket update received - flaggedItems: ${flaggedItems?.length ?? 0} items');
            if (flaggedItems != null) {
              // Convert flagged items to timeline format
              final convertedFlaggedItems = _convertFlaggedItemsToTimelineFormat(flaggedItems);
              print('üö© [FLAGGED ITEMS] Socket - Converted to ${convertedFlaggedItems.length} timeline items');
              setState(() {
                _timelineItems = convertedFlaggedItems;
              });
              print('üö© [FLAGGED ITEMS] Socket - ‚úÖ Timeline items updated in state');
            } else {
              print('üö© [FLAGGED ITEMS] Socket - ‚ùå No flagged items in socket data');
            }
          }
        });

        // Listen to self wallet updates (for all users)
        SocketService.onSelfWalletUpdate((data) async {
          // Enhanced socket listener logic from wallet_overview_screen
          if (mounted) {
            debugPrint('[DASHBOARD] üí∞ Self wallet update received - refreshing financial summary...');
            
            // ALWAYS refresh financial summary when wallet updates (for dashboard card)
            // This ensures dashboard financial summary stays up-to-date
            if (mounted) {
              _loadUserFinancialSummary();
            }
            
            // If viewing walletSelf screen, also refresh full wallet data
            if (_selectedItem == NavItem.walletSelf) {
              debugPrint('[SELF WALLET] üí∞ Self wallet update received - refreshing data...');
              
              // Refresh self wallet data when changes occur
              _loadFinancialData(isSelfWallet: true);
              
              // Safely extract transaction info for notification (from wallet_overview_screen)
              String notificationMessage = 'Wallet updated';
              try {
                if (data is Map<String, dynamic>) {
                  final transaction = data['transaction'];
                  if (transaction is Map<String, dynamic>) {
                    final amount = transaction['amount'];
                    final updateType = data['type'] ?? '';
                    if (amount != null) {
                      final amountValue = (amount is num) ? amount.toDouble() : (double.tryParse(amount.toString()) ?? 0.0);
                      final action = updateType == 'wallet_add' ? 'added' : (updateType == 'wallet_withdraw' ? 'withdrawn' : 'updated');
                      notificationMessage = 'Wallet updated: ‚Çπ${amountValue.toStringAsFixed(2)} $action';
                    }
                  }
                }
              } catch (e) {
                debugPrint('[SELF WALLET] Error parsing notification data: $e');
              }
              
              // Show subtle notification (from wallet_overview_screen)
              if (mounted && context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(notificationMessage),
                    duration: const Duration(seconds: 2),
                    backgroundColor: AppTheme.secondaryColor,
                    behavior: SnackBarBehavior.floating,
                  ),
                );
              }
            }
          }
        });

        // Listen to specific financial data updates - Unified Auto-Refresh Handler
        final socket = SocketService.socket;
        if (socket != null) {
          // Expense events
          socket.on('expenseUpdate', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('expenseCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('expenseUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Transaction events
          socket.on('transactionUpdate', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('transactionCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('transactionUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Collection events
          socket.on('collectionUpdate', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('collectionCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('collectionUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Custom Field events
          socket.on('customFieldUpdate', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('customFieldCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('customFieldUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('customFieldDeleted', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Expense Type events
          SocketService.onExpenseTypeUpdate((data) {
            if (mounted) {
              final event = data['event']?.toString() ?? '';
              if (event == 'created' || event == 'updated' || event == 'deleted') {
                _autoRefreshCurrentScreen(forceRefresh: true);
              }
            }
          });

          // User events - for Users screen
          socket.on('userCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('userUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('userDeleted', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Role events - for Roles screen
          socket.on('roleCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('roleUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('roleDeleted', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });

          // Payment Mode events - for Payment Modes screen
          socket.on('paymentModeCreated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('paymentModeUpdated', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('paymentModeDeleted', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
          socket.on('paymentModeStatusChanged', (data) {
            if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
          });
        } else {
          // Retry after a delay if socket is not ready
          Future.delayed(const Duration(seconds: 1), () {
            final retrySocket = SocketService.socket;
            if (retrySocket != null && mounted) {
              _setupSocketListeners(retrySocket);
            }
          });
        }
      }
    } catch (e) {
      print('Socket initialization error: $e');
    }
  }

  void _setupSocketListeners(dynamic socket) {
    socket.on('expenseUpdate', (data) {
      if (mounted) {
        // Refresh if viewing wallet (self or all), expense report, or account reports
        final isSelfWallet = _selectedItem == NavItem.walletSelf;
        final isExpenseReport = _selectedItem == NavItem.expenseReport;
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else if (isSelfWallet || isExpenseReport || _selectedItem == NavItem.walletAll || _selectedItem == NavItem.walletOverview) {
          // Force refresh to get real-time data, bypass cache
          _loadFinancialData(forceRefresh: true, isSelfWallet: isSelfWallet);
        }
      }
    });

    socket.on('transactionUpdate', (data) {
      if (mounted) {
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else {
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        }
      }
    });

    socket.on('collectionUpdate', (data) {
      if (mounted) {
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else {
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        }
      }
    });

    socket.on('expenseCreated', (data) {
      if (mounted) {
        // Refresh if viewing wallet (self or all), expense report, or account reports
        final isSelfWallet = _selectedItem == NavItem.walletSelf;
        final isExpenseReport = _selectedItem == NavItem.expenseReport;
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else if (isSelfWallet || isExpenseReport || _selectedItem == NavItem.walletAll || _selectedItem == NavItem.walletOverview) {
          // Force refresh to get real-time data, bypass cache
          _loadFinancialData(forceRefresh: true, isSelfWallet: isSelfWallet);
        }
      }
    });

    socket.on('transactionCreated', (data) {
      if (mounted) {
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else {
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        }
      }
    });

    socket.on('collectionCreated', (data) {
      if (mounted) {
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else {
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        }
      }
    });

    socket.on('expenseUpdated', (data) {
      if (mounted) {
        // Refresh if viewing wallet (self or all), expense report, or account reports
        final isSelfWallet = _selectedItem == NavItem.walletSelf;
        final isExpenseReport = _selectedItem == NavItem.expenseReport;
        if (_selectedItem == NavItem.accountReports) {
          // Refresh Account Reports when changes occur
          _loadFinancialData(isSelfWallet: false);
        } else if (isSelfWallet || isExpenseReport || _selectedItem == NavItem.walletAll || _selectedItem == NavItem.walletOverview) {
          // Force refresh to get real-time data, bypass cache
          _loadFinancialData(forceRefresh: true, isSelfWallet: isSelfWallet);
        }
      }
    });

    socket.on('transactionUpdated', (data) {
      if (mounted) {
        _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
      }
    });

    socket.on('collectionUpdated', (data) {
      if (mounted) {
        _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
      }
    });

    // User events - for Users screen
    socket.on('userCreated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('userUpdated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('userDeleted', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });

    // Role events - for Roles screen
    socket.on('roleCreated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('roleUpdated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('roleDeleted', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });

    // Payment Mode events - for Payment Modes screen
    socket.on('paymentModeCreated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('paymentModeUpdated', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('paymentModeDeleted', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
    socket.on('paymentModeStatusChanged', (data) {
      if (mounted) _autoRefreshCurrentScreen(forceRefresh: true);
    });
  }

  Future<void> _loadDashboardData() async {
    if (!mounted) return;
    setState(() {
      _isLoadingDashboard = true;
    });

    try {
      // Load dashboard data from API
      final dashboardResult = await DashboardService.getDashboard();
      
      if (dashboardResult['success'] == true && mounted) {
        final dashboard = dashboardResult['dashboard'] as Map<String, dynamic>? ?? {};
        
        // Load wallet separately
        final walletResult = await WalletService.getWallet();
        
        if (mounted) {
          setState(() {
            if (walletResult['success'] == true) {
              _wallet = walletResult['wallet'];
            }
            
            // Use dashboard API data
            _pendingCollections = dashboard['pendingCollections'] as int? ?? 0;
            _pendingTransactions = dashboard['pendingTransactions'] as int? ?? 0;
            _pendingExpenses = dashboard['pendingExpenses'] as int? ?? 0;
            
            // Get recent activities from dashboard API
            _recentActivities = dashboard['recentActivity'] as List<dynamic>? ?? [];
            
            // Get recent transactions and expenses
            _recentTransactions = dashboard['recentTransactions'] as List<dynamic>? ?? [];
            _recentExpenses = dashboard['recentExpenses'] as List<dynamic>? ?? [];
            
            _isLoadingDashboard = false;
          });
        }
      } else {
        // Fallback to individual API calls if dashboard API fails
        final walletResult = await WalletService.getWallet();
        final pendingCollections = await CollectionService.getCollections(status: 'Pending');
        final pendingTransactions = await TransactionService.getTransactions(status: 'Pending');
        final pendingExpenses = await ExpenseService.getExpenses(status: 'Pending');

        if (mounted) {
          setState(() {
            if (walletResult['success'] == true) {
              _wallet = walletResult['wallet'];
            }
            _pendingCollections = (pendingCollections['collections'] as List?)?.length ?? 0;
            _pendingTransactions = (pendingTransactions['transactions'] as List?)?.length ?? 0;
            _pendingExpenses = (pendingExpenses['expenses'] as List?)?.length ?? 0;
          });
        }
        
        if (mounted) {
          setState(() {
            _isLoadingDashboard = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoadingDashboard = false;
        });
        
        // Show error message
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to load dashboard data: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
            action: SnackBarAction(
              label: 'Retry',
              onPressed: _loadDashboardData,
            ),
          ),
        );
      }
    }
  }

  Future<void> _refreshSelfWalletView({bool force = false}) async {
    await _loadFinancialData(forceRefresh: force, isSelfWallet: true);
  }

  Future<void> _loadFinancialData({bool forceRefresh = false, bool isSelfWallet = false}) async {
    if (!mounted) return;
    
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    debugPrint('üîÑ [DEBUG] _loadFinancialData called');
    debugPrint('   forceRefresh: $forceRefresh');
    debugPrint('   isSelfWallet: $isSelfWallet');
    debugPrint('   _selectedItem: $_selectedItem');
    debugPrint('   isAccountReports: ${_selectedItem == NavItem.accountReports}');
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // Get logged-in user ID if this is Self Wallet view
    String? currentUserId;
    if (isSelfWallet) {
      currentUserId = await AuthService.getUserId();
      if (currentUserId == null || currentUserId.isEmpty) {
        debugPrint('Error: Could not get logged-in user ID for Self Wallet');
        if (mounted) {
          setState(() {
            _isLoadingFinancialData = false;
          });
        }
        return;
      }
      if (!mounted) return;
    }

    // Check cache first (unless force refresh)
    // For Self Wallet, we should invalidate cache when user changes or refresh
    // Include accountId in cache key if account filter is active
    // Include userId in cache key if user filter is active in All Wallet Report
    final String accountCacheKey = (_selectedItem == NavItem.accountReports && _selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty)
        ? '_account_$_selectedAccountFilterId'
        : '';
    
    // Get user ID for cache key (for All Wallet Report with user filter)
    // Include all selected user IDs in cache key to differentiate between filter combinations
    String? userIdForCache;
    if (!isSelfWallet && _selectedItem == NavItem.walletOverview) {
      final filterProvider = _filterProvider;
      if (filterProvider.selectedUserIds.isNotEmpty) {
        // Use sorted list of user IDs to create consistent cache key for multiple users
        final sortedUserIds = filterProvider.selectedUserIds.toList()..sort();
        userIdForCache = sortedUserIds.join(',');
      }
    }
    final String userCacheKey = userIdForCache != null ? '_user_$userIdForCache' : '';
    
    final String cacheKey = isSelfWallet 
        ? 'self_${currentUserId ?? ""}$accountCacheKey' 
        : 'all$accountCacheKey$userCacheKey';
    
    debugPrint('üîç [CACHE CHECK] forceRefresh: $forceRefresh, cacheKey: $cacheKey');
    if (!forceRefresh && _cachedWalletData != null && _cacheTimestamp != null) {
      final cacheAge = DateTime.now().difference(_cacheTimestamp!);
      final cachedKey = _cachedWalletData?['cacheKey'] as String?;
      debugPrint('üîç [CACHE CHECK] Cache exists: age=${cacheAge.inSeconds}s, cachedKey: $cachedKey, matches: ${cachedKey == cacheKey}');
      // Only use cache if it's for the same view (self wallet vs all accounts)
      if (cacheAge < _cacheDuration && cachedKey == cacheKey) {
        debugPrint('‚úÖ [CACHE] Using cached data (bypassing API call)');
        // Use cached data
        final cachedData = _cachedWalletData!;
        if (mounted) {
          setState(() {
            // Properly convert LinkedMap<dynamic, dynamic> to Map<String, dynamic>
            final cachedAllData = cachedData['allData'] as List? ?? [];
            _allData = cachedAllData.map((item) {
              if (item is Map) {
                return Map<String, dynamic>.from(item);
              }
              return item as Map<String, dynamic>;
            }).toList();
            
            final cachedFilteredData = cachedData['filteredData'] as List? ?? [];
            _filteredData = cachedFilteredData.map((item) {
              if (item is Map) {
                return Map<String, dynamic>.from(item);
              }
              return item as Map<String, dynamic>;
            }).toList();
            
            _wallet = cachedData['wallet'] != null 
                ? Map<String, dynamic>.from(cachedData['wallet'] as Map) 
                : null;
            // CRITICAL FIX: For Self Wallet, ALWAYS use cached summary values directly
            // DO NOT recalculate from data array - this can cause wrong values if data contains
            // items from other users or if calculation logic doesn't match backend exactly
            // The cached values come from backend API response which is always correct
            if (isSelfWallet) {
              // Use cached summary values directly (these come from backend API)
              _cashIn = (cachedData['cashIn'] as num?)?.toDouble() ?? 0.0;
              _cashOut = (cachedData['cashOut'] as num?)?.toDouble() ?? 0.0;
              _balance = (cachedData['balance'] as num?)?.toDouble() ?? 0.0;
              debugPrint('[SELF WALLET] üí∞ Using cached summary values (from API): cashIn=$_cashIn, cashOut=$_cashOut, balance=$_balance');
            } else {
              // For All Wallet Report, use cached values but log for debugging
              _cashIn = (cachedData['cashIn'] as num?)?.toDouble() ?? 0.0;
              _cashOut = (cachedData['cashOut'] as num?)?.toDouble() ?? 0.0;
              _balance = (cachedData['balance'] as num?)?.toDouble() ?? 0.0;
              if (_selectedItem == NavItem.walletOverview) {
                print('üìä [ALL WALLET REPORTS] Using cached values: cashIn=$_cashIn, cashOut=$_cashOut, balance=$_balance');
              }
            }
          });
          // Only call _applyFilters for non-All Wallet Report screens
          // For All Wallet Report, filters are handled by the listener when filters actually change
          if (_selectedItem != NavItem.walletOverview) {
            _applyFilters();
          }
        }
        return;
      } else {
        debugPrint('‚ö†Ô∏è [CACHE] Cache expired or key mismatch, will fetch from API');
      }
    } else {
      if (forceRefresh) {
        debugPrint('üîÑ [CACHE] forceRefresh=true, bypassing cache, will fetch from API');
      } else {
        debugPrint('‚ÑπÔ∏è [CACHE] No cache exists, will fetch from API');
      }
    }

    // Prevent concurrent loads
    if (_isLoadingFinancialData) {
      return;
    }

    _isLoadingFinancialData = true;

    // Dummy data disabled - always use real API data
    const bool useDummyData = false;
    
    if (useDummyData && !isSelfWallet) {
      // For Self Wallet, filter dummy data to show only user's data
      // For now, use same dummy data generator (will be replaced by real API data)
      final dummyData = _generateDummyDataForAllAccounts();
      if (mounted) {
        setState(() {
          _allData = dummyData;
          _filteredData = dummyData;
          _cashIn = 150000.0;
          _cashOut = 75000.0;
          _balance = 75000.0;
        });
        
        _cachedWalletData = {
          'cacheKey': cacheKey,
          'allData': _allData,
          'filteredData': _filteredData,
          'wallet': _wallet,
          'cashIn': _cashIn,
          'cashOut': _cashOut,
          'balance': _balance,
        };
        _cacheTimestamp = DateTime.now();
        _applyFilters();
      }
      _isLoadingFinancialData = false;
      return;
    }
    
    // For Self Wallet, initialize with fresh/empty data
    if (isSelfWallet) {
      if (mounted) {
        setState(() {
          _allData = [];
          _filteredData = [];
          _cashIn = 0.0;
          _cashOut = 0.0;
          _balance = 0.0;
        });
      }
    }

    bool reportLoaded = false;
    try {
      // Get FilterProvider for global filters
      final filterProvider = _filterProvider;
      
      // ============================================================================
      // CRITICAL: Self Wallet Isolation from User Filter
      // ============================================================================
      // Self Wallet MUST ALWAYS show only the logged-in user's data.
      // It MUST NEVER be affected by user filter selections in FilterProvider.
      // User filter changes in All Wallet Report should NEVER affect Self Wallet.
      // ============================================================================
      
      // Determine userIds for wallet report:
      // 1. If Self Wallet mode, ALWAYS use null (endpoint uses logged-in user automatically)
      // 2. If Wallet Report mode (walletOverview) and user(s) are selected from filter, use all selected user IDs
      // 3. Otherwise, use null (show all users)
      List<String>? userIdsForReport;
      if (isSelfWallet) {
        // CRITICAL: Self Wallet MUST always use null (endpoint uses logged-in user automatically)
        // This ensures Self Wallet is never affected by user filter selections in All Wallet Report
        userIdsForReport = null;
        
        // SAFETY CHECK: Verify that we're not accidentally using a filtered user ID
        if (filterProvider.selectedUserIds.isNotEmpty) {
          final filteredUserId = filterProvider.selectedUserIds.first;
          if (filteredUserId != currentUserId) {
            debugPrint('‚ö†Ô∏è  WARNING: User filter is set to "$filteredUserId" but Self Wallet is correctly using logged-in user "$currentUserId" (filter ignored)');
          }
        }
        
        debugPrint('üîí Self Wallet: Using logged-in user ID (ignoring filter): $currentUserId');
        debugPrint('   ‚úÖ Self Wallet is isolated from user filter changes');
      } else if (_selectedItem == NavItem.walletOverview && filterProvider.selectedUserIds.isNotEmpty) {
        // For All Wallet Report ONLY: If user(s) are selected from filter, use all selected user IDs
        // This filter ONLY affects All Wallet Report, not Self Wallet
        // Supports single user, multiple users, or all users (null)
        userIdsForReport = filterProvider.selectedUserIds.toList();
        debugPrint('üìä All Wallet Report: Using ${userIdsForReport.length} selected user(s) from filter');
        debugPrint('   User IDs: ${userIdsForReport.join(", ")}');
      } else {
        userIdsForReport = null; // Show all users
        debugPrint('üìä All Wallet Report: No user filter, showing all users (aggregated)');
      }
      
      // FINAL VALIDATION: Ensure Self Wallet never uses a filtered user ID
      if (isSelfWallet && userIdsForReport != null) {
        debugPrint('‚ùå ERROR: Self Wallet should not have userIds! Forcing to null.');
        userIdsForReport = null;
      }
      
      // Use separate endpoints for Self Wallet and All Wallet Report
      // This ensures complete isolation - filters can't leak between modes
      Map<String, dynamic> reportResult = {
        'success': false,
        'data': <Map<String, dynamic>>[],
        'wallet': null,
        'walletSummary': null,
        'summary': <String, dynamic>{
          'cashIn': 0.0,
          'cashOut': 0.0,
          'balance': 0.0,
        },
        'breakdown': <String, dynamic>{},
        'count': 0,
        'message': 'Initializing...',
      };
      if (isSelfWallet) {
        // Self Wallet: Call Self Wallet API
        // Apply wallet_overview_screen loading logic
        debugPrint('[SELF WALLET] üíº Dashboard: Calling getSelfWalletReport API');
        debugPrint('[SELF WALLET] üì° Using filters: startDate=${filterProvider.startDate?.toIso8601String()}, endDate=${filterProvider.endDate?.toIso8601String()}, mode=${filterProvider.selectedMode}, status=${filterProvider.selectedStatus}, type=${filterProvider.selectedType}');
        
        // STEP 1: Validate authentication token BEFORE making API call (from wallet_overview_screen)
        final token = await ApiService.getToken();
        if (token == null || token.isEmpty) {
          debugPrint('[SELF WALLET] ‚ùå ERROR: No authentication token found!');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Authentication required. Please login again.'),
                backgroundColor: AppTheme.errorColor,
                duration: const Duration(seconds: 5),
              ),
            );
          }
        reportResult = {
            'success': false,
          'data': <Map<String, dynamic>>[],
          'wallet': <String, dynamic>{
            'cashBalance': 0.0,
            'upiBalance': 0.0,
            'bankBalance': 0.0,
            'totalBalance': 0.0,
          },
          'walletSummary': null,
          'summary': <String, dynamic>{
            'cashIn': 0.0,
            'cashOut': 0.0,
            'balance': 0.0,
          },
            'breakdown': <String, dynamic>{},
            'count': 0,
            'message': 'Authentication required',
          };
        } else {
          debugPrint('[SELF WALLET] ‚úÖ Token validated (length: ${token.length})');
          
          try {
            // STEP 2: Make API call (from wallet_overview_screen)
            reportResult = await WalletService.getSelfWalletReport(
              startDate: filterProvider.startDate,
              endDate: filterProvider.endDate,
              mode: filterProvider.selectedMode != 'All' ? filterProvider.selectedMode : null,
              status: filterProvider.selectedStatus,
              type: filterProvider.selectedType,
            );
            
            if (!mounted) {
              debugPrint('[SELF WALLET] ‚ö†Ô∏è Widget unmounted, aborting...');
              return;
            }
            
            // STEP 3: Validate response structure (from wallet_overview_screen)
            debugPrint('[SELF WALLET] ‚úÖ Dashboard: Self Wallet API call successful, dataCount=${reportResult['data'] is List ? (reportResult['data'] as List).length : 0}');
            debugPrint('[SELF WALLET] üì• Response received: success=${reportResult['success']}, hasData=${reportResult['data'] != null}, hasSummary=${reportResult['summary'] != null}, dataCount=${reportResult['data'] is List ? (reportResult['data'] as List).length : 0}');
            
            // Check for authentication errors (from wallet_overview_screen)
            if (reportResult['error'] == 'NO_TOKEN' || reportResult['statusCode'] == 401) {
              debugPrint('[SELF WALLET] ‚ùå AUTH ERROR: Token invalid or expired');
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Authentication failed. Please login again.'),
                    backgroundColor: AppTheme.errorColor,
                    duration: const Duration(seconds: 5),
                  ),
                );
              }
              reportResult = {
                'success': false,
                'data': <Map<String, dynamic>>[],
                'wallet': <String, dynamic>{
                  'cashBalance': 0.0,
                  'upiBalance': 0.0,
                  'bankBalance': 0.0,
                  'totalBalance': 0.0,
                },
                'walletSummary': null,
                'summary': <String, dynamic>{
                  'cashIn': 0.0,
                  'cashOut': 0.0,
                  'balance': 0.0,
                },
                'breakdown': <String, dynamic>{},
                'count': 0,
                'message': 'Authentication failed',
              };
            }
            
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('[SELF WALLET] üì• API RESPONSE RECEIVED');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('[SELF WALLET] üì• Response summary: ${reportResult['summary']}');
            debugPrint('[SELF WALLET] üì• Response wallet: ${reportResult['wallet']}');
            debugPrint('[SELF WALLET] üì• Response filterMode: ${reportResult['filterMode']}');
            debugPrint('[SELF WALLET] üì• Response walletSummary: ${reportResult['walletSummary']}');
            if (reportResult['summary'] is Map) {
              final sum = reportResult['summary'] as Map;
              debugPrint('[SELF WALLET] üí∞ Raw API Values:');
              debugPrint('[SELF WALLET]    cashIn: ${sum['cashIn']} (type: ${sum['cashIn']?.runtimeType})');
              debugPrint('[SELF WALLET]    cashOut: ${sum['cashOut']} (type: ${sum['cashOut']?.runtimeType})');
              debugPrint('[SELF WALLET]    balance: ${sum['balance']} (type: ${sum['balance']?.runtimeType})');
            }
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          } catch (e) {
            // Enhanced error handling (from wallet_overview_screen)
            debugPrint('[SELF WALLET] ‚ùå Dashboard: Self Wallet API call failed: $e');
            debugPrint('[SELF WALLET] ‚ùå Exception: ${e.toString()} (${e.runtimeType})');
            
            String errorMessage = 'Failed to load wallet data';
            if (e.toString().contains('Failed to connect') || e.toString().contains('SocketException')) {
              errorMessage = 'Cannot connect to server. Please check your internet connection.';
            } else if (e.toString().contains('401') || e.toString().contains('Authentication')) {
              errorMessage = 'Authentication failed. Please login again.';
            } else {
              errorMessage = 'Error: ${e.toString().replaceFirst('Exception: ', '')}';
            }
            
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(errorMessage),
                  backgroundColor: AppTheme.errorColor,
                  duration: const Duration(seconds: 5),
                ),
              );
            }
            
            // Fallback to empty data on error
            reportResult = {
              'success': false,
              'data': <Map<String, dynamic>>[],
              'wallet': <String, dynamic>{
                'cashBalance': 0.0,
                'upiBalance': 0.0,
                'bankBalance': 0.0,
                'totalBalance': 0.0,
              },
              'walletSummary': null,
              'summary': <String, dynamic>{
                'cashIn': 0.0,
                'cashOut': 0.0,
                'balance': 0.0,
            },
              'breakdown': <String, dynamic>{},
          'count': 0,
              'message': errorMessage,
        };
          }
        }
      } else if (_isExpenseReportMode) {
        // Expense Report Mode: Skip wallet report API call
        // Expense report uses its own API endpoint (getExpenseReportScreenData)
        debugPrint('üìä [EXPENSE REPORT] Skipping getAllWalletReport API call - using expense report API instead');
        reportResult = {
          'success': true,
          'data': <Map<String, dynamic>>[],
          'summary': <String, dynamic>{
            'cashIn': 0.0,
            'cashOut': 0.0,
            'balance': 0.0,
          },
        };
        reportLoaded = true;
      } else {
        // All Wallet Report or Account Reports: Use AllWalletReportsService (same as standalone screen)
        Map<String, dynamic> allWalletReportResult;
        
        // Check if date filters are set
        final bool hasDateFilters = filterProvider.startDate != null || filterProvider.endDate != null;
        
        // For WalletService.getWalletReport (which only supports single user), extract single userId if available
        // For AllWalletReportsService.getAllWalletReportsWithFilters, we pass all userIds (supports multiple)
        final String? singleUserId = userIdsForReport != null && userIdsForReport.length == 1 
            ? userIdsForReport.first 
            : null;
        
        // For Account Reports: Check if account filter is set
        final bool isAccountReports = _selectedItem == NavItem.accountReports;
        // Normalize: treat null or empty string as "no filter" (All Accounts)
        final bool hasAccountFilter = isAccountReports && 
            _selectedAccountFilterId != null && 
            _selectedAccountFilterId!.trim().isNotEmpty;
        
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üìä [ACCOUNT REPORTS] Loading data...');
        debugPrint('   isAccountReports: $isAccountReports');
        debugPrint('   _selectedItem: $_selectedItem');
        debugPrint('   _selectedAccountFilterId: "$_selectedAccountFilterId"');
        debugPrint('   _selectedAccountFilterId == null: ${_selectedAccountFilterId == null}');
        debugPrint('   _selectedAccountFilterId?.isEmpty: ${_selectedAccountFilterId?.isEmpty}');
        debugPrint('   hasAccountFilter: $hasAccountFilter');
        debugPrint('   Will use "All Accounts" path: ${isAccountReports && !hasAccountFilter}');
        debugPrint('   hasDateFilters: $hasDateFilters');
        debugPrint('   userIdsForReport: ${userIdsForReport?.join(", ") ?? 'null'} (${userIdsForReport?.length ?? 0} user(s))');
        debugPrint('   startDate: ${filterProvider.startDate?.toIso8601String() ?? 'null'}');
        debugPrint('   endDate: ${filterProvider.endDate?.toIso8601String() ?? 'null'}');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // IMPORTANT: For Account Reports, use /api/wallet/report endpoint which properly
        // supports accountId filtering (or no accountId for "All Accounts").
        // /api/all-wallet-reports does NOT support accountId filtering.
        if (isAccountReports && !hasAccountFilter) {
          // For Account Reports "All Accounts": Use /api/wallet/report without accountId
          // This returns all collections and wallet transactions from all payment mode accounts
          debugPrint('üìä [ACCOUNT REPORTS] "All Accounts" selected - using /api/wallet/report (all payment modes)...');
          debugPrint('   userIdsForReport: ${userIdsForReport?.join(", ") ?? 'null'} (${userIdsForReport?.length ?? 0} user(s))');
          debugPrint('   startDate: ${filterProvider.startDate?.toIso8601String() ?? 'null'}');
          debugPrint('   endDate: ${filterProvider.endDate?.toIso8601String() ?? 'null'}');
          
          // For WalletService.getWalletReport, pass first userId if single user, or null for all/multiple
          final String? walletServiceUserId = userIdsForReport != null && userIdsForReport.length == 1 
              ? userIdsForReport.first 
              : null;
          
          final walletReportResult = await WalletService.getWalletReport(
            userId: walletServiceUserId,
            startDate: filterProvider.startDate,
            endDate: filterProvider.endDate,
            accountId: null, // No accountId = all accounts
            type: null, // Show all types (Collections, WalletTransactions)
            status: null,
            mode: null,
          );
          
          if (walletReportResult['success'] == true) {
            final summary = walletReportResult['summary'] ?? <String, dynamic>{};
            final data = walletReportResult['data'] ?? <Map<String, dynamic>>[];
            
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('‚úÖ [ACCOUNT REPORTS] "All Accounts" API Response received:');
            debugPrint('   success: true');
            debugPrint('   cashIn: ${summary['cashIn']}');
            debugPrint('   cashOut: ${summary['cashOut']}');
            debugPrint('   balance: ${summary['balance']}');
            debugPrint('   data items count: ${data.length}');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            allWalletReportResult = {
              'success': true,
              'report': {
                'cashIn': (summary['cashIn'] ?? 0.0).toDouble(),
                'cashOut': (summary['cashOut'] ?? 0.0).toDouble(),
                'balance': (summary['balance'] ?? 0.0).toDouble(),
              },
              'data': data,
              'userCount': 1,
            };
            
            // Assign to reportResult for consistency
            reportResult = {
              'success': true,
              'data': data.map((item) {
                if (item is Map<String, dynamic>) {
                  return Map<String, dynamic>.from(item);
                } else if (item is Map) {
                  return Map<String, dynamic>.from(item as Map);
                } else {
                  return <String, dynamic>{};
                }
              }).toList(),
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': (summary['cashIn'] ?? 0.0).toDouble(),
                'cashOut': (summary['cashOut'] ?? 0.0).toDouble(),
                'balance': (summary['balance'] ?? 0.0).toDouble(),
              },
              'filterMode': 'all',
              'breakdown': <String, dynamic>{},
              'count': data.length,
            };
            
            if (data.isNotEmpty) {
              debugPrint('‚úÖ [ACCOUNT REPORTS] Using backend filtered data for All Accounts (${data.length} items)');
              debugPrint('   Summary: CashIn=${summary['cashIn']}, CashOut=${summary['cashOut']}, Balance=${summary['balance']}');
              reportLoaded = true;
            } else {
              debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Wallet report API returned summary only - detailed data will be loaded separately');
              debugPrint('   Summary available: CashIn=${summary['cashIn']}, CashOut=${summary['cashOut']}, Balance=${summary['balance']}');
              reportLoaded = false;
            }
          } else {
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('‚ùå [ACCOUNT REPORTS] "All Accounts" API call failed:');
            debugPrint('   success: false');
            debugPrint('   message: ${walletReportResult['message'] ?? 'Unknown error'}');
            debugPrint('   full response: $walletReportResult');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          
            allWalletReportResult = {
              'success': false,
              'message': walletReportResult['message'] ?? 'Failed to fetch all accounts report',
            };
            
            reportResult = {
              'success': false,
              'data': <Map<String, dynamic>>[],
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': 0.0,
                'cashOut': 0.0,
                'balance': 0.0,
              },
              'filterMode': 'all',
              'breakdown': <String, dynamic>{},
              'count': 0,
              'message': walletReportResult['message'] ?? 'Failed to fetch all accounts report',
            };
            reportLoaded = false;
          }
        } else if (hasAccountFilter) {
          // Use getWalletReport which properly supports accountId filtering
          debugPrint('üìä [ACCOUNT REPORTS] Account filter detected - using /api/wallet/report endpoint...');
          debugPrint('   accountId: $_selectedAccountFilterId');
          debugPrint('   startDate: ${filterProvider.startDate?.toIso8601String() ?? 'null'}');
          debugPrint('   endDate: ${filterProvider.endDate?.toIso8601String() ?? 'null'}');
          
          // Use WalletService.getWalletReport which supports accountId
          final walletReportResult = await WalletService.getWalletReport(
            userId: singleUserId,
            startDate: filterProvider.startDate,
            endDate: filterProvider.endDate,
            accountId: _selectedAccountFilterId,
            type: null, // Show all types (Collections, WalletTransactions)
            status: null,
            mode: null,
          );
          
          if (walletReportResult['success'] == true) {
            // Transform wallet report response to match expected format
            final summary = walletReportResult['summary'] ?? <String, dynamic>{};
            final data = walletReportResult['data'] ?? <Map<String, dynamic>>[];
            
            allWalletReportResult = {
              'success': true,
              'report': {
                'cashIn': (summary['cashIn'] ?? 0.0).toDouble(),
                'cashOut': (summary['cashOut'] ?? 0.0).toDouble(),
                'balance': (summary['balance'] ?? 0.0).toDouble(),
              },
              'data': data,
              'userCount': 1,
            };
            
            // Assign to reportResult for consistency with other paths
            reportResult = {
              'success': true,
              'data': data.map((item) {
                if (item is Map<String, dynamic>) {
                  return Map<String, dynamic>.from(item);
                } else if (item is Map) {
                  return Map<String, dynamic>.from(item as Map);
                } else {
                  return <String, dynamic>{};
                }
              }).toList(),
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': (summary['cashIn'] ?? 0.0).toDouble(),
                'cashOut': (summary['cashOut'] ?? 0.0).toDouble(),
                'balance': (summary['balance'] ?? 0.0).toDouble(),
              },
              'filterMode': userIdsForReport != null ? (userIdsForReport.length == 1 ? 'user' : 'users') : 'all',
              'breakdown': <String, dynamic>{},
              'count': 1,
              'account': walletReportResult['account'],
            };
            
            // For Account Reports: If backend provided data, use it
            if (isAccountReports) {
              if (data.isNotEmpty) {
                debugPrint('üìä [ACCOUNT REPORTS] Using backend filtered data (${data.length} items)');
                reportLoaded = true;
              } else {
                debugPrint('üìä [ACCOUNT REPORTS] Wallet report API returned summary only - detailed data will be loaded separately');
                reportLoaded = false;
              }
            }
          } else {
            allWalletReportResult = {
              'success': false,
              'message': walletReportResult['message'] ?? 'Failed to fetch account report',
            };
            
            // Assign to reportResult for error case
            reportResult = {
              'success': false,
              'data': <Map<String, dynamic>>[],
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': 0.0,
                'cashOut': 0.0,
                'balance': 0.0,
              },
              'filterMode': userIdsForReport != null ? (userIdsForReport.length == 1 ? 'user' : 'users') : 'all',
              'breakdown': <String, dynamic>{},
              'count': 0,
              'message': walletReportResult['message'] ?? 'Failed to fetch account report',
            };
          }
        } else if (hasDateFilters || userIdsForReport != null) {
          // Use getAllWalletReportsWithFilters for date/user filters (for non-Account Reports)
          debugPrint('üìä [ACCOUNT REPORTS] Requesting reports with filters (no account filter)...');
          debugPrint('   userIds: ${userIdsForReport?.join(", ") ?? 'null'} (${userIdsForReport?.length ?? 0} user(s))');
          debugPrint('   startDate: ${filterProvider.startDate?.toIso8601String() ?? 'null'}');
          debugPrint('   endDate: ${filterProvider.endDate?.toIso8601String() ?? 'null'}');
          
          allWalletReportResult = await AllWalletReportsService.getAllWalletReportsWithFilters(
            userIds: userIdsForReport, // Pass all selected user IDs (supports single, multiple, or null for all)
            startDate: filterProvider.startDate,
            endDate: filterProvider.endDate,
            accountId: null, // No accountId for this path
          );
          
          if (allWalletReportResult['success'] == true) {
            final report = allWalletReportResult['report'] as Map<String, dynamic>?;
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('‚úÖ [ACCOUNT REPORTS] API Response received:');
            debugPrint('   success: true');
            if (report != null) {
            debugPrint('   cashIn: ${report['cashIn']}');
            debugPrint('   cashOut: ${report['cashOut']}');
            debugPrint('   balance: ${report['balance']}');
            }
            debugPrint('   userCount: ${allWalletReportResult['userCount'] ?? 0}');
            debugPrint('   _selectedAccountFilterId: $_selectedAccountFilterId');
            debugPrint('   Current _cashIn before update: $_cashIn');
            debugPrint('   Current _cashOut before update: $_cashOut');
            debugPrint('   Current _balance before update: $_balance');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Check if backend returned data array (when accountId filter is applied via /api/wallet/report)
            final backendData = allWalletReportResult['data'] as List?;
            final hasBackendData = backendData != null && backendData.isNotEmpty;
            debugPrint('   hasBackendData: $hasBackendData, dataLength: ${hasBackendData ? backendData.length : 0}');
            
            // Transform to match expected format
            // For Account Reports: Use backend data if available, otherwise load detailed data separately
            reportResult = {
              'success': true,
              'data': hasBackendData ? backendData.map((item) {
                if (item is Map<String, dynamic>) {
                  return Map<String, dynamic>.from(item);
                } else if (item is Map) {
                  return Map<String, dynamic>.from(item as Map);
                } else {
                  return <String, dynamic>{};
                }
              }).toList() : <Map<String, dynamic>>[], // Use backend data if available
              'wallet': null,
              'walletSummary': userIdsForReport == null && report != null ? {
                'totalBalance': report['balance'] ?? 0.0,
              } : null,
              'summary': report != null ? {
                'cashIn': report['cashIn'] ?? 0.0,
                'cashOut': report['cashOut'] ?? 0.0,
                'balance': report['balance'] ?? 0.0,
              } : <String, dynamic>{},
              'filterMode': userIdsForReport != null ? (userIdsForReport.length == 1 ? 'user' : 'users') : 'all',
              'breakdown': <String, dynamic>{},
              'count': allWalletReportResult['userCount'] ?? 0,
            };
            
            // For Account Reports: If backend provided data, use it; otherwise load detailed data separately
            if (isAccountReports) {
              if (hasBackendData) {
                debugPrint('üìä [ACCOUNT REPORTS] Using backend filtered data (${(backendData as List).length} items)');
                reportLoaded = true; // Backend provided data, no need to load separately
              } else {
              debugPrint('üìä [ACCOUNT REPORTS] Wallet report API returned summary only - detailed data will be loaded separately');
              reportLoaded = false; // Force detailed data loading
              }
            }
          } else {
            print('‚ùå [ALL WALLET REPORTS] Frontend: Failed to get filtered report: ${allWalletReportResult['message']}');
            reportResult = {
              'success': false,
              'data': <Map<String, dynamic>>[],
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': 0.0,
                'cashOut': 0.0,
                'balance': 0.0,
              },
              'filterMode': userIdsForReport != null ? (userIdsForReport.length == 1 ? 'user' : 'users') : 'all',
              'breakdown': <String, dynamic>{},
              'count': 0,
              'message': allWalletReportResult['message'] ?? 'Failed to load wallet reports',
            };
          }
        } else {
          // No filters - Get aggregated totals for all users (faster, no date filtering)
          print('üìä [ALL WALLET REPORTS] Frontend: Requesting totals (no filters)...');
          allWalletReportResult = await AllWalletReportsService.getAllWalletReportsTotals();
          
          if (allWalletReportResult['success'] == true && allWalletReportResult['totals'] != null) {
            final totals = allWalletReportResult['totals'] as Map<String, dynamic>;
            print('üìä [ALL WALLET REPORTS] Frontend: Received response: success=true, totals={totalCashIn: ${totals['totalCashIn']}, totalCashOut: ${totals['totalCashOut']}, totalBalance: ${totals['totalBalance']}, userCount: ${totals['userCount']}, lastUpdated: ${totals['lastUpdated']}}');
            
            // Transform to match expected format
            // For Account Reports: Don't set reportLoaded=true yet, we need to load detailed data
            reportResult = {
              'success': true,
              'data': <Map<String, dynamic>>[], // Empty - detailed data will be loaded separately
              'wallet': null,
              'walletSummary': {
                'totalBalance': totals['totalBalance'] ?? 0.0,
              },
              'summary': {
                'cashIn': totals['totalCashIn'] ?? 0.0,
                'cashOut': totals['totalCashOut'] ?? 0.0,
                'balance': totals['totalBalance'] ?? 0.0,
              },
              'filterMode': 'all',
              'breakdown': <String, dynamic>{},
              'count': totals['userCount'] ?? 0,
            };
            
            // For Account Reports: Don't mark reportLoaded=true, so detailed data loading happens
            if (isAccountReports) {
              debugPrint('üìä [ACCOUNT REPORTS] Totals API returned summary only - detailed data will be loaded separately');
              reportLoaded = false; // Force detailed data loading
            }
          } else {
            print('‚ùå [ALL WALLET REPORTS] Frontend: Failed to get totals: ${allWalletReportResult['message']}');
            reportResult = {
              'success': false,
              'data': <Map<String, dynamic>>[],
              'wallet': null,
              'walletSummary': null,
              'summary': {
                'cashIn': 0.0,
                'cashOut': 0.0,
                'balance': 0.0,
              },
              'filterMode': 'all',
              'breakdown': <String, dynamic>{},
              'count': 0,
              'message': allWalletReportResult['message'] ?? 'Failed to load wallet reports',
            };
          }
        }
      }
      
      // Validate success response - handle both bool and other types (from wallet_overview_screen)
      final bool isSuccess = reportResult['success'] == true || 
                             reportResult['success'] == 1 ||
                             (reportResult['success'] is String && reportResult['success'].toLowerCase() == 'true');
      
      if (isSuccess) {
        reportLoaded = true;
        // Safely convert JavaScript objects to Dart Maps
        final List<Map<String, dynamic>> reportData = (() {
          final data = reportResult['data'];
          if (data == null) return <Map<String, dynamic>>[];
          if (data is List) {
            return data.map((item) {
              if (item is Map<String, dynamic>) {
                return Map<String, dynamic>.from(item);
              } else if (item is Map) {
                return Map<String, dynamic>.from(item as Map);
              } else {
                return <String, dynamic>{};
              }
            }).toList();
          }
          return <Map<String, dynamic>>[];
        })();

        // Safely convert JavaScript objects to Dart Maps
        final summaryRaw = reportResult['summary'];
        final walletRaw = reportResult['wallet'];
        final walletSummaryRaw = reportResult['walletSummary']; // Aggregated totals for all users
        final filterMode = reportResult['filterMode']?.toString(); // 'all' or 'user'
        final accountInfo = reportResult['account']; // Account info if filtered by account
        final breakdownRaw = reportResult['breakdown']; // Breakdown for Self Wallet (from wallet_overview_screen)

        // Debug logging
        // Get single user ID for report if only one user is selected
        final String? userIdForReport = userIdsForReport != null && userIdsForReport.length == 1 
            ? userIdsForReport.first 
            : null;
        
        print('üìä [ALL WALLET REPORTS] Wallet Report Response (isSelfWallet=$isSelfWallet):');
        print('   filterMode: $filterMode');
        print('   hasSummary: ${summaryRaw != null}');
        if (summaryRaw != null) {
          print('   summaryRaw: $summaryRaw');
        }
        print('   hasWallet: ${walletRaw != null}');
        print('   hasWalletSummary: ${walletSummaryRaw != null}');
        if (walletSummaryRaw != null) {
          print('   walletSummaryRaw: $walletSummaryRaw');
        }
        print('   userIdForReport: $userIdForReport');

        // Initialize to 0.0 (not null) like wallet_overview_screen - ensures values are always set
        double summaryCashIn = 0.0;
        double summaryCashOut = 0.0;
        double summaryBalance = 0.0;

        // Determine if showing all users or specific user
        // For Self Wallet, always treat as specific user (single user view)
        // filterMode: 'user' when filtering by specific user, 'all' when showing all users
        // Also check walletRaw presence: if walletRaw exists, it's a specific user; if walletSummaryRaw exists, it's all users
        final bool isShowingAllUsers = !isSelfWallet && (filterMode == 'all' || (filterMode == null && walletSummaryRaw != null && walletRaw == null));
        final bool isShowingSpecificUser = isSelfWallet || filterMode == 'user' || (filterMode == null && walletRaw != null && walletSummaryRaw == null);
        
        print('üìä [ALL WALLET REPORTS] Parsing decision: isSelfWallet=$isSelfWallet, filterMode=$filterMode, isShowingAllUsers=$isShowingAllUsers, isShowingSpecificUser=$isShowingSpecificUser');
        
        if (isShowingAllUsers && walletSummaryRaw != null && !isSelfWallet) {
          // When showing all users, use walletSummary for aggregated totals
          print('üìä [ALL WALLET REPORTS] Parsing all users data - isShowingAllUsers=true');
          final walletSummaryMap = walletSummaryRaw is Map<String, dynamic>
              ? Map<String, dynamic>.from(walletSummaryRaw)
              : (walletSummaryRaw is Map
                  ? Map<String, dynamic>.from(walletSummaryRaw as Map)
                  : <String, dynamic>{});
          print('üìä [ALL WALLET REPORTS] walletSummaryMap: $walletSummaryMap');
          if (walletSummaryMap.isNotEmpty) {
            // Use summary for cash flow, but balance from walletSummary totalBalance
            if (summaryRaw != null) {
              final summaryMap = summaryRaw is Map<String, dynamic>
                  ? Map<String, dynamic>.from(summaryRaw)
                  : (summaryRaw is Map
                      ? Map<String, dynamic>.from(summaryRaw as Map)
                      : <String, dynamic>{});
              print('üìä [ALL WALLET REPORTS] summaryMap: $summaryMap');
              if (summaryMap.isNotEmpty) {
                summaryCashIn = _parseAmount(summaryMap['cashIn']);
                summaryCashOut = _parseAmount(summaryMap['cashOut']);
                print('üìä [ALL WALLET REPORTS] Parsed from summary: cashIn=$summaryCashIn, cashOut=$summaryCashOut');
              } else {
                print('‚ö†Ô∏è [ALL WALLET REPORTS] summaryMap is empty!');
              }
            } else {
              print('‚ö†Ô∏è [ALL WALLET REPORTS] summaryRaw is null!');
            }
            // Use totalBalance from walletSummary for aggregated balance
            summaryBalance = _parseAmount(walletSummaryMap['totalBalance']);
            print('üìä [ALL WALLET REPORTS] Parsed balance from walletSummary: $summaryBalance');
          } else {
            print('‚ö†Ô∏è [ALL WALLET REPORTS] walletSummaryMap is empty!');
          }
        } else if (isShowingSpecificUser && summaryRaw != null) {
          print('üìä [ALL WALLET REPORTS] Parsing specific user data - isShowingSpecificUser=true');
          // When showing specific user (or Self Wallet), use summary from backend
          final summaryMap = summaryRaw is Map<String, dynamic>
              ? Map<String, dynamic>.from(summaryRaw)
              : (summaryRaw is Map
                  ? Map<String, dynamic>.from(summaryRaw as Map)
                  : <String, dynamic>{});
          if (summaryMap.isNotEmpty) {
            if (isSelfWallet) {
              debugPrint('[SELF WALLET] üîç Parsing summary for Self Wallet:');
            } else {
            debugPrint('üîç Parsing summary for specific user:');
            }
            debugPrint('   summaryMap: $summaryMap');
            debugPrint('   cashIn raw: ${summaryMap['cashIn']} (type: ${summaryMap['cashIn']?.runtimeType})');
            debugPrint('   cashOut raw: ${summaryMap['cashOut']} (type: ${summaryMap['cashOut']?.runtimeType})');
            debugPrint('   balance raw: ${summaryMap['balance']} (type: ${summaryMap['balance']?.runtimeType})');
            
            // Robust parsing similar to wallet_overview_screen
            final cashInRaw = summaryMap['cashIn'];
            final cashOutRaw = summaryMap['cashOut'];
            final balanceRaw = summaryMap['balance'];
            
            // Parse Cash In with enhanced error handling (matching wallet_overview_screen pattern)
            try {
              if (cashInRaw != null) {
                summaryCashIn = (cashInRaw is num) ? cashInRaw.toDouble() : double.tryParse(cashInRaw.toString()) ?? 0.0;
                if (isSelfWallet) {
                  debugPrint('[SELF WALLET] üí∞ Cash In parsed: $summaryCashIn from raw: $cashInRaw');
                }
              } else {
                summaryCashIn = 0.0; // Ensure default value even if null
                if (isSelfWallet) {
                  debugPrint('[SELF WALLET] ‚ö†Ô∏è  Cash In raw value is NULL! Defaulting to 0.0');
                }
              }
            } catch (e) {
              debugPrint('[SELF WALLET] ‚ùå Error parsing Cash In: $e');
              summaryCashIn = 0.0;
            }
            
            // Parse Cash Out
            try {
              if (cashOutRaw != null) {
                summaryCashOut = (cashOutRaw is num) ? cashOutRaw.toDouble() : double.tryParse(cashOutRaw.toString()) ?? 0.0;
              } else {
                summaryCashOut = 0.0; // Ensure default value
              }
            } catch (e) {
              debugPrint('[SELF WALLET] ‚ùå Error parsing Cash Out: $e');
              summaryCashOut = 0.0;
            }
            
            // Parse Balance
            try {
              if (balanceRaw != null) {
                summaryBalance = (balanceRaw is num) ? balanceRaw.toDouble() : double.tryParse(balanceRaw.toString()) ?? 0.0;
              } else {
                summaryBalance = 0.0; // Ensure default value
              }
            } catch (e) {
              debugPrint('[SELF WALLET] ‚ùå Error parsing Balance: $e');
              summaryBalance = 0.0;
            }
            
            // Check if data is coming (from wallet_overview_screen)
            if (isSelfWallet) {
              if (summaryCashIn == 0.0 && summaryCashOut == 0.0 && summaryBalance == 0.0) {
                debugPrint('[SELF WALLET] ‚ö†Ô∏è  All values ZERO - No data or empty wallet');
              } else {
                debugPrint('[SELF WALLET] üí∞ Data Found: CashIn=$summaryCashIn, CashOut=$summaryCashOut, Balance=$summaryBalance');
              }
            }
            
            // Only show detailed parsing logs for Self Wallet
            if (isSelfWallet) {
              debugPrint('[SELF WALLET] üìä After parsing:');
              debugPrint('[SELF WALLET]    summaryCashIn: $summaryCashIn');
              debugPrint('[SELF WALLET]    summaryCashOut: $summaryCashOut');
              debugPrint('[SELF WALLET]    summaryBalance: $summaryBalance');
              debugPrint('[SELF WALLET] ‚úÖ Summary parsed successfully: CashIn=$summaryCashIn, CashOut=$summaryCashOut, Balance=$summaryBalance');
          }
          } else if (isSelfWallet) {
            debugPrint('[SELF WALLET] ‚ö†Ô∏è  Summary map is empty!');
            // Ensure values are still set to 0.0 (already initialized above)
            debugPrint('[SELF WALLET] üí∞ Using default values: CashIn=$summaryCashIn, CashOut=$summaryCashOut, Balance=$summaryBalance');
          }
        } else if (summaryRaw != null && !isSelfWallet) {
          // Fallback: Try to use summary if available (for backward compatibility)
          print('üìä [ALL WALLET REPORTS] Using fallback parsing - summaryRaw is not null');
          final summaryMap = summaryRaw is Map<String, dynamic>
              ? Map<String, dynamic>.from(summaryRaw)
              : (summaryRaw is Map
                  ? Map<String, dynamic>.from(summaryRaw as Map)
                  : <String, dynamic>{});
          print('üìä [ALL WALLET REPORTS] Fallback summaryMap: $summaryMap');
          if (summaryMap.isNotEmpty) {
            summaryCashIn = _parseAmount(summaryMap['cashIn']);
            summaryCashOut = _parseAmount(summaryMap['cashOut']);
            summaryBalance = _parseAmount(summaryMap['balance']);
            print('üìä [ALL WALLET REPORTS] Fallback parsed: cashIn=$summaryCashIn, cashOut=$summaryCashOut, balance=$summaryBalance');
          } else {
            print('‚ö†Ô∏è [ALL WALLET REPORTS] Fallback summaryMap is empty!');
          }
        } else if (!isSelfWallet) {
          print('‚ö†Ô∏è [ALL WALLET REPORTS] No data found! summaryRaw is null, isShowingAllUsers=$isShowingAllUsers, isShowingSpecificUser=$isShowingSpecificUser');
        }
        
        // Store account info if available (safely convert)
        if (accountInfo != null) {
          final accountMap = accountInfo is Map<String, dynamic>
              ? Map<String, dynamic>.from(accountInfo)
              : (accountInfo is Map
                  ? Map<String, dynamic>.from(accountInfo as Map)
                  : <String, dynamic>{});
          // Account info is available from backend
          // We can use this to display account name in UI
        }

        // Update breakdown and store snapshot for filter restoration (from wallet_overview_screen)
        if (isSelfWallet && breakdownRaw is Map) {
          try {
            final breakdownMap = Map<String, Map<String, Map<String, dynamic>>>.from(
              (breakdownRaw as Map).map(
                (key, value) => MapEntry(
                  key.toString(),
                  value is Map
                      ? Map<String, Map<String, dynamic>>.from(
                          (value as Map).map(
                            (k, v) => MapEntry(
                              k.toString(),
                              v is Map
                                  ? Map<String, dynamic>.from(v as Map)
                                  : <String, dynamic>{},
                            ),
                          ),
                        )
                      : <String, Map<String, dynamic>>{},
                ),
              ),
            );
            // Store breakdown for Self Wallet (will be used in setState below)
            if (mounted) {
              setState(() {
                _filterBreakdown = breakdownMap;
              });
            }
            debugPrint('[SELF WALLET] ‚úÖ Breakdown stored: ${breakdownMap.keys.toList()}');
          } catch (e) {
            debugPrint('[SELF WALLET] ‚ùå Error parsing breakdown: $e');
          }
        }

        // Transform expense data in reportData if needed
        // If in expense report mode, filter to expenses only
        var transformedReportData = reportData.map((item) {
          // Ensure item is a proper Dart Map, not a JavaScript object
          final Map<String, dynamic> itemMap = item is Map<String, dynamic>
              ? Map<String, dynamic>.from(item)
              : (item is Map
                  ? Map<String, dynamic>.from(item as Map)
                  : <String, dynamic>{});
          
          // For Self Wallet: Transform dataType to type (singular to plural) for filtering
          if (isSelfWallet) {
            final dataType = itemMap['dataType']?.toString() ?? '';
            
            // Check if this is a wallet transaction - use operation field to determine type
            if (dataType == 'WalletTransaction') {
              final operation = itemMap['operation']?.toString().toLowerCase() ?? '';
              
              // Determine type from operation field
              // Add operations: operation = 'add'
              // Withdraw operations: operation = 'subtract' and no relatedId (expense/transaction would have relatedId)
              if (operation == 'add') {
                itemMap['type'] = 'Add Amount';
              } else if (operation == 'subtract') {
                // Check if it's a withdraw (no relatedId) vs expense/transaction (has relatedId)
                final hasRelatedId = itemMap['relatedId'] != null;
                if (!hasRelatedId) {
                  // No relatedId means it's a direct withdraw operation
                  itemMap['type'] = 'Withdraw';
                } else {
                  // Has relatedId means it's from expense or transaction, keep as WalletTransactions
                  itemMap['type'] = 'WalletTransactions';
                }
              } else {
                // Other operations, keep as WalletTransactions
                itemMap['type'] = 'WalletTransactions';
              }
            } else if (!itemMap.containsKey('type') || itemMap['type'] == null || itemMap['type'] == '') {
              // Map singular backend values to plural frontend filter values
              switch (dataType) {
                case 'Expense':
                  itemMap['type'] = 'Expenses';
                  break;
                case 'Transaction':
                  itemMap['type'] = 'Transactions';
                  break;
                case 'Collection':
                  itemMap['type'] = 'Collections';
                  break;
                default:
                  itemMap['type'] = dataType.isNotEmpty ? dataType : '';
              }
            }
          }
          
          if (itemMap['type'] == 'Expenses') {
            // Get created by person name
            final createdBy = itemMap['createdBy'];
            final createdByName = createdBy is Map 
                ? ((createdBy as Map)['name']?.toString() ?? 'Unknown')
                : (createdBy?.toString() ?? 'Unknown');
            // Get expense category name
            final categoryName = itemMap['category']?.toString() ?? 'Unknown';
            // Get approvedBy name
            final approvedBy = itemMap['approvedBy'];
            String approvedByName = '';
            if (approvedBy != null) {
              if (approvedBy is Map) {
                approvedByName = (approvedBy['name'] ?? approvedBy['fullName'] ?? approvedBy['displayName'])?.toString() ?? '';
              } else if (approvedBy is String && approvedBy.isNotEmpty) {
                approvedByName = approvedBy;
              }
            }
            return <String, dynamic>{
              ...itemMap,
              'from': createdByName,
              'to': categoryName,
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (itemMap['approvedByName']?.toString() ?? ''),
            };
          }
          if (itemMap['type'] == 'Transactions') {
            // Get sender and receiver names
            final sender = itemMap['sender'];
            final senderName = sender is Map 
                ? ((sender as Map)['name']?.toString() ?? 'Unknown')
                : (sender?.toString() ?? 'Unknown');
            final receiver = itemMap['receiver'];
            final receiverName = receiver is Map 
                ? ((receiver as Map)['name']?.toString() ?? 'Unknown')
                : (receiver?.toString() ?? 'Unknown');
            // Get approvedBy name
            final approvedBy = itemMap['approvedBy'];
            String approvedByName = '';
            if (approvedBy != null) {
              if (approvedBy is Map) {
                approvedByName = (approvedBy['name'] ?? approvedBy['fullName'] ?? approvedBy['displayName'])?.toString() ?? '';
              } else if (approvedBy is String && approvedBy.isNotEmpty) {
                approvedByName = approvedBy;
              }
            }
            // Check if current user is the receiver
            final receiverUserId = receiver is Map 
                ? (receiver['_id'] ?? receiver['id'])?.toString()
                : receiver?.toString();
            // Note: We'll set isReceiver flag when we have currentUserId available
            // For now, we'll check it in the handler function
            
            return <String, dynamic>{
              ...itemMap,
              'from': senderName,
              'to': receiverName,
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (itemMap['approvedByName']?.toString() ?? ''),
              'receiverId': receiverUserId, // Store receiver ID for later comparison
            };
          }
          if (itemMap['type'] == 'Collections') {
            // Check if this is a system collection or systematic entry (created by System)
            final isSystemCollection = itemMap['isSystemCollection'] == true || itemMap['collectedBy'] == null;
            final isSystematicEntry = itemMap['isSystematicEntry'] == true || itemMap['collectionType'] == 'systematic';
            
            // Get collectedBy name properly
            final collectedBy = itemMap['collectedBy'];
            String collectedByName = 'Unknown';
            if (collectedBy != null) {
              if (collectedBy is Map) {
                collectedByName = (collectedBy['name'] ?? collectedBy['fullName'] ?? collectedBy['displayName'])?.toString() ?? 'Unknown';
              } else if (collectedBy is String && collectedBy.isNotEmpty) {
                collectedByName = 'Unknown'; // ObjectId string, can't get name
              }
            }
            
            // Get assignedReceiver name properly
            final assignedReceiver = itemMap['assignedReceiver'];
            String receiverName = 'Not Assigned';
            if (assignedReceiver != null) {
              if (assignedReceiver is Map) {
                receiverName = (assignedReceiver['name'] ?? assignedReceiver['fullName'] ?? assignedReceiver['displayName'])?.toString() ?? 'Unknown';
              } else if (assignedReceiver is String && assignedReceiver.isNotEmpty) {
                receiverName = 'Not Assigned'; // ObjectId string, can't get name
              }
            }
            
            // Get approvedBy name
            final approvedBy = itemMap['approvedBy'];
            String approvedByName = '';
            if (approvedBy != null) {
              if (approvedBy is Map) {
                approvedByName = (approvedBy['name'] ?? approvedBy['fullName'] ?? approvedBy['displayName'])?.toString() ?? '';
              } else if (approvedBy is String && approvedBy.isNotEmpty) {
                approvedByName = approvedBy;
              }
            }
            
            // Created by: System if system collection or systematic entry, otherwise collector
            final createdByName = (isSystemCollection || isSystematicEntry) ? 'System' : collectedByName;
            
            return <String, dynamic>{
              ...itemMap,
              'from': collectedByName,
              'to': receiverName,
              'createdBy': createdByName, // Add createdBy field (System for systematic entries)
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (itemMap['approvedByName']?.toString() ?? ''),
            };
          }
          // Handle Add Amount and Withdraw wallet transactions
          if (itemMap['type'] == 'Add Amount' || itemMap['type'] == 'Withdraw') {
            // Get performedBy user name - backend sends it as performedBy (populated)
            // Also check createdBy as fallback
            final performedBy = itemMap['performedBy'];
            final createdBy = itemMap['createdBy'];
            
            // Try to get name from performedBy first, then createdBy
            String performerName = 'Unknown';
            if (performedBy != null) {
              if (performedBy is Map) {
                performerName = (performedBy['name']?.toString() ?? 'Unknown');
              } else if (performedBy is String && performedBy.isNotEmpty) {
                performerName = performedBy;
              }
            } else if (createdBy != null) {
              if (createdBy is Map) {
                performerName = (createdBy['name']?.toString() ?? 'Unknown');
              } else if (createdBy is String && createdBy.isNotEmpty) {
                performerName = createdBy;
              }
            }
            
            // Get mode (account) - Cash, UPI, or Bank
            final mode = itemMap['mode']?.toString() ?? 'Unknown';
            
            return <String, dynamic>{
              ...itemMap,
              'from': performerName, // Person who performed the action (login user)
              'to': mode, // Account name (Cash/UPI/Bank)
              'approvedBy': performerName, // Auto-approved by the same person who performed it
            };
          }
          return itemMap;
        }).where((item) {
          // Filter to expenses only if in expense report mode
          if (_isExpenseReportMode) {
            return item['type'] == 'Expenses';
          }
          // For self wallet, exclude WalletTransactions type but allow Add Amount and Withdraw
          // The transformation above converts 'add' to 'Add Amount' and 'withdraw' to 'Withdraw'
          // So we only filter out items that are still 'WalletTransactions' after transformation
          if (isSelfWallet && item['type'] == 'WalletTransactions') {
            return false;
          }
          return true;
        }).toList();

        // Remove duplicate entries: If WalletTransaction has relatedId pointing to Transaction,
        // hide the WalletTransaction and show only the Transaction
        if (isSelfWallet) {
          final Set<String> transactionIds = {};
          final Set<String> walletTransactionIdsToRemove = {};
          
          // First pass: Collect all Transaction IDs
          for (var item in transformedReportData) {
            if (item['type'] == 'Transactions') {
              final transactionId = item['id']?.toString() ?? item['_id']?.toString();
              if (transactionId != null && transactionId.isNotEmpty) {
                transactionIds.add(transactionId);
              }
            }
          }
          
          // Second pass: Find WalletTransactions that have relatedId matching Transaction IDs
          for (var item in transformedReportData) {
            final itemType = item['type']?.toString() ?? '';
            final relatedId = item['relatedId']?.toString();
            final relatedModel = item['relatedModel']?.toString();
            
            // If this is a WalletTransaction with relatedId pointing to a Transaction
            if ((itemType == 'Add Amount' || itemType == 'Withdraw' || itemType == 'WalletTransactions') &&
                relatedId != null && 
                relatedModel == 'Transaction' &&
                transactionIds.contains(relatedId)) {
              // Mark this WalletTransaction for removal
              final walletTransactionId = item['id']?.toString() ?? item['_id']?.toString();
              if (walletTransactionId != null && walletTransactionId.isNotEmpty) {
                walletTransactionIdsToRemove.add(walletTransactionId);
                debugPrint('[SELF WALLET] üîÑ Removing duplicate WalletTransaction (ID: $walletTransactionId) - related to Transaction (ID: $relatedId)');
              }
            }
          }
          
          // Remove WalletTransactions that are duplicates of Transactions
          if (walletTransactionIdsToRemove.isNotEmpty) {
            final beforeCount = transformedReportData.length;
            transformedReportData = transformedReportData.where((item) {
              final itemId = item['id']?.toString() ?? item['_id']?.toString();
              return itemId == null || !walletTransactionIdsToRemove.contains(itemId);
            }).toList();
            debugPrint('[SELF WALLET] üîÑ Removed ${beforeCount - transformedReportData.length} duplicate WalletTransactions (kept Transaction entries)');
          }
        }

        if (mounted) {
          // For Self Wallet: Remove dummy data if all values are zero
          List<Map<String, dynamic>> processedReportData = List<Map<String, dynamic>>.from(transformedReportData);
          Map<String, dynamic>? convertedWallet;

          if (walletRaw != null) {
            convertedWallet = walletRaw is Map<String, dynamic>
                ? Map<String, dynamic>.from(walletRaw)
                : (walletRaw is Map ? Map<String, dynamic>.from(walletRaw as Map) : null);
          }

          // Use parsed values directly (they're already initialized to 0.0, not null)
          double finalCashIn = summaryCashIn;
          double finalCashOut = summaryCashOut;
          double finalBalance = summaryBalance;
          
          // For All Wallet Report and Account Reports: Check if we need to fetch detailed data
          // If yes, skip this setState and update everything together after fetching detailed data
          final bool isAllWalletReport = !isSelfWallet && _selectedItem == NavItem.walletOverview;
          final bool isAccountReports = _selectedItem == NavItem.accountReports;
          final bool shouldFetchDetailedData = isAllWalletReport || isAccountReports;
          final bool shouldSkipFirstSetState = isAllWalletReport || isAccountReports;
          
          // Only show detailed logs for Self Wallet
          if (isSelfWallet) {
            debugPrint('[SELF WALLET] üîç Before setting final values:');
            debugPrint('[SELF WALLET]    summaryCashIn: $summaryCashIn');
            debugPrint('[SELF WALLET]    summaryCashOut: $summaryCashOut');
            debugPrint('[SELF WALLET]    summaryBalance: $summaryBalance');
            debugPrint('[SELF WALLET]    finalCashIn: $finalCashIn');
            debugPrint('[SELF WALLET]    finalCashOut: $finalCashOut');
            debugPrint('[SELF WALLET]    finalBalance: $finalBalance');
          }
          
          if (!isSelfWallet && !_isExpenseReportMode) {
            // All Wallet Report: Use values from AllWalletReportsService API response
            // Values are already parsed from summaryRaw above (summaryCashIn, summaryCashOut, summaryBalance)
            // SKIP for Expense Report Mode - expense report calculates its own values
            finalCashIn = summaryCashIn;
            finalCashOut = summaryCashOut;
            finalBalance = summaryBalance;
            
            // Debug logging for final values
            print('üìä [ALL WALLET REPORTS] Final Summary Values:');
            print('   CashIn: $finalCashIn');
            print('   CashOut: $finalCashOut');
            print('   Balance: $finalBalance');
          } else if (_isExpenseReportMode) {
            // Expense Report Mode: Don't set values here - they're calculated from expenses in _calculateFinancialSummary
            debugPrint('üìä [EXPENSE REPORT] Skipping All Wallet Report value assignment - will calculate from expenses');
            // Keep existing values (they'll be updated by _calculateFinancialSummary)
            finalCashIn = _cashIn;
            finalCashOut = _cashOut;
            finalBalance = _balance;
            
            // For All Wallet Report and Account Reports: Store values but don't setState yet if we're fetching detailed data
            // This prevents flickering - we'll update everything together after detailed data is loaded
            if (shouldFetchDetailedData) {
              // Store the summary values temporarily - they'll be set in setState after detailed data is loaded
              // For Account Reports: Set API summary totals now so they're available when detailed data loads
              if (isAccountReports) {
                setState(() {
                  _cashIn = finalCashIn;
                  _cashOut = finalCashOut;
                  _balance = finalBalance;
                });
                debugPrint('üìä [ACCOUNT REPORTS] Set API summary totals: CashIn=$finalCashIn, CashOut=$finalCashOut, Balance=$finalBalance');
              }
              // Don't call full setState here - wait for detailed data to be loaded to prevent flickering
              print('üìä [ALL WALLET REPORTS] Stored summary values, will update UI after detailed data is loaded');
              // Skip full setState and _applyFilters here - will be called after detailed data is loaded
            } else {
              // Not fetching detailed data, proceed with normal setState
              setState(() {
                _allData = processedReportData;
                _filteredData = processedReportData;
                _wallet = convertedWallet;
                _cashIn = finalCashIn;
                _cashOut = finalCashOut;
                _balance = finalBalance;
              });
              
              _cachedWalletData = {
                'cacheKey': cacheKey,
                'allData': _allData,
                'filteredData': _filteredData,
                'wallet': _wallet,
                'cashIn': _cashIn,
                'cashOut': _cashOut,
                'balance': _balance,
              };
              _cacheTimestamp = DateTime.now();
              _applyFilters();
            }
          } else if (currentUserId != null) {
            // Self Wallet: Use values from API response (already parsed from summaryRaw)
            debugPrint('[SELF WALLET] üí∞ Dashboard: Using API parsed values for Self Wallet');
            debugPrint('[SELF WALLET] üí∞ Parsed values - summaryCashIn: $summaryCashIn, summaryCashOut: $summaryCashOut, summaryBalance: $summaryBalance');
            
            // Use parsed API values (already set from summaryRaw parsing above)
            // These values come from WalletService.getSelfWalletReport() API call
            // Always use the parsed values (they default to 0.0 if parsing failed)
            debugPrint('[SELF WALLET] üí∞ Before assignment - summaryCashIn: $summaryCashIn, summaryCashOut: $summaryCashOut, summaryBalance: $summaryBalance');
            
            // Use parsed values directly (already initialized to 0.0, not null)
            finalCashIn = summaryCashIn;
            finalCashOut = summaryCashOut;
            finalBalance = summaryBalance;
            
            debugPrint('[SELF WALLET] üí∞ After assignment - finalCashIn: $finalCashIn, finalCashOut: $finalCashOut, finalBalance: $finalBalance');
            
            // Fallback: If API didn't provide summary, try wallet balance
            if (finalCashIn == 0.0 && finalCashOut == 0.0 && finalBalance == 0.0 && convertedWallet != null) {
              final walletBalance = _parseAmount(convertedWallet['totalBalance']);
              if (walletBalance != null && walletBalance != 0.0) {
                finalBalance = walletBalance;
                debugPrint('[SELF WALLET] üí∞ Using wallet totalBalance as fallback: $finalBalance');
              }
            }

            // Remove dummy data if all values are zero
            if (finalCashIn == 0.0 && finalCashOut == 0.0 && finalBalance == 0.0) {
              processedReportData = processedReportData.where((item) {
                final isDummy = item['isDummy'] == true ||
                    (item['id']?.toString().startsWith('dummy-') ?? false);
                return !isDummy;
              }).toList();
            }
            
            debugPrint('[SELF WALLET] üí∞ Final Self Wallet values: CashIn=$finalCashIn, CashOut=$finalCashOut, Balance=$finalBalance');
          }

          // For All Wallet Report: Skip setState if we're going to fetch detailed data (prevents flickering)
          if (!shouldSkipFirstSetState) {
            // Extract expenses from financial data for Self Wallet
            List<dynamic> extractedExpenses = [];
            if (isSelfWallet) {
              // Extract expenses from processedReportData
              extractedExpenses = processedReportData
                  .where((item) => item['type'] == 'Expenses' || item['type'] == 'Expense')
                  .take(10) // Take only recent 10 expenses
                  .map((item) {
                    // Convert to expense format expected by _recentExpenses
                    return {
                      'id': item['id'] ?? item['_id'] ?? '',
                      'date': item['date'] ?? item['createdAt'] ?? DateTime.now().toIso8601String(),
                      'createdAt': item['createdAt'] ?? item['date'] ?? DateTime.now().toIso8601String(),
                      'userId': item['createdBy'] is Map 
                          ? item['createdBy']
                          : {'name': item['from'] ?? 'Unknown'},
                      'category': item['category'] ?? item['to'] ?? 'Unknown',
                      'amount': _parseAmount(item['amount']) ?? 0.0,
                      'mode': item['mode'] ?? 'Cash',
                      'description': item['description'] ?? item['purpose'] ?? '',
                      'status': item['status'] ?? 'Pending',
                    };
                  })
                  .toList();
              debugPrint('[SELF WALLET] üìã Extracted ${extractedExpenses.length} expenses from financial data');
            }
            
            setState(() {
              _allData = processedReportData;
              _filteredData = processedReportData;
              _wallet = convertedWallet;
              _cashIn = finalCashIn;
              _cashOut = finalCashOut;
              _balance = finalBalance;
              
              // Update recent expenses for Self Wallet
              if (isSelfWallet && extractedExpenses.isNotEmpty) {
                _recentExpenses = extractedExpenses;
              }
              
              // For Self Wallet, also update _userCashIn, _userCashOut, _userBalance
              // These are used in the UI summary cards
              if (isSelfWallet) {
              final oldUserCashIn = _userCashIn;
              final oldUserCashOut = _userCashOut;
              final oldUserBalance = _userBalance;
              
              debugPrint('[SELF WALLET] üìù Before setState - Current UI values:');
              debugPrint('[SELF WALLET]    oldUserCashIn: $oldUserCashIn');
              debugPrint('[SELF WALLET]    oldUserCashOut: $oldUserCashOut');
              debugPrint('[SELF WALLET]    oldUserBalance: $oldUserBalance');
              debugPrint('[SELF WALLET] üìù Setting NEW UI values:');
              debugPrint('[SELF WALLET]    newUserCashIn: $finalCashIn');
              debugPrint('[SELF WALLET]    newUserCashOut: $finalCashOut');
              debugPrint('[SELF WALLET]    newUserBalance: $finalBalance');
              
              _userCashIn = finalCashIn;
              _userCashOut = finalCashOut;
              _userBalance = finalBalance;
              
              // Log if value was reset from non-zero
              if (oldUserCashIn != 0.0 && finalCashIn == 0.0) {
                debugPrint('[SELF WALLET] ‚ö†Ô∏è  WARNING: Cash In reset from $oldUserCashIn to 0.0!');
                debugPrint('[SELF WALLET] ‚ö†Ô∏è  Location: setState in _loadFinancialData (Self Wallet block)');
              }
              if (oldUserCashOut != 0.0 && finalCashOut == 0.0) {
                debugPrint('[SELF WALLET] ‚ö†Ô∏è  WARNING: Cash Out reset from $oldUserCashOut to 0.0!');
              }
              if (oldUserBalance != 0.0 && finalBalance == 0.0) {
                debugPrint('[SELF WALLET] ‚ö†Ô∏è  WARNING: Balance reset from $oldUserBalance to 0.0!');
              }
              
              debugPrint('[SELF WALLET] üîí Locked _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
              }
            });
            
            if (isSelfWallet) {
              debugPrint('[SELF WALLET] ‚úÖ Dashboard: After setState - Values set:');
              debugPrint('[SELF WALLET]    _cashIn: $_cashIn');
              debugPrint('[SELF WALLET]    _cashOut: $_cashOut');
              debugPrint('[SELF WALLET]    _balance: $_balance');
              debugPrint('[SELF WALLET]    _userCashIn: $_userCashIn');
              debugPrint('[SELF WALLET]    _userCashOut: $_userCashOut');
              debugPrint('[SELF WALLET]    _userBalance: $_userBalance');
              debugPrint('[SELF WALLET]    _allData count: ${_allData.length}');
              debugPrint('[SELF WALLET]    _filteredData count: ${_filteredData.length}');
            } else {
              debugPrint('‚úÖ After setState - Values set:');
              debugPrint('   _cashIn: $_cashIn');
              debugPrint('   _cashOut: $_cashOut');
              debugPrint('   _balance: $_balance');
            }

            _cachedWalletData = {
              'cacheKey': cacheKey,
              'allData': _allData,
              'filteredData': _filteredData,
              'wallet': _wallet,
              'cashIn': _cashIn,
              'cashOut': _cashOut,
              'balance': _balance,
            };
            _cacheTimestamp = DateTime.now();

            // Log before _applyFilters (should not modify _userCashIn for Self Wallet)
            if (isSelfWallet) {
              debugPrint('[SELF WALLET] üìã Before _applyFilters():');
              debugPrint('[SELF WALLET]    _userCashIn: $_userCashIn');
              debugPrint('[SELF WALLET]    _userCashOut: $_userCashOut');
              debugPrint('[SELF WALLET]    _userBalance: $_userBalance');
            }

            _applyFilters();
          } else {
            // For All Wallet Report: Store values but skip setState to prevent flickering
            // Values will be set in setState after detailed data is loaded
            _cashIn = finalCashIn;
            _cashOut = finalCashOut;
            _balance = finalBalance;
            _wallet = convertedWallet;
            print('üìä [ALL WALLET REPORTS] Skipped first setState to prevent flickering - will update after detailed data loads');
          }
          
          // Log after _applyFilters (should not have changed)
          if (isSelfWallet) {
            debugPrint('[SELF WALLET] üìã After _applyFilters():');
            debugPrint('[SELF WALLET]    _userCashIn: $_userCashIn (should be unchanged)');
            debugPrint('[SELF WALLET]    _userCashOut: $_userCashOut (should be unchanged)');
            debugPrint('[SELF WALLET]    _userBalance: $_userBalance (should be unchanged)');
            
            // Warning if values changed after _applyFilters
            if (_userCashIn == 0.0 && finalCashIn != 0.0) {
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  WARNING: _userCashIn changed to 0.0 after _applyFilters()!');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  Location: After _applyFilters() call');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  Expected: $finalCashIn, Actual: $_userCashIn');
            }
          }
        }
      } else {
        // Handle error - API returned success: false or null (from wallet_overview_screen)
        debugPrint('[SELF WALLET] ‚ùå API Error: success=${reportResult['success']}, message=${reportResult['message'] ?? reportResult['error'] ?? 'No message'}, statusCode=${reportResult['statusCode'] ?? 'N/A'}');
        
        String errorMessage = reportResult['message']?.toString() ?? 
                             reportResult['error']?.toString() ?? 
                             'Failed to load self wallet data';
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(errorMessage),
              backgroundColor: AppTheme.errorColor,
              duration: const Duration(seconds: 5),
            ),
          );
        }
        
        if (mounted && isSelfWallet) {
          setState(() {
            _cashIn = 0.0;
            _cashOut = 0.0;
            _balance = 0.0;
            if (isSelfWallet) {
              final oldUserCashIn = _userCashIn;
              final oldUserCashOut = _userCashOut;
              final oldUserBalance = _userBalance;
              
              _userCashIn = 0.0;
              _userCashOut = 0.0;
              _userBalance = 0.0;
              
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  WARNING: Resetting to ZERO in error handler!');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  Location: Error handler in _loadFinancialData (success: false)');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  oldUserCashIn: $oldUserCashIn ‚Üí newUserCashIn: 0.0');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  oldUserCashOut: $oldUserCashOut ‚Üí newUserCashOut: 0.0');
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  oldUserBalance: $oldUserBalance ‚Üí newUserBalance: 0.0');
            } else {
              _userCashIn = 0.0;
              _userCashOut = 0.0;
              _userBalance = 0.0;
            }
            _allData = [];
            _filteredData = [];
          });
        }
      }
    } catch (e) {
      debugPrint('Wallet report fetch failed: $e');
    } finally {
      _isLoadingFinancialData = false;
    }

    // For All Wallet Report, Expense Report, and Account Reports, we need to fetch detailed data even if reportLoaded is true
    // This is needed for filters and filter breakdown to work correctly
    // CRITICAL: For Self Wallet, if reportLoaded is true, skip detailed data fetch to prevent values from being overwritten
    final bool isExpenseReport = _selectedItem == NavItem.expenseReport;
    final bool isAllWalletReport = !isSelfWallet && _selectedItem == NavItem.walletOverview;
    final bool isAccountReports = _selectedItem == NavItem.accountReports;
    // For Self Wallet: Only fetch detailed data if report was NOT loaded (to prevent overwriting API values)
    // For other views: Fetch detailed data as needed
    final bool shouldFetchDetailedData = isSelfWallet 
        ? (!reportLoaded)  // Self Wallet: Only if report not loaded
        : (!reportLoaded || isAllWalletReport || isExpenseReport || isAccountReports);  // Other views: Normal logic

    debugPrint('üîç [DEBUG] shouldFetchDetailedData check:');
    debugPrint('   reportLoaded: $reportLoaded');
    debugPrint('   isAllWalletReport: $isAllWalletReport');
    debugPrint('   isExpenseReport: $isExpenseReport');
    debugPrint('   isAccountReports: $isAccountReports');
    debugPrint('   shouldFetchDetailedData: $shouldFetchDetailedData');

    if (!shouldFetchDetailedData) {
      debugPrint('‚ö†Ô∏è  [DEBUG] Skipping detailed data fetch - shouldFetchDetailedData is false');
      return;
    }

    try {
      List<dynamic> allData = [];
      
      // Get FilterProvider for global filters
      final filterProvider = _filterProvider;
      
      debugPrint('üîç [DEBUG] Starting detailed data fetch...');
      debugPrint('   _selectedItem: $_selectedItem');
      debugPrint('   isAccountReports: ${_selectedItem == NavItem.accountReports}');
      debugPrint('   _selectedAccountFilterId: $_selectedAccountFilterId');
      
      // For All Wallet Report: Determine which users to fetch data for
      List<String>? userIdsForDetailedData;
      if (!isSelfWallet && _selectedItem == NavItem.walletOverview) {
        // For All Wallet Report, use selected user IDs from filter if any
        if (filterProvider.selectedUserIds.isNotEmpty) {
          userIdsForDetailedData = filterProvider.selectedUserIds.toList();
        } else {
          userIdsForDetailedData = null; // Fetch all users' data
        }
      }
      
      // CRITICAL: For Self Wallet, always use currentUserId (ignore user filter)
      // For other views, use null (show all users) unless explicitly filtered
      
      // If in expense report mode, load only expenses using expense report screen API
      debugPrint('üîç [DEBUG] _loadFinancialData - _isExpenseReportMode: $_isExpenseReportMode, _selectedItem: $_selectedItem');
      if (_isExpenseReportMode) {
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üìä [EXPENSE REPORT] Loading expenses from backend API with date filters...');
        debugPrint('   Mode: Expense Report Only');
        debugPrint('   isSelfWallet: $isSelfWallet');
        
        final targetUserId = isSelfWallet ? currentUserId : (userIdsForDetailedData != null && userIdsForDetailedData.length == 1 ? userIdsForDetailedData.first : null);
        debugPrint('   Target User ID: ${targetUserId ?? "All Users"}');
        debugPrint('   Status Filter: ${filterProvider.selectedStatus ?? "All"}');
        debugPrint('   Category Filter: ${_selectedExpenseTypeCategory ?? "All"}');
        debugPrint('   Date Range: ${filterProvider.startDate?.toString() ?? "No start"} to ${filterProvider.endDate?.toString() ?? "No end"}');
        
        // Format dates for API (yyyy-MM-dd format)
        String? fromDateStr;
        String? toDateStr;
        if (filterProvider.startDate != null) {
          fromDateStr = '${filterProvider.startDate!.year}-${filterProvider.startDate!.month.toString().padLeft(2, '0')}-${filterProvider.startDate!.day.toString().padLeft(2, '0')}';
        }
        if (filterProvider.endDate != null) {
          toDateStr = '${filterProvider.endDate!.year}-${filterProvider.endDate!.month.toString().padLeft(2, '0')}-${filterProvider.endDate!.day.toString().padLeft(2, '0')}';
        }
        
        // Map status filter to backend format
        String? statusFilter;
        if (filterProvider.selectedStatus != null && filterProvider.selectedStatus != 'All') {
          // Map frontend status to backend format
          if (filterProvider.selectedStatus == 'Approved') {
            statusFilter = 'approved';
          } else if (filterProvider.selectedStatus == 'Unapproved' || filterProvider.selectedStatus == 'Pending') {
            statusFilter = 'unapproved';
          } else if (filterProvider.selectedStatus == 'Flagged') {
            statusFilter = 'flagged';
          } else {
            statusFilter = filterProvider.selectedStatus!.toLowerCase();
          }
        }
        
        // Load expense report data with date filters from backend
        final expensesResult = await ExpenseService.getExpenseReportScreenData(
          from: fromDateStr,
          to: toDateStr,
          status: statusFilter,
          category: _selectedExpenseTypeCategory != null && _selectedExpenseTypeCategory != 'All' ? _selectedExpenseTypeCategory : null,
          userId: targetUserId,
        );
        
        debugPrint('   üì• [EXPENSE REPORT] Backend response received');
        debugPrint('   Success: ${expensesResult['success']}');
        
        if (expensesResult['success'] == true) {
          final expenses = expensesResult['expenses'] as List<dynamic>? ?? [];
          final summary = expensesResult['summary'] as Map<String, dynamic>? ?? {};
          debugPrint('   Expenses from backend (already filtered by date): ${expenses.length} items');
          debugPrint('   Summary from backend: $summary');
          
          // Process expenses for display
          final processedExpenses = expenses.map((e) {
            final amount = _parseAmount(e['amount']);
            // Get created by person name
            final createdByName = e['createdBy'] is Map 
                ? (e['createdBy']?['name'] ?? 'Unknown')
                : (e['createdByName']?.toString() ?? 'Unknown');
            // Get expense category name
            final categoryName = e['category']?.toString() ?? 'Unknown';
            return {
              ...e,
              'type': 'Expenses',
              'date': e['date'] ?? e['createdAt'],
              'from': createdByName,
              'to': categoryName,
              'amount': amount,
              'status': e['status'] ?? 'Pending',
            };
          }).toList();
          
          allData.addAll(processedExpenses);
          
          debugPrint('   ‚úÖ [EXPENSE REPORT] Added ${processedExpenses.length} expenses to allData');
          debugPrint('   Total allData count: ${allData.length}');
          
          // Update breakdown from backend summary
          if (summary.isNotEmpty) {
            final byStatus = summary['byStatus'] as Map<String, dynamic>? ?? {};
            final approvedData = byStatus['approved'] as Map<String, dynamic>? ?? {};
            final unapprovedData = byStatus['unapproved'] as Map<String, dynamic>? ?? {};
            final flaggedData = byStatus['flagged'] as Map<String, dynamic>? ?? {};
            
            debugPrint('   üìä [EXPENSE REPORT] Updating breakdown from backend summary:');
            debugPrint('     Approved: count=${approvedData['count']}, amount=${approvedData['amount']}');
            debugPrint('     Unapproved: count=${unapprovedData['count']}, amount=${unapprovedData['amount']}');
            debugPrint('     Flagged: count=${flaggedData['count']}, amount=${flaggedData['amount']}');
            
            // Update filter breakdown with backend summary data
            setState(() {
              _filterBreakdown = {
                'Expenses': {
                  'Approved': {
                    'count': (approvedData['count'] ?? 0).toInt(),
                    'amount': _parseAmount(approvedData['amount'] ?? 0),
                  },
                  'Unapproved': {
                    'count': (unapprovedData['count'] ?? 0).toInt(),
                    'amount': _parseAmount(unapprovedData['amount'] ?? 0),
                  },
                  'Flagged': {
                    'count': (flaggedData['count'] ?? 0).toInt(),
                    'amount': _parseAmount(flaggedData['amount'] ?? 0),
                  },
                  'Rejected': {
                    'count': 0,
                    'amount': 0.0,
                  },
                },
                'Transactions': _filterBreakdown['Transactions'] ?? {},
                'Collections': _filterBreakdown['Collections'] ?? {},
              };
            });
          } else {
            debugPrint('   ‚ö†Ô∏è [EXPENSE REPORT] No summary data from backend');
          }
          
          // Calculate cash in/out/balance from loaded expenses
          debugPrint('   üí∞ [EXPENSE REPORT] Calling _calculateFinancialSummary() to calculate cash flow...');
          debugPrint('   üí∞ [EXPENSE REPORT] Before calculation: _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
          debugPrint('   üí∞ [EXPENSE REPORT] Processed expenses count: ${processedExpenses.length}');
          _calculateFinancialSummary(data: processedExpenses);
          debugPrint('   üí∞ [EXPENSE REPORT] After _calculateFinancialSummary: _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        } else {
          debugPrint('   ‚ùå [EXPENSE REPORT] Failed to load expenses');
          debugPrint('   Error: ${expensesResult['message'] ?? 'Unknown error'}');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
      } else {
        // Load all data types (expenses, transactions, collections)
        // This applies to: All Wallet Report, Account Reports, and other views
        final bool isAccountReports = _selectedItem == NavItem.accountReports;
        final bool hasAccountFilter = isAccountReports && _selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty;
        
        if (isAccountReports) {
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          debugPrint('üìä [ACCOUNT REPORTS] Loading detailed data (expenses, collections, transactions)...');
          debugPrint('   Account filter: ${_selectedAccountFilterId ?? 'None (All Accounts)'}');
          debugPrint('   hasAccountFilter: $hasAccountFilter');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        } else {
          debugPrint('‚ö†Ô∏è  [DEBUG] Expense Report Mode is FALSE - loading all data types');
        }
        
        // For Account Reports: Load ALL data and filter client-side by accountId
        // Don't use mode filter in API calls - backend mode filter might not match account names
        // Instead, load all data and filter by accountId in _applyFilters
        if (isAccountReports) {
          debugPrint('üìä [ACCOUNT REPORTS] Loading ALL data (will filter by accountId client-side)');
        }
        
        // For Self Wallet, filter by user ID for each service
        // For All Wallet Report, apply user filters if set
        // For Account Reports: Load all data, filter by accountId in _applyFilters
        // Note: Transaction and Collection services may need OR filtering (sender OR receiver, collectedBy OR assignedReceiver)
        // The backend getWalletReport API handles this better, so we primarily use that
        final results = await Future.wait([
          ExpenseService.getExpenses(
            userId: isSelfWallet ? currentUserId : (userIdsForDetailedData != null && userIdsForDetailedData.length == 1 ? userIdsForDetailedData.first : null),
            status: filterProvider.selectedStatus,
            mode: filterProvider.selectedMode, // Don't filter by account mode - load all and filter client-side
          ),
          // For transactions, we need to filter by user being sender OR receiver
          // The backend getWalletReport handles this, but for fallback we load all and filter client-side
          TransactionService.getTransactions(
            status: filterProvider.selectedStatus,
            mode: filterProvider.selectedMode, // Don't filter by account mode - load all and filter client-side
          ),
          // For collections, we need to filter by user being collector OR assigned receiver
          CollectionService.getCollections(
            status: filterProvider.selectedStatus,
            mode: filterProvider.selectedMode, // Don't filter by account mode - load all and filter client-side
            startDate: filterProvider.startDate?.toIso8601String(),
            endDate: filterProvider.endDate?.toIso8601String(),
          ),
        ]);
        
        final expensesResult = results[0] as Map<String, dynamic>;
        final transactionsResult = results[1] as Map<String, dynamic>;
        final collectionsResult = results[2] as Map<String, dynamic>;
        
        // Process expenses (already filtered by userId if isSelfWallet)
        if (expensesResult['success'] == true) {
          final expenses = expensesResult['expenses'] as List<dynamic>? ?? [];
          // Apply date filtering client-side if date filters are set
          final filteredExpenses = (filterProvider.startDate != null || filterProvider.endDate != null)
              ? expenses.where((e) {
                  try {
                    final itemDate = e['date'] != null 
                        ? DateTime.parse(e['date'].toString()).toLocal()
                        : (e['createdAt'] != null 
                            ? DateTime.parse(e['createdAt'].toString()).toLocal()
                            : null);
                    if (itemDate == null) return false;
                    if (filterProvider.startDate != null && itemDate.isBefore(filterProvider.startDate!)) return false;
                    if (filterProvider.endDate != null && itemDate.isAfter(filterProvider.endDate!.add(const Duration(days: 1)))) return false;
                    return true;
                  } catch (e) {
                    return false;
                  }
                }).toList()
              : expenses;
          allData.addAll(filteredExpenses.map((e) {
            final amount = _parseAmount(e['amount']);
            // Get created by person name
            final createdByName = e['createdBy'] is Map 
                ? (e['createdBy']?['name'] ?? 'Unknown')
                : 'Unknown';
            // Get expense category name
            final categoryName = e['category']?.toString() ?? 'Unknown';
            // Extract payment mode/account name
            final accountName = _extractPaymentModeName(e) ?? (e['mode']?.toString() ?? 'Cash');
            // Extract approvedBy name
            final approvedByValue = e['approvedBy'];
            String approvedByName = '';
            if (approvedByValue != null) {
              if (approvedByValue is Map) {
                approvedByName = approvedByValue['name'] ?? approvedByValue['fullName'] ?? approvedByValue['displayName'] ?? '';
              } else if (approvedByValue is String && approvedByValue.isNotEmpty) {
                approvedByName = approvedByValue;
              }
            }
            return {
              ...e,
              'type': 'Expenses',
              'date': e['date'] ?? e['createdAt'],
              'from': createdByName,
              'to': categoryName,
              'amount': amount,
              'status': e['status'] ?? 'Pending',
              'accountName': accountName, // Add account name
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (e['approvedByName'] ?? ''), // Add approvedBy
            };
          }));
          
          if (isAccountReports) {
            debugPrint('   ‚úÖ [ACCOUNT REPORTS] Added ${filteredExpenses.length} expenses to allData');
          }
        } else {
          if (isAccountReports) {
            debugPrint('   ‚ùå [ACCOUNT REPORTS] Failed to load expenses: ${expensesResult['message'] ?? 'Unknown error'}');
          }
        }
        
        // Process transactions
        if (transactionsResult['success'] == true) {
          final transactions = transactionsResult['transactions'] as List<dynamic>? ?? [];
          // First filter by user (if needed)
          var userFilteredTransactions = (isSelfWallet && currentUserId != null)
              ? transactions.where((t) {
                  // Filter to transactions where user is sender, receiver, or initiator
                  final senderId = t['sender'] is Map
                      ? (t['sender']?['_id'] ?? t['sender']?['id'] ?? '').toString()
                      : (t['sender'] ?? '').toString();
                  final receiverId = t['receiver'] is Map
                      ? (t['receiver']?['_id'] ?? t['receiver']?['id'] ?? '').toString()
                      : (t['receiver'] ?? '').toString();
                  final initiatedById = t['initiatedBy'] is Map
                      ? (t['initiatedBy']?['_id'] ?? t['initiatedBy']?['id'] ?? '').toString()
                      : (t['initiatedBy'] ?? '').toString();
                  return senderId == currentUserId ||
                      receiverId == currentUserId ||
                      initiatedById == currentUserId;
                }).toList()
              : (userIdsForDetailedData != null && userIdsForDetailedData.isNotEmpty
                  ? transactions.where((t) {
                      // For All Wallet Report with user filter: filter to transactions involving selected users
                      final senderId = t['sender'] is Map
                          ? (t['sender']?['_id'] ?? t['sender']?['id'] ?? '').toString()
                          : (t['sender'] ?? '').toString();
                      final receiverId = t['receiver'] is Map
                          ? (t['receiver']?['_id'] ?? t['receiver']?['id'] ?? '').toString()
                          : (t['receiver'] ?? '').toString();
                      final initiatedById = t['initiatedBy'] is Map
                          ? (t['initiatedBy']?['_id'] ?? t['initiatedBy']?['id'] ?? '').toString()
                          : (t['initiatedBy'] ?? '').toString();
                      return userIdsForDetailedData!.contains(senderId) ||
                          userIdsForDetailedData!.contains(receiverId) ||
                          userIdsForDetailedData!.contains(initiatedById);
                    }).toList()
                  : transactions);
          // Then apply date filtering client-side if date filters are set
          final filteredTransactions = (filterProvider.startDate != null || filterProvider.endDate != null)
              ? userFilteredTransactions.where((t) {
                  try {
                    final itemDate = t['date'] != null 
                        ? DateTime.parse(t['date'].toString()).toLocal()
                        : (t['createdAt'] != null 
                            ? DateTime.parse(t['createdAt'].toString()).toLocal()
                            : null);
                    if (itemDate == null) return false;
                    if (filterProvider.startDate != null && itemDate.isBefore(filterProvider.startDate!)) return false;
                    if (filterProvider.endDate != null && itemDate.isAfter(filterProvider.endDate!.add(const Duration(days: 1)))) return false;
                    return true;
                  } catch (e) {
                    return false;
                  }
                }).toList()
              : userFilteredTransactions;
          allData.addAll(filteredTransactions.map((t) {
            final amount = _parseAmount(t['amount']);
            // Extract payment mode/account name
            final accountName = _extractPaymentModeName(t) ?? (t['mode']?.toString() ?? 'Cash');
            // Extract approvedBy name
            final approvedByValue = t['approvedBy'];
            String approvedByName = '';
            if (approvedByValue != null) {
              if (approvedByValue is Map) {
                approvedByName = approvedByValue['name'] ?? approvedByValue['fullName'] ?? approvedByValue['displayName'] ?? '';
              } else if (approvedByValue is String && approvedByValue.isNotEmpty) {
                approvedByName = approvedByValue;
              }
            }
            return {
              ...t,
              'type': 'Transactions',
              'date': t['date'] ?? t['createdAt'],
              'from': t['sender']?['name'] ?? 'Unknown',
              'to': t['receiver']?['name'] ?? 'Unknown',
              'amount': amount,
              'status': t['status'] ?? 'Pending',
              'accountName': accountName, // Add account name
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (t['approvedByName'] ?? ''), // Add approvedBy
            };
          }));
          
          if (isAccountReports) {
            debugPrint('   ‚úÖ [ACCOUNT REPORTS] Added ${filteredTransactions.length} transactions to allData');
          }
        } else {
          if (isAccountReports) {
            debugPrint('   ‚ùå [ACCOUNT REPORTS] Failed to load transactions: ${transactionsResult['message'] ?? 'Unknown error'}');
          }
        }
        
        // Process collections
        if (collectionsResult['success'] == true) {
          final collections = collectionsResult['collections'] as List<dynamic>? ?? [];
          final filteredCollections = (isSelfWallet && currentUserId != null)
              ? collections.where((c) {
                  // Filter to collections where user is collector or assigned receiver
                  final collectedById = c['collectedBy'] is Map
                      ? (c['collectedBy']?['_id'] ?? c['collectedBy']?['id'] ?? '').toString()
                      : (c['collectedBy'] ?? '').toString();
                  final assignedReceiverId = c['assignedReceiver'] is Map
                      ? (c['assignedReceiver']?['_id'] ?? c['assignedReceiver']?['id'] ?? '').toString()
                      : (c['assignedReceiver'] ?? '').toString();
                  return collectedById == currentUserId ||
                      assignedReceiverId == currentUserId;
                }).toList()
              : (userIdsForDetailedData != null && userIdsForDetailedData.isNotEmpty
                  ? collections.where((c) {
                      // For All Wallet Report with user filter: filter to collections involving selected users
                      final collectedById = c['collectedBy'] is Map
                          ? (c['collectedBy']?['_id'] ?? c['collectedBy']?['id'] ?? '').toString()
                          : (c['collectedBy'] ?? '').toString();
                      final assignedReceiverId = c['assignedReceiver'] is Map
                          ? (c['assignedReceiver']?['_id'] ?? c['assignedReceiver']?['id'] ?? '').toString()
                          : (c['assignedReceiver'] ?? '').toString();
                      return userIdsForDetailedData!.contains(collectedById) ||
                          userIdsForDetailedData!.contains(assignedReceiverId);
                    }).toList()
                  : collections);
          allData.addAll(filteredCollections.map((c) {
            final amount = _parseAmount(c['amount']);
            
            // Extract collectedBy name properly
            final collectedBy = c['collectedBy'];
            String collectedByName = 'Unknown';
            if (collectedBy != null) {
              if (collectedBy is Map) {
                collectedByName = collectedBy['name'] ?? collectedBy['fullName'] ?? collectedBy['displayName'] ?? 'Unknown';
              } else if (collectedBy is String && collectedBy.isNotEmpty) {
                collectedByName = 'Unknown'; // ObjectId string, can't get name
              }
            }
            
            // Extract assignedReceiver name properly
            final assignedReceiver = c['assignedReceiver'];
            String receiverName = 'Not Assigned';
            if (assignedReceiver != null) {
              if (assignedReceiver is Map) {
                receiverName = assignedReceiver['name'] ?? assignedReceiver['fullName'] ?? assignedReceiver['displayName'] ?? 'Unknown';
              } else if (assignedReceiver is String && assignedReceiver.isNotEmpty) {
                receiverName = 'Not Assigned'; // ObjectId string, can't get name
              }
            }
            
            // Extract approvedBy name
            final approvedBy = c['approvedBy'];
            String approvedByName = '';
            if (approvedBy != null) {
              if (approvedBy is Map) {
                approvedByName = approvedBy['name'] ?? approvedBy['fullName'] ?? approvedBy['displayName'] ?? '';
              } else if (approvedBy is String && approvedBy.isNotEmpty) {
                approvedByName = approvedBy;
              }
            }
            
            // Extract payment mode/account name
            final accountName = _extractPaymentModeName(c) ?? (c['mode']?.toString() ?? 'Cash');
            
            return {
              ...c,
              'type': 'Collections',
              'date': c['createdAt'] ?? c['date'],
              'from': collectedByName,
              'to': receiverName,
              'createdBy': collectedByName, // Add createdBy field
              'approvedBy': approvedByName.isNotEmpty ? approvedByName : (c['approvedByName'] ?? ''),
              'amount': amount,
              'status': c['status'] ?? 'Pending',
              'accountName': accountName, // Add account name
            };
          }));
          
          if (isAccountReports) {
            debugPrint('   ‚úÖ [ACCOUNT REPORTS] Added ${filteredCollections.length} collections to allData');
          }
        } else {
          if (isAccountReports) {
            debugPrint('   ‚ùå [ACCOUNT REPORTS] Failed to load collections: ${collectionsResult['message'] ?? 'Unknown error'}');
          }
        }
        
        if (isAccountReports) {
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          debugPrint('üìä [ACCOUNT REPORTS] Detailed data loading complete:');
          debugPrint('   Total items in allData: ${allData.length}');
          debugPrint('   Account filter: ${_selectedAccountFilterId ?? 'None'}');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          // Don't set flag here - will be set after setState successfully completes
        }
      }

      // Sort all data by date (newest first)
      allData.sort((a, b) {
        try {
          final dateA = DateTime.parse(a['date'].toString());
          final dateB = DateTime.parse(b['date'].toString());
          return dateB.compareTo(dateA);
        } catch (e) {
          return 0;
        }
      });

      // Calculate cashIn/cashOut/balance from loaded data (especially for self wallet)
      double calculatedCashIn = 0.0;
      double calculatedCashOut = 0.0;
      double calculatedBalance = 0.0;

      if (isSelfWallet && currentUserId != null) {
        final flow = _calculateSelfWalletCashFlow(
          allData.map((e) => Map<String, dynamic>.from(e as Map)).toList(),
          currentUserId,
          _wallet,
        );
        calculatedCashIn = flow['cashIn'] ?? 0.0;
        calculatedCashOut = flow['cashOut'] ?? 0.0;
        calculatedBalance = flow['balance'] ?? 0.0;
      } else {
        for (final item in allData) {
          final amount = _parseAmount(item['amount']);
          final type = item['type']?.toString() ?? '';
          
          if (type == 'Expenses') {
            // With new backend logic: Admin pays User1 (reimbursement)
            // So for expense owner: Approved expense = Cash In (reimbursement received)
            // Note: This calculation is from expense owner's perspective
            if (_isItemApproved(item)) {
              calculatedCashIn += amount; // Expense owner receives reimbursement
            }
          } else if (type == 'Collections') {
            if (_isItemApproved(item)) {
              calculatedCashIn += amount;
            }
          } else if (type == 'Transactions') {
            if (_isItemApproved(item)) {
              calculatedCashIn += amount;
            }
          } else if (type == 'Add Amount' || type.toLowerCase() == 'add amount') {
            calculatedCashIn += amount;
          } else if (type == 'Withdraw' || type.toLowerCase() == 'withdraw') {
            calculatedCashOut += amount;
          }
        }
        calculatedBalance = calculatedCashIn - calculatedCashOut;
      }

      if (mounted) {
        // For Self Wallet: Remove dummy data if all values are zero
        List<dynamic> processedData = allData;
        if (isSelfWallet && calculatedCashIn == 0.0 && calculatedCashOut == 0.0 && calculatedBalance == 0.0) {
          processedData = allData.where((item) {
            // Remove any entries marked as dummy data
            final isDummy = item['isDummy'] == true || 
                           (item['id']?.toString().startsWith('dummy-') ?? false);
            return !isDummy;
          }).toList();
        }
        
        // Log Account Reports data summary
        if (_selectedItem == NavItem.accountReports) {
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          debugPrint('üìä [ACCOUNT REPORTS] Data loaded successfully:');
          debugPrint('   Total items loaded: ${processedData.length}');
          debugPrint('   Account filter: ${_selectedAccountFilterId ?? 'None (All Accounts)'}');
          final expensesCount = processedData.where((item) => item['type'] == 'Expenses').length;
          final collectionsCount = processedData.where((item) => item['type'] == 'Collections').length;
          final transactionsCount = processedData.where((item) => item['type'] == 'Transactions').length;
          debugPrint('   Expenses: $expensesCount');
          debugPrint('   Collections: $collectionsCount');
          debugPrint('   Transactions: $transactionsCount');
          debugPrint('   Cash In: $calculatedCashIn');
          debugPrint('   Cash Out: $calculatedCashOut');
          debugPrint('   Balance: $calculatedBalance');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
        
        setState(() {
          _allData = processedData;
          _filteredData = processedData;
          // For Self Wallet, ALWAYS use API summary values (already set at line 3853-3855)
          // API values come from backend's stored wallet cashIn/cashOut which are accurate
          // DO NOT recalculate from filtered data - it causes wrong values on refresh
          // For All Wallet Report, keep API summary values (already set, don't overwrite)
          // For other views, only update if not already set from API summary
          if (isSelfWallet) {
            // CRITICAL: Keep API summary values that were already set at line 3853-3855
            // These values come from backend API which uses stored wallet cashIn/cashOut
            // Recalculating from filtered data causes wrong values because:
            // 1. Filters (date/status/type) make data incomplete
            // 2. Double counting can occur (wallet transactions + related expenses/transactions)
            // 3. API already provides correct TOTAL values from stored wallet
            // Only use calculated values as fallback if API values are completely missing (all zeros)
            if (_cashIn == 0.0 && _cashOut == 0.0 && _balance == 0.0) {
              // Fallback: API values missing, use calculated (shouldn't happen normally)
              debugPrint('[SELF WALLET] ‚ö†Ô∏è  API values missing, using calculated as fallback');
              _cashIn = calculatedCashIn;
              _cashOut = calculatedCashOut;
              // Use actual wallet balance if available, otherwise use calculated balance
              if (_wallet != null) {
                final wallet = _wallet!;
                final walletBalance = _parseAmount(wallet['totalBalance']);
                if (walletBalance != null && walletBalance != 0.0) {
                  _balance = walletBalance;
                } else {
                  _balance = calculatedBalance;
                }
              } else {
                _balance = calculatedBalance;
              }
            } else {
              // Keep existing API values - they are correct and already set
              debugPrint('[SELF WALLET] ‚úÖ Keeping API summary values: CashIn=$_cashIn, CashOut=$_cashOut, Balance=$_balance');
              debugPrint('[SELF WALLET]    (Calculated would be: CashIn=$calculatedCashIn, CashOut=$calculatedCashOut, Balance=$calculatedBalance)');
              // Don't overwrite - API values are the source of truth
            }
          } else if (!isSelfWallet && _selectedItem == NavItem.walletOverview) {
            // All Wallet Report: Keep API summary values (already set from aggregated totals API)
            // Don't overwrite with calculated values - API values are more accurate
            print('üìä [ALL WALLET REPORTS] Keeping API summary values: cashIn=$_cashIn, cashOut=$_cashOut, balance=$_balance');
          } else if (_selectedItem == NavItem.accountReports) {
            // Account Reports: Handle totals based on account filter
            final bool hasAccountFilter = _selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty;
            
            if (hasAccountFilter) {
              // Account filter selected: Use API summary values (already filtered by accountId in backend)
              // The API already returned the correct totals for this account
              // Only recalculate from filtered data if we have actual data AND API values are 0
              debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              debugPrint('üìä [ACCOUNT REPORTS] Account filter active - using API summary totals');
              debugPrint('   Account ID: $_selectedAccountFilterId');
              debugPrint('   API Cash In: $_cashIn (from API)');
              debugPrint('   API Cash Out: $_cashOut (from API)');
              debugPrint('   API Balance: $_balance (from API)');
              debugPrint('   Note: API already filtered by accountId, so these are correct');
              debugPrint('   _applyFilters will only recalculate if we have detailed data');
              debugPrint('   Current state: _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
              debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              
              // API summary values are already set at line 3178-3183
              // Keep them - _applyFilters will only update if we have detailed data to recalculate from
            } else {
              // No account filter: Use API summary totals (all accounts)
              debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              debugPrint('üìä [ACCOUNT REPORTS] No account filter - using API summary (all accounts)');
              debugPrint('   API Cash In: $_cashIn');
              debugPrint('   API Cash Out: $_cashOut');
              debugPrint('   API Balance: $_balance');
              debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
              
              // Keep API summary values (already set from reportResult)
              // Don't overwrite with calculated values
            }
          } else {
            // Only update if values haven't been set from API summary
            if (_cashIn == 0.0 && _cashOut == 0.0 && _balance == 0.0) {
              _cashIn = calculatedCashIn;
              _cashOut = calculatedCashOut;
              _balance = calculatedBalance;
            }
          }
        });
        
        // Cache the data
        _cachedWalletData = {
          'cacheKey': cacheKey,
          'allData': _allData,
          'filteredData': _filteredData,
          'wallet': _wallet,
          'cashIn': _cashIn,
          'cashOut': _cashOut,
          'balance': _balance,
        };
        _cacheTimestamp = DateTime.now();
        
        // Update filter breakdown with all loaded data (for Status Count Table)
        // This ensures the breakdown shows totals for all data, not just filtered data
        _updateFilterBreakdown(data: processedData);
        
        // For Account Reports: Mark as loaded AFTER data is successfully set
        if (_selectedItem == NavItem.accountReports) {
          _accountReportsDataLoaded = true;
          _isInitializingAccountReports = false; // Reset initialization flag
          _accountReportsCallbackScheduled = false; // Reset callback scheduled flag
          debugPrint('üìä [ACCOUNT REPORTS] Data successfully loaded and set - marked as loaded');
        }
        
        _applyFilters();
      }
    } catch (e) {
      debugPrint('Failed to load financial data: $e');
      // For Self Wallet, don't use dummy data - show empty state instead
      if (mounted) {
        if (isSelfWallet) {
          // Self Wallet: Show empty state on error (no dummy data)
          setState(() {
            _allData = [];
            _filteredData = [];
            _cashIn = 0.0;
            _cashOut = 0.0;
            _balance = 0.0;
          });
        } else {
          // Other views: Show empty state on error (no dummy data)
          setState(() {
            _allData = [];
            _filteredData = [];
            _cashIn = 0.0;
            _cashOut = 0.0;
            _balance = 0.0;
          });
        }
        
        _cachedWalletData = {
          'cacheKey': cacheKey,
          'allData': _allData,
          'filteredData': _filteredData,
          'wallet': _wallet,
          'cashIn': _cashIn,
          'cashOut': _cashOut,
          'balance': _balance,
        };
        _cacheTimestamp = DateTime.now();
        
        // For Account Reports: Reset initialization flag on error
        if (_selectedItem == NavItem.accountReports) {
          _isInitializingAccountReports = false;
          _accountReportsCallbackScheduled = false; // Reset callback scheduled flag
        }
        
        _applyFilters();
      }
    } finally {
      _isLoadingFinancialData = false;
      
      // For Account Reports: Ensure initialization flag is reset in finally block
      if (_selectedItem == NavItem.accountReports) {
        _isInitializingAccountReports = false;
        _accountReportsCallbackScheduled = false; // Reset callback scheduled flag
      }
    }
  }

  // Generate dummy data for All Accounts Report table view
  List<Map<String, dynamic>> _generateDummyDataForAllAccounts() {
    final now = DateTime.now();
    final dummyData = <Map<String, dynamic>>[];

    // Helper function to format date as ISO string
    String formatDate(DateTime date) {
      return date.toIso8601String();
    }

    // Add Amount Transactions
    final addDate1 = now.subtract(const Duration(days: 1));
    final addDate2 = now.subtract(const Duration(days: 3));
    final addDate3 = now.subtract(const Duration(days: 5));
    
    dummyData.addAll([
      {
        'id': 'wt_add_1',
        'type': 'Add Amount',
        'date': formatDate(addDate1),
        'createdAt': formatDate(addDate1),
        'from': 'SuperAdmin',
        'to': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'amount': 50000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_hdfc_1234',
        'accountName': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount added to account acc_hdfc_1234 by SuperAdmin',
      },
      {
        'id': 'wt_add_2',
        'type': 'Add Amount',
        'date': formatDate(addDate2),
        'createdAt': formatDate(addDate2),
        'from': 'SuperAdmin',
        'to': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'amount': 30000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_icici_5678',
        'accountName': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount added to account acc_icici_5678 by SuperAdmin',
      },
      {
        'id': 'wt_add_3',
        'type': 'Add Amount',
        'date': formatDate(addDate3),
        'createdAt': formatDate(addDate3),
        'from': 'SuperAdmin',
        'to': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'amount': 25000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_sbi_9012',
        'accountName': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount added to account acc_sbi_9012 by SuperAdmin',
      },
    ]);

    // Withdraw Transactions
    final withdrawDate1 = now.subtract(const Duration(hours: 6));
    final withdrawDate2 = now.subtract(const Duration(days: 2));
    final withdrawDate3 = now.subtract(const Duration(days: 4));
    
    dummyData.addAll([
      {
        'id': 'wt_withdraw_1',
        'type': 'Withdraw',
        'date': formatDate(withdrawDate1),
        'createdAt': formatDate(withdrawDate1),
        'from': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'to': 'SuperAdmin',
        'amount': 15000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_hdfc_1234',
        'accountName': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount withdrawn from account acc_hdfc_1234 by SuperAdmin',
      },
      {
        'id': 'wt_withdraw_2',
        'type': 'Withdraw',
        'date': formatDate(withdrawDate2),
        'createdAt': formatDate(withdrawDate2),
        'from': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'to': 'SuperAdmin',
        'amount': 10000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_icici_5678',
        'accountName': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount withdrawn from account acc_icici_5678 by SuperAdmin',
      },
      {
        'id': 'wt_withdraw_3',
        'type': 'Withdraw',
        'date': formatDate(withdrawDate3),
        'createdAt': formatDate(withdrawDate3),
        'from': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'to': 'SuperAdmin',
        'amount': 20000.0,
        'mode': 'Bank',
        'status': 'Completed',
        'accountId': 'acc_sbi_9012',
        'accountName': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'createdBy': {'name': 'SuperAdmin', 'email': 'admin@example.com', 'role': 'SuperAdmin'},
        'notes': 'Amount withdrawn from account acc_sbi_9012 by SuperAdmin',
      },
    ]);

    // Regular Transactions
    final txDate1 = now.subtract(const Duration(hours: 2));
    final txDate2 = now.subtract(const Duration(days: 1, hours: 3));
    
    dummyData.addAll([
      {
        'id': 'tx_1',
        'type': 'Transactions',
        'date': formatDate(txDate1),
        'createdAt': formatDate(txDate1),
        'from': 'John Doe',
        'to': 'Jane Smith',
        'amount': 5000.0,
        'mode': 'UPI',
        'status': 'Approved',
        'accountName': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'createdBy': {'name': 'John Doe', 'email': 'john@example.com', 'role': 'Staff'},
        'purpose': 'Payment for services',
      },
      {
        'id': 'tx_2',
        'type': 'Transactions',
        'date': formatDate(txDate2),
        'createdAt': formatDate(txDate2),
        'from': 'Admin User',
        'to': 'Staff Member',
        'amount': 3000.0,
        'mode': 'Cash',
        'status': 'Pending',
        'accountName': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'createdBy': {'name': 'Admin User', 'email': 'admin@example.com', 'role': 'Admin'},
        'purpose': 'Salary advance',
      },
    ]);

    // Collections
    final colDate1 = now.subtract(const Duration(hours: 4));
    final colDate2 = now.subtract(const Duration(days: 2, hours: 5));
    
    dummyData.addAll([
      {
        'id': 'col_1',
        'type': 'Collections',
        'date': formatDate(colDate1),
        'createdAt': formatDate(colDate1),
        'from': 'Collection Agent',
        'to': 'Admin User',
        'amount': 10000.0,
        'mode': 'Cash',
        'status': 'Verified',
        'accountName': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'createdBy': {'name': 'Collection Agent', 'email': 'agent@example.com', 'role': 'Staff'},
        'customerName': 'Customer ABC',
        'voucherNumber': 'VCH-001',
      },
      {
        'id': 'col_2',
        'type': 'Collections',
        'date': formatDate(colDate2),
        'createdAt': formatDate(colDate2),
        'from': 'Field Collector',
        'to': 'Admin User',
        'amount': 7500.0,
        'mode': 'UPI',
        'status': 'Pending',
        'accountName': 'HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234',
        'createdBy': {'name': 'Field Collector', 'email': 'collector@example.com', 'role': 'Staff'},
        'customerName': 'Customer XYZ',
        'voucherNumber': 'VCH-002',
      },
    ]);

    // Expenses
    final expDate1 = now.subtract(const Duration(hours: 1));
    final expDate2 = now.subtract(const Duration(days: 1, hours: 8));
    
    dummyData.addAll([
      {
        'id': 'exp_1',
        'type': 'Expenses',
        'date': formatDate(expDate1),
        'createdAt': formatDate(expDate1),
        'from': 'Admin User',
        'to': 'Office Supplies',
        'amount': 2500.0,
        'mode': 'Cash',
        'status': 'Approved',
        'accountName': 'ICICI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 5678',
        'createdBy': {'name': 'Admin User', 'email': 'admin@example.com', 'role': 'Admin'},
        'category': 'Office Supplies',
        'description': 'Stationery purchase',
      },
      {
        'id': 'exp_2',
        'type': 'Expenses',
        'date': formatDate(expDate2),
        'createdAt': formatDate(expDate2),
        'from': 'Staff Member',
        'to': 'Travel',
        'amount': 1200.0,
        'mode': 'Bank',
        'status': 'Pending',
        'accountName': 'SBI Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 9012',
        'createdBy': {'name': 'Staff Member', 'email': 'staff@example.com', 'role': 'Staff'},
        'category': 'Travel',
        'description': 'Travel expenses',
      },
    ]);

    // Sort by date (newest first)
    dummyData.sort((a, b) {
      try {
        final dateA = DateTime.parse(a['date'].toString());
        final dateB = DateTime.parse(b['date'].toString());
        return dateB.compareTo(dateA);
      } catch (e) {
        return 0;
      }
    });

    return dummyData;
  }

  Future<void> _refreshDashboardAndFinancialData() async {
    if (_isRefreshing) {
      debugPrint('üîÑ [REFRESH] Already refreshing, skipping...');
      return;
    }

    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    debugPrint('üîÑ [REFRESH BUTTON] CLICKED - BEFORE REFRESH');
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    if (isSelfWallet) {
      debugPrint('[SELF WALLET] üìä Current Values BEFORE Refresh:');
      debugPrint('   _cashIn: $_cashIn');
      debugPrint('   _cashOut: $_cashOut');
      debugPrint('   _balance: $_balance');
      debugPrint('   _userCashIn: $_userCashIn');
      debugPrint('   _userCashOut: $_userCashOut');
      debugPrint('   _userBalance: $_userBalance');
      debugPrint('   Cache exists: ${_cachedWalletData != null}');
      if (_cachedWalletData != null) {
        final cachedCashIn = (_cachedWalletData!['cashIn'] as num?)?.toDouble() ?? 0.0;
        final cachedCashOut = (_cachedWalletData!['cashOut'] as num?)?.toDouble() ?? 0.0;
        final cachedBalance = (_cachedWalletData!['balance'] as num?)?.toDouble() ?? 0.0;
        debugPrint('   Cached values: cashIn=$cachedCashIn, cashOut=$cachedCashOut, balance=$cachedBalance');
      }
    }
    debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    setState(() {
      _isRefreshing = true;
    });

    try {
      // Always refresh dashboard data
      await _loadDashboardData();
      
      // Refresh based on current screen
      switch (_selectedItem) {
        case NavItem.dashboard:
        case NavItem.walletOverview:
        case NavItem.walletSelf:
        case NavItem.walletAll:
        case NavItem.accountReports:
        case NavItem.expenseReport:
          // Financial data screens
      debugPrint('[REFRESH] Calling _loadFinancialData with forceRefresh: true');
      await _loadFinancialData(forceRefresh: true, isSelfWallet: isSelfWallet);
          break;
          
        case NavItem.expenseType:
          // Expense Types
          await _loadExpenseTypes();
          break;
          
        case NavItem.users:
          // Users
          await _loadAllUsers();
          break;
          
        case NavItem.roles:
          // Roles - screen has its own refresh mechanism
          // Trigger refresh by calling _autoRefreshCurrentScreen
          _autoRefreshCurrentScreen(forceRefresh: true);
          break;
          
        case NavItem.paymentModes:
          // Payment Modes
          await _loadPaymentModes();
          break;
          
        case NavItem.collectionCustomField:
          // Collection Custom Fields
          _collectionCustomFieldRefreshKey.currentState?.refresh();
          break;
          
        case NavItem.smartApprovals:
          // Smart Approvals
          _pendingApprovalsRefreshKey.currentState?.refresh();
          break;
          
        default:
          // Other screens - refresh financial data as fallback
          await _loadFinancialData(forceRefresh: true, isSelfWallet: isSelfWallet);
          break;
      }
      
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      debugPrint('üîÑ [REFRESH BUTTON] AFTER REFRESH');
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      if (isSelfWallet) {
        debugPrint('[SELF WALLET] üìä New Values AFTER Refresh:');
        debugPrint('   _cashIn: $_cashIn');
        debugPrint('   _cashOut: $_cashOut');
        debugPrint('   _balance: $_balance');
        debugPrint('   _userCashIn: $_userCashIn');
        debugPrint('   _userCashOut: $_userCashOut');
        debugPrint('   _userBalance: $_userBalance');
      }
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    } finally {
      if (!mounted) {
        return;
      }

      setState(() {
        _isRefreshing = false;
      });
      
      debugPrint('[REFRESH] ‚úÖ Refresh completed, _isRefreshing set to false');
    }
  }

  /// Unified auto-refresh handler - refreshes current screen based on _selectedItem
  /// This method is called from all socket events to auto-refresh the current screen
  void _autoRefreshCurrentScreen({bool forceRefresh = true}) {
    if (!mounted) return;

    debugPrint('üîÑ [AUTO REFRESH] Current screen: $_selectedItem');

    // Always refresh dashboard data and financial summary for dashboard card
    _loadDashboardData();
    _loadUserFinancialSummary();

    // Refresh based on current screen
    switch (_selectedItem) {
      case NavItem.dashboard:
        // Dashboard already refreshed above
        break;

      case NavItem.walletOverview:
        // All Wallet Report
        _loadFinancialData(forceRefresh: forceRefresh, isSelfWallet: false);
        break;

      case NavItem.walletSelf:
        // Self Wallet
        _loadFinancialData(forceRefresh: forceRefresh, isSelfWallet: true);
        break;

      case NavItem.walletAll:
        // All User Wallets
        _loadFinancialData(forceRefresh: forceRefresh, isSelfWallet: false);
        break;

      case NavItem.accountReports:
        // Account Reports
        _loadFinancialData(forceRefresh: forceRefresh, isSelfWallet: false);
        break;

      case NavItem.expenseReport:
        // Expense Report
        _loadFinancialData(forceRefresh: forceRefresh, isSelfWallet: false);
        break;

      case NavItem.expenseType:
        // Expense Types
        _loadExpenseTypes();
        break;

      case NavItem.users:
        // Users - reload users list
        _loadAllUsers();
        break;

      case NavItem.roles:
        // Roles - reload roles (screen will handle its own refresh via socket)
        // Note: RolesScreen has its own socket listeners, but we ensure data is fresh
        break;

      case NavItem.paymentModes:
        // Payment Modes - reload payment modes
        _loadPaymentModes();
        break;

      case NavItem.collectionCustomField:
        // Collection Custom Fields
        _collectionCustomFieldRefreshKey.currentState?.refresh();
        break;

      case NavItem.smartApprovals:
        // Smart Approvals (Pending Approvals)
        _pendingApprovalsRefreshKey.currentState?.refresh();
        break;

      default:
        // Other screens - no specific refresh needed
        break;
    }
  }

  /// Auto-refresh method with debouncing to prevent excessive API calls
  /// This method ensures dashboard data is refreshed when changes occur
  // Auto-refresh functions removed - refresh only occurs on socket events (when changes happen)

  Future<void> _loadActionButtonSettings() async {
    if (_isLoadingActionButtons) return;

    final bool isAuthenticated = await AuthService.isAuthenticated();
    if (!isAuthenticated) {
      if (mounted) {
        setState(() {
          _actionButtonSettings =
              Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
        });
      }
      return;
    }

    // Check if user is SuperAdmin - only SuperAdmin can access action button settings
    final userRole = await AuthService.getUserRole();
    if (userRole != 'SuperAdmin') {
      // Non-SuperAdmin users should use default settings silently
      if (mounted) {
        setState(() {
          _actionButtonSettings =
              Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
        });
      }
      return;
    }

    setState(() {
      _isLoadingActionButtons = true;
    });

    try {
      final settings = await SettingsService.fetchActionButtonSettings();
      if (!mounted) return;
      // If settings is empty (authorization error), use defaults
      if (settings.isEmpty) {
        setState(() {
          _actionButtonSettings =
              Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
        });
      } else {
        setState(() {
          _actionButtonSettings = _mergeActionButtonSettings(settings);
        });
      }
    } catch (error) {
      // Silently use default settings on error (authorization or other errors)
      // Only log if it's not an authorization error
      final errorString = error.toString();
      if (!errorString.contains('not authorized') && 
          !errorString.contains('authorized to access')) {
        if (mounted) {
          debugPrint('Failed to load action button settings: $error');
        }
      }
      if (mounted) {
        setState(() {
          _actionButtonSettings =
              Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoadingActionButtons = false;
        });
      }
    }
  }

  Future<void> _loadAllUsers() async {
    if (_isLoadingUsers) return;

    setState(() {
      _isLoadingUsers = true;
    });

    try {
      final result = await UserService.getUsers();
      if (!mounted) {
        return;
      }

      List<Map<String, String>> resolvedOptions =
          _userOptions.map((option) => Map<String, String>.from(option)).toList();

      if (result['success'] == true) {
        final List<dynamic> usersRaw = result['users'] as List<dynamic>? ?? [];
        final Map<String, Map<String, String>> unique = {};

        for (final user in usersRaw) {
          if (user is Map) {
            final userMap = Map<String, dynamic>.from(user as Map);
            if (!_isUserActive(userMap)) {
              continue;
            }
            final String? id = _extractUserId(userMap);
            final String label = _extractUserLabel(userMap);
            final String? role = _extractUserRole(userMap);
            if (id != null && id.isNotEmpty && label.isNotEmpty) {
              unique[id] = {
                'id': id,
                'label': _composeUserOptionLabel(label, role),
                if (role != null && role.isNotEmpty) 'role': role,
              };
            }
          }
        }

        resolvedOptions = unique.values
            .map((entry) => Map<String, String>.from(entry))
            .toList();
        resolvedOptions.sort(
          (a, b) => (a['label'] ?? '').compareTo(b['label'] ?? ''),
        );
      }

      setState(() {
        if (result['success'] == true) {
          _userOptions = resolvedOptions;
        }
        _isLoadingUsers = false;
      });
      _syncSelectedUserLabels();
    } catch (_) {
      if (!mounted) {
        return;
      }
      setState(() {
        _isLoadingUsers = false;
      });
    }
  }

  Future<void> _loadPaymentModes({String? displayType}) async {
    if (_isLoadingPaymentModes) return;

    setState(() {
      _isLoadingPaymentModes = true;
    });

    try {
      print('üîç [SuperAdminDashboard] _loadPaymentModes called with displayType: $displayType');
      final result = await PaymentModeService.getPaymentModes(displayType: displayType);
      if (!mounted) {
        return;
      }

      setState(() {
        if (result['success'] == true) {
          final List<dynamic> paymentModesRaw = result['paymentModes'] as List<dynamic>? ?? [];
          _paymentModes = paymentModesRaw
              .map((mode) => Map<String, dynamic>.from(mode as Map))
              .where((mode) => mode['isActive'] != false)
              .toList();
          debugPrint('Loaded ${_paymentModes.length} payment modes');
          for (var mode in _paymentModes) {
            debugPrint('Payment mode: ${mode['modeName']}');
          }
        } else {
          debugPrint('Failed to load payment modes: ${result['message']}');
        }
        _isLoadingPaymentModes = false;
        _paymentModesLoadedNotifier.value = !_paymentModesLoadedNotifier.value;
      });
    } catch (_) {
      if (!mounted) {
        return;
      }
      setState(() {
        _isLoadingPaymentModes = false;
        _paymentModesLoadedNotifier.value = !_paymentModesLoadedNotifier.value;
      });
    }
  }

  // Helper function to detect mode type from modeName for icon display
  IconData _getPaymentModeIcon(String modeName) {
    final lowerName = modeName.toLowerCase();
    if (lowerName.contains('cash')) {
      return Icons.money;
    } else if (lowerName.contains('upi')) {
      return Icons.qr_code;
    } else if (lowerName.contains('bank')) {
      return Icons.account_balance;
    }
    return Icons.payment;
  }

  Future<void> _loadExpenseTypes() async {
    try {
      final result = await ExpenseTypeService.getActiveExpenseTypes();
      
      if (result['success'] == true && mounted) {
        final expenseTypes = result['expenseTypes'] as List<dynamic>? ?? [];
        setState(() {
          // Remove duplicates and ensure unique categories
          _expenseCategories = expenseTypes
              .map((et) => et['name']?.toString() ?? '')
              .where((name) => name.isNotEmpty)
              .toSet()
              .toList();
          
          // Store full expense type objects with images and proof requirement
          _expenseTypesWithImages = expenseTypes
              .map((et) => <String, dynamic>{
                    'name': et['name']?.toString() ?? '',
                    'imageUrl': et['imageUrl']?.toString(),
                    'proofRequired': et['proofRequired'] == true || et['isProofRequired'] == true,
                  })
              .where((et) => (et['name'] as String).isNotEmpty)
              .toList();
          
          // If no types from API, keep default list
          if (_expenseCategories.isEmpty) {
            _expenseCategories = ['Office', 'Travel', 'Marketing', 'Maintenance', 'Misc'];
            _expenseTypesWithImages = _expenseCategories.map((name) => <String, dynamic>{
              'name': name,
              'imageUrl': null,
              'proofRequired': false, // Default to optional for fallback categories
            }).toList();
          }
          
          // Update selected category if it's not in the list anymore
          if (!_expenseCategories.contains(_selectedExpenseCategory) && _expenseCategories.isNotEmpty) {
            _selectedExpenseCategory = _expenseCategories.first;
          }
        });
      }
    } catch (e) {
      // Keep default categories on error
      if (mounted) {
        setState(() {
          _expenseCategories = ['Office', 'Travel', 'Marketing', 'Maintenance', 'Misc'];
          _expenseTypesWithImages = _expenseCategories.map((name) => <String, dynamic>{
            'name': name,
            'imageUrl': null,
            'proofRequired': false, // Default to optional for fallback categories
          }).toList();
        });
      }
    }
  }

  /// Check if proof is required for the selected expense type
  bool _isProofRequiredForSelectedType() {
    if (_selectedExpenseTypeForDialog == null) {
      return false;
    }
    return _selectedExpenseTypeForDialog!['proofRequired'] == true;
  }

  String? _extractUserId(Map<String, dynamic> user) {
    for (final key in ['_id', 'id', 'userId', 'user_id']) {
      final value = user[key];
      if (value != null && value.toString().isNotEmpty) {
        return value.toString();
      }
    }
    return null;
  }

  String _labelOnlyKey(String label) => '__label__$label';

  String _extractUserLabel(Map<String, dynamic> user) {
    for (final key in ['name', 'username', 'email', 'mobile', 'phone']) {
      final value = user[key];
      if (value != null && value.toString().isNotEmpty) {
        return value.toString();
      }
    }
    return 'Unknown User';
  }

  String? _extractUserRole(Map<String, dynamic> user) {
    for (final key in ['role', 'userRole', 'user_role', 'designation', 'department']) {
      final value = user[key];
      if (value != null && value.toString().isNotEmpty) {
        return value.toString();
      }
    }
    return null;
  }

  bool _isUserActive(Map<String, dynamic> user) {
    final dynamic statusValue = user['status'];
    if (statusValue is String && statusValue.trim().isNotEmpty) {
      final normalized = _normalizeStatusKey(statusValue);
      if (normalized == 'active') {
        return true;
      }
      if (normalized == 'inactive') {
        return false;
      }
    }

    final dynamic isVerified = user['isVerified'];
    if (isVerified is bool) {
      return isVerified;
    }
    if (isVerified is String && isVerified.trim().isNotEmpty) {
      final normalized = _normalizeStatusKey(isVerified);
      if (normalized.isNotEmpty) {
        return normalized == 'active';
      }
    }

    for (final key in ['isActive', 'active', 'enabled']) {
      final dynamic value = user[key];
      if (value is bool) {
        return value;
      }
      if (value is String && value.trim().isNotEmpty) {
        final normalized = _normalizeStatusKey(value);
        if (normalized.isNotEmpty) {
          return normalized == 'active';
        }
      }
    }

    return true;
  }

  String _composeUserOptionLabel(String name, String? role) {
    final trimmedName = name.trim();
    final trimmedRole = role?.trim() ?? '';
    if (trimmedRole.isNotEmpty) {
      return '$trimmedRole - $trimmedName';
    }
    return trimmedName;
  }

  void _syncSelectedUserLabels() {
    final filterProvider = _filterProvider;
    if (filterProvider.selectedUserIds.isEmpty && filterProvider.selectedUserDisplayLabels.isEmpty) {
      return;
    }

    final Map<String, String> idToLabel = {
      for (final option in _userOptions)
        if ((option['id'] ?? '').isNotEmpty)
          option['id']!: (option['label'] ?? option['id']!)
    };

    for (final id in filterProvider.selectedUserIds) {
      final String? resolvedLabel = idToLabel[id];
      if (resolvedLabel != null && resolvedLabel.isNotEmpty) {
        filterProvider.addUser(id, label: resolvedLabel);
        _selectedUserLabelMatchers.add(resolvedLabel.toLowerCase());
      } else if (!filterProvider.selectedUserDisplayLabels.containsKey(id)) {
        filterProvider.addUser(id, label: id);
      }
    }

    final List<String> staleKeys = [];
    filterProvider.selectedUserDisplayLabels.forEach((key, _) {
      if (!filterProvider.selectedUserIds.contains(key) && !key.startsWith('__label__')) {
        staleKeys.add(key);
      }
    });
    for (final key in staleKeys) {
      filterProvider.removeUser(key);
    }
  }

  bool _doesItemMatchSelectedUser(dynamic item) {
    final filterProvider = _filterProvider;
    final bool hasUserIds = filterProvider.selectedUserIds.isNotEmpty;
    final bool hasUserLabels = _selectedUserLabelMatchers.isNotEmpty;

    if (!hasUserIds && !hasUserLabels) {
      return true;
    }

    bool matches(
      dynamic value, {
      int depth = 0,
      Set<int>? visited,
    }) {
      if (depth > 10) {
        return false;
      }

      if (value == null) {
        return false;
      }
      if (value is Map) {
        visited ??= <int>{};
        final mapIdentity = identityHashCode(value);
        if (!visited.add(mapIdentity)) {
          return false;
        }
        final result = matches(
                  value['_id'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['id'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['userId'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['user_id'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['name'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['username'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['email'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['mobile'],
                  depth: depth + 1,
                  visited: visited,
                ) ||
                matches(
                  value['phone'],
                  depth: depth + 1,
                  visited: visited,
                );
        visited.remove(mapIdentity);
        return result;
      }
      if (value is Iterable) {
        int index = 0;
        for (final entry in value) {
          if (index++ > 100) {
            break;
          }
          if (matches(
            entry,
            depth: depth + 1,
            visited: visited,
          )) {
            return true;
          }
        }
        return false;
      }
      final String text = value.toString();
      final filterProvider = _filterProvider;
      if (hasUserIds && filterProvider.selectedUserIds.contains(text)) {
        return true;
      }
      if (hasUserLabels && _selectedUserLabelMatchers.contains(text.toLowerCase())) {
        return true;
      }
      return false;
    }

    return matches(item['userId']) ||
        matches(item['createdBy']) ||
        matches(item['created_by']) ||
        matches(item['sender']) ||
        matches(item['receiver']) ||
        matches(item['collectedBy']) ||
        matches(item['assignedReceiver']) ||
        matches(item['user']) ||
        matches(item['from']) ||
        matches(item['to']);
  }

  Map<String, ActionButtonSetting> _mergeActionButtonSettings(Iterable<ActionButtonSetting> settings) {
    final merged = Map<String, ActionButtonSetting>.from(_defaultActionButtonSettings);
    for (final setting in settings) {
      if (_defaultActionButtonSettings.containsKey(setting.key)) {
        merged[setting.key] = setting;
      }
    }
    return merged;
  }

  ActionButtonSetting _getActionButtonSetting(String key) {
    return _actionButtonSettings[key] ?? _defaultActionButtonSettings[key] ??
        const ActionButtonSetting(key: 'unknown', showButton: true, enablePopup: false);
  }

  bool _isActionButtonVisible(String key) {
    return _getActionButtonSetting(key).showButton;
  }

  bool _isActionButtonPopupEnabled(String key) {
    return _getActionButtonSetting(key).enablePopup;
  }

  Future<void> _handleConfiguredAction({
    required String key,
    required String label,
    required Color color,
    required Future<void> Function() action,
    Future<void> Function(String reason)? actionWithReason,
  }) async {
    if (!_isActionButtonVisible(key)) {
      return;
    }

    bool proceed = true;
    String? reason;
    final bool needsReason = actionWithReason != null;

    // Only show confirmation dialog if a reason is explicitly required (for reject/flag actions)
    // This matches Smart Approvals behavior: approve, unapprove, edit, delete execute directly
    if (needsReason) {
      final dialogResult = await _showActionConfirmationDialog(
        key: key,
        label: label,
        color: color,
        requireReason: needsReason,
      );

      if (dialogResult == null) {
        proceed = false;
      } else {
        proceed = dialogResult['proceed'] as bool? ?? false;
        reason = dialogResult['reason'] as String?;
      }
    }

    if (!proceed) return;

    if (needsReason && reason != null && actionWithReason != null) {
      await actionWithReason(reason);
    } else {
      await action();
    }
  }

  Future<Map<String, dynamic>?> _showActionConfirmationDialog({
    required String key,
    required String label,
    required Color color,
    bool requireReason = false,
  }) async {
    final message = _actionConfirmationMessages[key] ?? label.toLowerCase();
    final description = message.isEmpty ? label.toLowerCase() : message;
    final TextEditingController reasonController = TextEditingController();

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (dialogContext) {
        void submit() {
          if (requireReason && reasonController.text.trim().isEmpty) {
            ScaffoldMessenger.of(this.context).showSnackBar(
              const SnackBar(content: Text('Reason is required')),
            );
            return;
          }
          Navigator.of(dialogContext).pop({
            'proceed': true,
            'reason': requireReason ? reasonController.text.trim() : null,
          });
        }

        return Shortcuts(
          shortcuts: const <ShortcutActivator, Intent>{
            SingleActivator(LogicalKeyboardKey.enter): ActivateIntent(),
            SingleActivator(LogicalKeyboardKey.numpadEnter): ActivateIntent(),
          },
          child: Actions(
            actions: <Type, Action<Intent>>{
              ActivateIntent: CallbackAction<ActivateIntent>(
                onInvoke: (intent) {
                  submit();
                  return null;
                },
              ),
            },
            child: FocusTraversalGroup(
              child: FocusScope(
                autofocus: true,
                child: AlertDialog(
                  backgroundColor: Colors.white,
                  title: Text('$label Confirmation'),
                  content: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text('Are you sure you want to $description?'),
                      if (requireReason) ...[
                        const SizedBox(height: 16),
                        TextField(
                          controller: reasonController,
                          autofocus: true,
                          maxLines: 3,
                          decoration: const InputDecoration(
                            labelText: 'Reason',
                            hintText: 'Provide a reason',
                            border: OutlineInputBorder(),
                          ),
                        ),
                      ],
                    ],
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(dialogContext).pop({
                        'proceed': false,
                        'reason': null,
                      }),
                      child: const Text('Cancel'),
                    ),
                    FilledButton(
                      onPressed: submit,
                      style: FilledButton.styleFrom(
                        backgroundColor: color,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('Confirm'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );

    reasonController.dispose();

    return result;
  }

  // Helper: Extract payment mode ID from an item
  String? _extractPaymentModeId(dynamic item) {
    if (item == null) return null;
    
    // Try paymentModeId first (direct field)
    final paymentModeId = item['paymentModeId'];
    if (paymentModeId != null) {
      // If paymentModeId is a Map/object, extract _id from it
      if (paymentModeId is Map) {
        final modeId = paymentModeId['_id'] ?? paymentModeId['id'];
        if (modeId != null && modeId.toString().trim().isNotEmpty) {
          return modeId.toString().trim();
        }
      } else if (paymentModeId.toString().trim().isNotEmpty) {
        // If it's already a string, use it directly
      return paymentModeId.toString().trim();
      }
    }
    
    // Try accountId field (some items use this instead of paymentModeId)
    final accountId = item['accountId'];
    if (accountId != null && accountId.toString().trim().isNotEmpty) {
      return accountId.toString().trim();
        }
        
    // Try nested paymentMode object
        final paymentMode = item['paymentMode'];
        if (paymentMode != null) {
          if (paymentMode is Map) {
        // Try _id first, then id
        final modeId = paymentMode['_id'] ?? paymentMode['id'];
        if (modeId != null && modeId.toString().trim().isNotEmpty) {
          return modeId.toString().trim();
        }
      } else if (paymentMode is String && paymentMode.trim().isNotEmpty) {
        return paymentMode.trim();
      }
    }
    
    // Try mode field (some items store payment mode ID in mode field)
    final mode = item['mode'];
    if (mode != null) {
      if (mode is Map) {
        final modeId = mode['_id'] ?? mode['id'];
        if (modeId != null && modeId.toString().trim().isNotEmpty) {
          return modeId.toString().trim();
        }
      } else if (mode is String && mode.trim().isNotEmpty) {
        // Check if mode is an ID (ObjectId format) or a name
        // If it looks like an ObjectId (24 hex characters), treat it as ID
        final modeStr = mode.trim();
        if (modeStr.length == 24 && RegExp(r'^[0-9a-fA-F]{24}$').hasMatch(modeStr)) {
          return modeStr;
        }
      }
    }
    
    return null;
  }

  // Helper: Extract payment mode name from an item
  String? _extractPaymentModeName(dynamic item) {
    if (item == null) return null;
    
    // Try nested paymentMode object first
    final paymentMode = item['paymentMode'];
    if (paymentMode != null && paymentMode is Map) {
      final modeName = paymentMode['modeName'] ?? paymentMode['name'] ?? paymentMode['displayName'];
      if (modeName != null && modeName.toString().trim().isNotEmpty) {
        return modeName.toString().trim();
      }
    }
    
    // Fallback: check mode field
    final mode = item['mode'];
    if (mode != null) {
      if (mode is Map) {
        // If mode is an object, extract name
        final modeName = mode['modeName'] ?? mode['name'] ?? mode['displayName'];
        if (modeName != null && modeName.toString().trim().isNotEmpty) {
          return modeName.toString().trim();
        }
      } else if (mode is String && mode.trim().isNotEmpty) {
        // If mode is a string, check if it's a name (not an ID)
        final modeStr = mode.trim();
        // If it doesn't look like an ObjectId, treat it as a name
        if (modeStr.length != 24 || !RegExp(r'^[0-9a-fA-F]{24}$').hasMatch(modeStr)) {
          return modeStr;
        }
      }
    }
    
    return null;
  }

  // Helper: Check if expense/item is approved (including Flagged with approvedBy)
  bool _isItemApproved(dynamic item) {
    final status = item['status']?.toString() ?? '';
    final statusLower = status.toLowerCase(); // Normalize to lowercase for case-insensitive comparison
    final approvedBy = item['approvedBy'];
    final type = item['type']?.toString() ?? '';
    
    // For Expenses and Transactions: Check if explicitly approved (case-insensitive)
    if (type == 'Expenses' || type == 'Transactions') {
      if (statusLower == 'approved' || statusLower == 'completed') {
        return true;
      }
      // Check if Flagged but has approvedBy (approved Flagged item)
      if (statusLower == 'flagged' && approvedBy != null) {
        // Check if approvedBy is not empty (could be object or string)
        if (approvedBy is Map && approvedBy.isNotEmpty) {
          return true;
        } else if (approvedBy is String && approvedBy.isNotEmpty) {
          return true;
        } else if (approvedBy != null) {
          return true;
        }
      }
    } else if (type == 'Collections') {
      // For Collections: Check if verified/accounted/approved (case-insensitive)
      if (statusLower == 'verified' || statusLower == 'accounted' || statusLower == 'approved') {
        return true;
      }
      // Check if Flagged but has approvedBy (approved Flagged collection)
      if (statusLower == 'flagged' && approvedBy != null) {
        if (approvedBy is Map && approvedBy.isNotEmpty) {
          return true;
        } else if (approvedBy is String && approvedBy.isNotEmpty) {
          return true;
        } else if (approvedBy != null) {
          return true;
        }
      }
    }
    
    return false;
  }

  // Helper: Check if item matches selected account
  bool _doesItemMatchSelectedAccount(dynamic item) {
    if (_selectedAccountFilterId == null || _selectedAccountFilterId!.isEmpty) {
      return true; // No filter applied, show all
    }
    
    final selectedAccountId = _selectedAccountFilterId!;
    
    // For wallet transactions (Add Amount/Withdraw), check accountId in notes
    final itemType = item['type']?.toString() ?? '';
    if (itemType == 'Add Amount' || itemType == 'Withdraw' || itemType == 'WalletTransactions') {
      final notes = item['notes']?.toString() ?? '';
      final accountId = item['accountId']?.toString() ?? '';
      
      // Check if notes contains accountId (format: "mode: accountId" or "accountId: ...")
      if (notes.isNotEmpty) {
        // Check for "mode: accountId" pattern
        final modePattern = RegExp(r'mode[:\s]+([^\s,]+)', caseSensitive: false);
        final match = modePattern.firstMatch(notes);
        if (match != null) {
          final noteAccountId = match.group(1)?.trim();
          if (noteAccountId != null && noteAccountId == selectedAccountId) {
            debugPrint('   ‚úÖ [ACCOUNT MATCH] WalletTransaction matched by notes mode: $noteAccountId');
        return true;
      }
        }
        // Also check if notes directly contains the accountId
        if (notes.contains(selectedAccountId)) {
          debugPrint('   ‚úÖ [ACCOUNT MATCH] WalletTransaction matched by notes containing accountId');
          return true;
        }
      }
      // Check direct accountId field
      if (accountId.isNotEmpty && accountId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] WalletTransaction matched by accountId: $accountId');
        return true;
      }
      debugPrint('   ‚ùå [ACCOUNT MATCH] WalletTransaction does not match account filter');
      return false; // Wallet transactions must match by accountId
    }
    
    // Try ID matching first (most reliable) - for collections, expenses, and transactions
    final paymentModeId = _extractPaymentModeId(item);
    if (paymentModeId != null && paymentModeId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Item matched by paymentModeId: $paymentModeId');
      return true;
    }
    
      // Also check direct accountId field (but extract ID if it's an object)
      final accountIdField = item['accountId'];
      String? directAccountId;
      if (accountIdField != null) {
        if (accountIdField is Map) {
          directAccountId = (accountIdField['_id'] ?? accountIdField['id'])?.toString();
        } else {
          directAccountId = accountIdField.toString();
        }
      }
      if (directAccountId != null && directAccountId.isNotEmpty && directAccountId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Item matched by accountId: $directAccountId');
      return true;
    }
    
    // For Account Reports: If backend already filtered by accountId, we can trust it to some extent
    // However, we should still do client-side matching for accuracy
    // Only trust backend if we absolutely cannot find any payment mode info in the item
    // This is a fallback for edge cases where item structure is unexpected
    if (_selectedItem == NavItem.accountReports && 
        _selectedAccountFilterId != null && 
        _selectedAccountFilterId!.isNotEmpty) {
      // If we have no way to match the item client-side, and backend filtered it,
      // we can include it as a last resort
      // But prefer client-side matching when possible
      if (paymentModeId == null && directAccountId == null) {
        // Check if we can extract payment mode name - if yes, try name matching first
        final paymentModeName = _extractPaymentModeName(item);
        if (paymentModeName == null || paymentModeName.isEmpty) {
          // No payment mode info at all - trust backend filtering as last resort
          debugPrint('   ‚ö†Ô∏è  [ACCOUNT MATCH] No payment mode info found - trusting backend filter');
        return true;
        }
      }
    }
    
    // For expenses, check accountId/paymentModeId fields
    if (itemType == 'Expenses') {
      // First check direct ID matching
      final accountId = item['accountId']?.toString() ?? item['paymentModeId']?.toString();
      if (accountId != null && accountId.isNotEmpty && accountId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Expense matched by accountId/paymentModeId: $accountId');
        return true;
      }
      
      // NO NAME MATCHING for expenses - Only ID matching
      // Expenses should have paymentModeId or accountId field for account filtering
      
      // If no match found, exclude the expense
      debugPrint('   ‚ùå [ACCOUNT MATCH] Expense does not match account filter');
      return false;
    }
    
    // For transactions, check if they have payment mode information
    if (itemType == 'Transactions') {
      // First check if transaction has payment mode ID
      final transactionPaymentModeId = _extractPaymentModeId(item);
      if (transactionPaymentModeId != null && transactionPaymentModeId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Transaction matched by paymentModeId: $transactionPaymentModeId');
        return true;
      }
      
      // Check direct accountId field
      final transactionAccountId = item['accountId']?.toString();
      if (transactionAccountId != null && transactionAccountId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Transaction matched by accountId: $transactionAccountId');
        return true;
      }
      
      // NO NAME MATCHING for transactions - Only ID matching
      // Transactions should have paymentModeId or accountId field for account filtering
      
      // If transaction has no payment mode info, exclude it when filtering by account
      // (Transactions without payment mode are typically wallet-to-wallet transfers)
      debugPrint('   ‚ùå [ACCOUNT MATCH] Transaction does not match account filter (no payment mode info)');
      return false;
    }
    
    // For collections, ONLY use ID matching - NO name matching to avoid false matches
    if (itemType == 'Collections') {
      // Try ID matching (already checked above, but double-check for collections)
      final collectionPaymentModeId = _extractPaymentModeId(item);
      if (collectionPaymentModeId != null && collectionPaymentModeId == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Collection matched by paymentModeId: $collectionPaymentModeId');
        return true;
      }
      
      // Also check if accountId field matches (extract ID if it's an object)
      final accountIdField = item['accountId'];
      String? accountIdFromField;
      if (accountIdField != null) {
        if (accountIdField is Map) {
          accountIdFromField = (accountIdField['_id'] ?? accountIdField['id'])?.toString();
        } else {
          accountIdFromField = accountIdField.toString();
        }
      }
      if (accountIdFromField != null && accountIdFromField.isNotEmpty && accountIdFromField == selectedAccountId) {
        debugPrint('   ‚úÖ [ACCOUNT MATCH] Collection matched by accountId field: $accountIdFromField');
              return true;
      }
      
      // NO NAME MATCHING - Only ID matching to ensure accuracy
      // Backend already filtered by accountId, so if ID doesn't match, exclude it
      debugPrint('   ‚ùå [ACCOUNT MATCH] Collection does not match account filter');
      debugPrint('     Collection paymentModeId: $collectionPaymentModeId');
      debugPrint('     Collection accountId field: $accountIdFromField');
      debugPrint('     Selected accountId: $selectedAccountId');
      return false;
    }
        
    // If item type is not recognized or doesn't match, exclude it
    debugPrint('   ‚ùå [ACCOUNT MATCH] Item type "$itemType" does not match account filter');
    return false;
  }

  void _calculateFinancialSummary({List<dynamic>? data}) async {
    // Skip calculation for Self Wallet - API already provides correct values
    // Self wallet should never use account filtering logic
    if (_selectedItem == NavItem.walletSelf) {
      debugPrint('[SELF WALLET] ‚è≠Ô∏è Skipping _calculateFinancialSummary() - Using API values');
      debugPrint('[SELF WALLET] ‚è≠Ô∏è Current UI values: _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
      return;
    }
    
    List<dynamic> source = data ?? _allData;
    
    // Note: Account filtering only applies to Account Reports, not Self Wallet
    // If data comes from backend API with accountId filter, it's already filtered
    // Only apply client-side filter if data wasn't from API or for additional filtering
    // The backend API now handles account filtering, so this is mainly for fallback
    if (_selectedItem == NavItem.accountReports && 
        _selectedAccountFilterId != null && 
        _selectedAccountFilterId!.isNotEmpty &&
        data == null) { // Only filter if using _allData (not pre-filtered data)
      source = source.where((item) => _doesItemMatchSelectedAccount(item)).toList();
    }
    
    // For Expense Report Mode: Only calculate from expenses
    if (_isExpenseReportMode) {
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      debugPrint('üí∞ [EXPENSE REPORT] _calculateFinancialSummary() - START');
      debugPrint('   Source data count: ${source.length}');
      debugPrint('   _selectedItem: $_selectedItem');
      debugPrint('   _isExpenseReportMode: $_isExpenseReportMode');
      
      // Filter to only expenses
      source = source.where((item) => item['type']?.toString() == 'Expenses').toList();
      debugPrint('   After filtering to Expenses: ${source.length} items');
      
      double cashIn = 0.0; // Reimbursements (if any)
      double cashOut = 0.0; // Expenses are money going out
      
      // Get current user ID for self wallet calculations
      String? currentUserId;
      if (_selectedItem == NavItem.walletSelf) {
        currentUserId = await AuthService.getUserId();
        debugPrint('   Current User ID: $currentUserId');
      }
      
      debugPrint('   Processing ${source.length} expense items...');
      int approvedCount = 0;
      int unapprovedCount = 0;
      
      // Calculate only from approved expenses (including Flagged with approvedBy)
      for (var item in source) {
        final amount = _parseAmount(item['amount']);
        final status = item['status']?.toString() ?? 'Unknown';
        final statusLower = status.toLowerCase();
        final isApproved = _isItemApproved(item);
        
        debugPrint('   Item: amount=$amount, status=$status (lowercase: $statusLower), isApproved=$isApproved');
        
        if (isApproved) {
          approvedCount++;
          // In expense report: Approved expenses = Cash Out (money spent/paid)
          // For self wallet, only count expenses where user is owner
          if (_selectedItem == NavItem.walletSelf && currentUserId != null) {
            final expenseUserId = item['userId'] is Map
                ? (item['userId']?['_id'] ?? item['userId']?['id'] ?? '').toString()
                : (item['userId'] ?? '').toString();
            debugPrint('     Expense User ID: $expenseUserId, Current User ID: $currentUserId');
            if (expenseUserId == currentUserId) {
              cashOut += amount; // Expense owner paid money (Cash Out)
              debugPrint('     ‚úÖ Added to cashOut: $amount (new total: $cashOut)');
            } else {
              debugPrint('     ‚è≠Ô∏è Skipped - expense belongs to different user');
            }
          } else {
            // For all accounts view, count all approved expenses as cash out (money spent)
            cashOut += amount;
            debugPrint('     ‚úÖ Added to cashOut: $amount (new total: $cashOut)');
          }
        } else {
          unapprovedCount++;
          debugPrint('     ‚è≠Ô∏è Skipped - expense not approved');
          }
        }
      
      debugPrint('   Summary:');
      debugPrint('     Total items: ${source.length}');
      debugPrint('     Approved: $approvedCount');
      debugPrint('     Unapproved: $unapprovedCount');
      debugPrint('     Cash In: $cashIn');
      debugPrint('     Cash Out: $cashOut');
      
      // Balance = Cash In - Cash Out (for expense report, typically negative or zero)
      final balance = cashIn - cashOut;
      debugPrint('     Balance: $balance (Cash In - Cash Out)');
      
      debugPrint('   üí∞ [EXPENSE REPORT] BEFORE setState in _calculateFinancialSummary:');
      debugPrint('      _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
      debugPrint('      _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
      debugPrint('      Calculated values: cashIn=$cashIn, cashOut=$cashOut, balance=$balance');
      
      if (mounted) {
        setState(() {
          _cashIn = cashIn;
          _cashOut = cashOut;
          _balance = balance;
          // Also update _user* variables for expense report display (UI uses these)
          _userCashIn = cashIn;
          _userCashOut = cashOut;
          _userBalance = balance;
        });
        debugPrint('   üí∞ [EXPENSE REPORT] AFTER setState in _calculateFinancialSummary:');
        debugPrint('      _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
        debugPrint('      _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
      } else {
        debugPrint('   ‚ö†Ô∏è Widget not mounted, skipping setState');
      }
      
      debugPrint('üí∞ [EXPENSE REPORT] _calculateFinancialSummary() - END');
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return;
    }
    
    // Original logic for non-expense report mode
    double cashIn = 0.0;
    double cashOut = 0.0;
    
    // Get current user ID for self wallet calculations
    String? currentUserId;
    if (_selectedItem == NavItem.walletSelf) {
      currentUserId = await AuthService.getUserId();
    }
    
    for (var item in source) {
      final type = item['type']?.toString() ?? '';
      final statusValue = item['status']?.toString() ?? '';
      final normalizedStatus = _normalizeStatusKey(statusValue);
      final amount = _parseAmount(item['amount']);

      // Handle Add Amount (wallet transactions)
      if (type == 'Add Amount') {
        cashIn += amount;
      }
      // Handle Withdraw (wallet transactions)
      else if (type == 'Withdraw') {
        cashOut += amount;
      }
      // Handle Collections
      else if (type == 'Collections') {
        if (normalizedStatus == 'accounted' || normalizedStatus == 'approved') {
          // For self wallet, only count collections where user is assigned receiver
          if (_selectedItem == NavItem.walletSelf && currentUserId != null) {
            final assignedReceiverId = item['assignedReceiver'] is Map
                ? (item['assignedReceiver']?['_id'] ?? item['assignedReceiver']?['id'] ?? '').toString()
                : (item['assignedReceiver'] ?? '').toString();
            if (assignedReceiverId == currentUserId) {
              cashIn += amount;
            }
          } else {
            // For all accounts view, count all approved collections
            cashIn += amount;
          }
        }
      }
      // Handle Expenses
      else if (type == 'Expenses') {
        // With new backend logic: Approver pays Expense Owner (reimbursement)
        // - Expense owner: Approved expense = Cash In (reimbursement received)
        // - Approver: Approved expense = Cash Out (payment made)
        if (_isItemApproved(item)) {
          // Get expense owner ID
          final expenseUserId = item['userId'] is Map
              ? (item['userId']?['_id'] ?? item['userId']?['id'] ?? '').toString()
              : (item['userId'] ?? '').toString();
          
          // Get approver ID
          final approvedByValue = item['approvedBy'];
          String? approverId;
          if (approvedByValue != null) {
            if (approvedByValue is Map) {
              approverId = (approvedByValue['_id'] ?? approvedByValue['id'] ?? '').toString();
            } else if (approvedByValue is String) {
              approverId = approvedByValue;
            } else {
              approverId = approvedByValue.toString();
            }
          }
          
          // Calculate based on user's role (owner or approver)
          // For self wallet: currentUserId is already set
          // For all accounts view: We need to check if current user is owner or approver
          if (currentUserId != null) {
            if (expenseUserId == currentUserId) {
              // Current user is expense owner: Cash In (reimbursement received)
              cashIn += amount;
            } else if (approverId != null && approverId == currentUserId) {
              // Current user is approver: Cash Out (payment made)
              cashOut += amount;
            }
          } else {
            // If we can't determine current user, try to get it
            // This might happen in some edge cases
            try {
              final userId = await AuthService.getUserId();
              if (expenseUserId == userId) {
                cashIn += amount;
              } else if (approverId != null && approverId == userId) {
                cashOut += amount;
              }
            } catch (e) {
              // If we still can't get user ID, default to expense owner logic (Cash In)
              // This maintains backward compatibility
              cashIn += amount;
            }
          }
        }
      }
      // Handle Transactions - check if user is sender or receiver
      else if (type == 'Transactions') {
        if (normalizedStatus == 'approved' || normalizedStatus == 'completed') {
          // For self wallet, calculate based on user role (sender or receiver)
          if (_selectedItem == NavItem.walletSelf && currentUserId != null) {
            final senderId = item['sender'] is Map
                ? (item['sender']?['_id'] ?? item['sender']?['id'] ?? '').toString()
                : (item['sender'] ?? '').toString();
            final receiverId = item['receiver'] is Map
                ? (item['receiver']?['_id'] ?? item['receiver']?['id'] ?? '').toString()
                : (item['receiver'] ?? '').toString();
            
            if (senderId == currentUserId) {
              cashOut += amount; // User sent money
            }
            if (receiverId == currentUserId) {
              cashIn += amount; // User received money
            }
          }
          // For all accounts view, transactions don't affect cash in/out directly
        }
      }
    }

    // Calculate balance based on context
    double balance;
    if (_selectedItem == NavItem.accountReports && 
        _selectedAccountFilterId != null && 
        _selectedAccountFilterId!.isNotEmpty) {
      // For Account Reports with selected account: Calculate balance from filtered cash in/out
      balance = cashIn - cashOut;
    } else {
      // For other views: Use wallet total balance from API
      balance = _wallet?['totalBalance']?.toDouble() ?? (cashIn - cashOut);
    }

    if (mounted) {
      setState(() {
        _cashIn = cashIn;
        _cashOut = cashOut;
        _balance = balance;
      });
    }
  }

  void _updateFilterBreakdown({List<dynamic>? data}) {
    final source = data ?? _allData;

    // Note: Status counts should come from backend API (_loadStatusCounts)
    // Do not recalculate here to avoid double counting
    
    // For Expense Report Mode: Breakdown comes from backend API, don't recalculate
    if (_isExpenseReportMode) {
      debugPrint('üìä [EXPENSE REPORT] Skipping client-side breakdown calculation - using backend summary');
      return;
    }

    final Map<String, Map<String, Map<String, num>>> updatedBreakdown = {
      'Expenses': {
        'Approved': {'count': 0, 'amount': 0.0},
        'Unapproved': {'count': 0, 'amount': 0.0},
        'Flagged': {'count': 0, 'amount': 0.0},
        'Rejected': {'count': 0, 'amount': 0.0},
      },
      'Transactions': {
        'Approved': {'count': 0, 'amount': 0.0},
        'Unapproved': {'count': 0, 'amount': 0.0},
        'Flagged': {'count': 0, 'amount': 0.0},
        'Rejected': {'count': 0, 'amount': 0.0},
      },
      'Collections': {
        'Accounted': {'count': 0, 'amount': 0.0},
        'Unaccounted': {'count': 0, 'amount': 0.0},
        'Flagged': {'count': 0, 'amount': 0.0},
        'Rejected': {'count': 0, 'amount': 0.0},
      },
    };

    for (var item in source) {
      final type = item['type']?.toString() ?? 'Unknown';
      final statusValue = item['status']?.toString() ?? '';
      final normalizedStatus = _normalizeStatusKey(statusValue);
      final amount = _parseAmount(item['amount']);

      if (type == 'Expenses') {
        if (normalizedStatus == 'approved') {
          _incrementBreakdownEntry(updatedBreakdown, 'Expenses', 'Approved', amount);
        } else if (normalizedStatus == 'flagged') {
          _incrementBreakdownEntry(updatedBreakdown, 'Expenses', 'Flagged', amount);
        } else if (normalizedStatus == 'rejected') {
          // Rejected items should also be counted in Unapproved for Status Count Table
          _incrementBreakdownEntry(updatedBreakdown, 'Expenses', 'Rejected', amount);
          _incrementBreakdownEntry(updatedBreakdown, 'Expenses', 'Unapproved', amount);
        } else {
          _incrementBreakdownEntry(updatedBreakdown, 'Expenses', 'Unapproved', amount);
        }
      } else if (type == 'Transactions') {
        if (normalizedStatus == 'approved') {
          _incrementBreakdownEntry(updatedBreakdown, 'Transactions', 'Approved', amount);
        } else if (normalizedStatus == 'flagged') {
          _incrementBreakdownEntry(updatedBreakdown, 'Transactions', 'Flagged', amount);
        } else if (normalizedStatus == 'rejected') {
          // Rejected items should also be counted in Unapproved for Status Count Table
          _incrementBreakdownEntry(updatedBreakdown, 'Transactions', 'Rejected', amount);
          _incrementBreakdownEntry(updatedBreakdown, 'Transactions', 'Unapproved', amount);
        } else {
          _incrementBreakdownEntry(updatedBreakdown, 'Transactions', 'Unapproved', amount);
        }
      } else if (type == 'Collections') {
        if (normalizedStatus == 'accounted' || normalizedStatus == 'approved') {
          _incrementBreakdownEntry(updatedBreakdown, 'Collections', 'Accounted', amount);
        } else if (normalizedStatus == 'flagged') {
          _incrementBreakdownEntry(updatedBreakdown, 'Collections', 'Flagged', amount);
        } else if (normalizedStatus == 'rejected') {
          // Rejected items should also be counted in Unaccounted for Status Count Table
          _incrementBreakdownEntry(updatedBreakdown, 'Collections', 'Rejected', amount);
          _incrementBreakdownEntry(updatedBreakdown, 'Collections', 'Unaccounted', amount);
        } else {
          _incrementBreakdownEntry(updatedBreakdown, 'Collections', 'Unaccounted', amount);
        }
      }
    }

    setState(() {
      _filterBreakdown = updatedBreakdown.map((category, statusMap) {
        final convertedStatus = statusMap.map((status, values) {
          final count = (values['count'] ?? 0).toInt();
          final amount = _parseAmount(values['amount']);
          return MapEntry(status, {
            'count': count,
            'amount': amount,
          });
        });
        return MapEntry(category, convertedStatus);
      });
    });
  }

  void _incrementBreakdownEntry(
    Map<String, Map<String, Map<String, num>>> breakdown,
    String category,
    String statusKey,
    double amount,
  ) {
    final entry = breakdown[category]?[statusKey];
    if (entry == null) return;

    final currentCount = (entry['count'] ?? 0).toInt();
    final currentAmount = _parseAmount(entry['amount']);

    entry['count'] = currentCount + 1;
    entry['amount'] = currentAmount + amount;
  }

  Map<String, double> _calculateSelfWalletCashFlow(
    List<Map<String, dynamic>> data,
    String currentUserId,
    Map<String, dynamic>? wallet,
  ) {
    return _calculateUserWalletCashFlow(data, currentUserId, wallet);
  }

  /// Calculate cash flow for a specific user from filtered data
  /// Similar to _calculateSelfWalletCashFlow but can be used for any userId
  Map<String, double> _calculateUserWalletCashFlow(
    List<Map<String, dynamic>> data,
    String userId,
    Map<String, dynamic>? wallet,
  ) {
    double cashIn = 0.0;
    double cashOut = 0.0;

    for (final item in data) {
      final type = item['type']?.toString() ?? '';
      final amount = _parseAmount(item['amount']);
      if (amount == 0.0) continue;

      final statusValue = item['status']?.toString() ?? '';
      final normalizedStatus = _normalizeStatusKey(statusValue);

      switch (type) {
        case 'Add Amount':
          cashIn += amount;
          break;
        case 'Withdraw':
          cashOut += amount;
          break;
        case 'Collections':
          if (normalizedStatus == 'accounted' || normalizedStatus == 'approved') {
            final assignedReceiverId = item['assignedReceiver'] is Map
                ? (item['assignedReceiver']?['_id'] ?? item['assignedReceiver']?['id'] ?? '').toString()
                : (item['assignedReceiver'] ?? '').toString();
            if (assignedReceiverId.isEmpty || assignedReceiverId == userId) {
              cashIn += amount;
            }
          }
          break;
        case 'Expenses':
          // With new backend logic: Admin pays User1 (reimbursement)
          // So for expense owner: Approved expense = Cash In (reimbursement received)
          if (_isItemApproved(item)) {
            final expenseUserId = item['userId'] is Map
                ? (item['userId']?['_id'] ?? item['userId']?['id'] ?? '').toString()
                : (item['userId'] ?? '').toString();
            if (expenseUserId.isEmpty || expenseUserId == userId) {
              cashIn += amount; // Expense owner receives reimbursement (Cash In)
            }
          }
          break;
        case 'Transactions':
          // IMPORTANT TRANSACTION LOGIC FOR ALL USERS:
          // - Only 'approved' or 'completed' transactions affect Cash In/Cash Out
          // - 'pending', 'flagged', 'rejected', 'cancelled' transactions are NOT counted
          // - When user is RECEIVER: Transaction amount = Cash In
          // - When user is SENDER: Transaction amount = Cash Out
          // - If transaction is rejected/cancelled after approval, wallet is reversed (handled in backend)
          // - This logic applies consistently to ALL users in the system
          if (normalizedStatus == 'approved' || normalizedStatus == 'completed') {
            final senderId = item['sender'] is Map
                ? (item['sender']?['_id'] ?? item['sender']?['id'] ?? '').toString()
                : (item['sender'] ?? '').toString();
            final receiverId = item['receiver'] is Map
                ? (item['receiver']?['_id'] ?? item['receiver']?['id'] ?? '').toString()
                : (item['receiver'] ?? '').toString();

            if (senderId == userId) {
              cashOut += amount; // User sent money = Cash Out
            } else if (receiverId == userId) {
              cashIn += amount; // User received money = Cash In
            }
          }
          break;
        default:
          break;
      }
    }

    double balance = cashIn - cashOut;
    if (wallet != null) {
      final walletBalance = _parseAmount(wallet['totalBalance']);
      if (walletBalance != null) {
        balance = walletBalance;
      }
    }

    return {
      'cashIn': cashIn,
      'cashOut': cashOut,
      'balance': balance,
    };
  }

  bool _isWalletViewSelected() {
    return _selectedItem == NavItem.walletSelf || _selectedItem == NavItem.walletOverview;
  }

  Future<void> _applyFilters({bool debounce = true}) async {
    // Debounce filter updates to reduce unnecessary recalculations
    if (debounce) {
      _debounceTimer?.cancel();
      _debounceTimer = Timer(const Duration(milliseconds: 300), () async {
        if (mounted) {
          await _applyFilters(debounce: false);
        }
      });
      return;
    }
    
    // Prevent concurrent execution
    if (_isApplyingFilters) {
      return;
    }
    
    if (!mounted) return;
    
    _isApplyingFilters = true;
    
    try {
      // Get FilterProvider for global filters
      final filterProvider = _filterProvider;

      // Log for Self Wallet
      if (_selectedItem == NavItem.walletSelf) {
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üîç [SELF WALLET] _applyFilters() - START');
        debugPrint('   Total items in _allData: ${_allData.length}');
        debugPrint('   Active Filters:');
        debugPrint('     - Type: ${filterProvider.selectedType ?? "All"}');
        debugPrint('     - Status: ${filterProvider.selectedStatus ?? "All"}');
        debugPrint('     - Status Set: $_selectedStatusSet');
        debugPrint('     - Mode: ${filterProvider.selectedMode ?? "All"}');
        debugPrint('     - Start Date: ${filterProvider.startDate}');
        debugPrint('     - End Date: ${filterProvider.endDate}');
        debugPrint('     - Quick Range: ${filterProvider.selectedQuickRange}');
        debugPrint('     - User IDs: ${filterProvider.selectedUserIds.length}');
        debugPrint('   _isApplyingFilters: $_isApplyingFilters');
        debugPrint('   _isLoadingFinancialData: $_isLoadingFinancialData');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      }

      List<dynamic> filtered = List.from(_allData);

      // Force filter to expenses only if in expense report mode
      if (_isExpenseReportMode) {
        filtered = filtered.where((item) => item['type'] == 'Expenses').toList();
        // Ensure type is set to Expenses (temporarily remove listener to prevent infinite loop)
        if (filterProvider.selectedType != 'Expenses') {
          filterProvider.removeListener(_onFilterChanged);
          filterProvider.setType('Expenses');
          // Re-add listener after modification
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
              filterProvider.addListener(_onFilterChanged);
            }
          });
        }
      }

      bool pendingMode = _pendingApprovalsMode;

      if (pendingMode && (filterProvider.selectedType != null || filterProvider.selectedStatus != null || _selectedStatusSet.isNotEmpty)) {
        pendingMode = false;
      }

      // Filter by selected payment mode (for All Account Reports)
      if (_selectedItem == NavItem.accountReports && _selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty) {
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üîç [ACCOUNT REPORTS] Applying account filter in _applyFilters:');
        debugPrint('   _selectedAccountFilterId: $_selectedAccountFilterId');
        debugPrint('   Items before account filter: ${filtered.length}');
        
        // Get selected account name for logging
        String? selectedAccountName;
        try {
          final selectedAccount = _allAccountsList.firstWhere(
            (account) {
              final accountId = (account['id'] ?? account['_id'])?.toString();
              return accountId == _selectedAccountFilterId;
            },
            orElse: () => <String, dynamic>{},
          );
          if (selectedAccount.isNotEmpty) {
            selectedAccountName = (selectedAccount['name'] ?? selectedAccount['modeName'] ?? '').toString();
          }
        } catch (e) {
          // Ignore
        }
        debugPrint('   Selected Account Name: ${selectedAccountName ?? 'Unknown'}');
        
        // Debug: Check first few items to see why they're not matching
        if (filtered.isNotEmpty) {
          debugPrint('   Sample items before filtering:');
          for (int i = 0; i < (filtered.length > 3 ? 3 : filtered.length); i++) {
            final item = filtered[i];
            final itemType = item['type']?.toString() ?? 'Unknown';
            final paymentModeId = _extractPaymentModeId(item);
            final paymentModeName = _extractPaymentModeName(item);
            final accountId = item['accountId']?.toString() ?? item['paymentModeId']?.toString();
            final doesMatch = _doesItemMatchSelectedAccount(item);
            debugPrint('     Item $i: type=$itemType, paymentModeId=$paymentModeId, paymentModeName=$paymentModeName, accountId=$accountId, selectedAccountId=$_selectedAccountFilterId, matches=$doesMatch');
            
            // Also log the full paymentMode object if it exists
            if (item['paymentMode'] != null) {
              debugPrint('       paymentMode object: ${item['paymentMode']}');
            }
          }
        } else {
          debugPrint('   ‚ö†Ô∏è  No items in filtered list before account filter!');
          debugPrint('   _allData.length: ${_allData.length}');
        }
        
        filtered = filtered.where((item) => _doesItemMatchSelectedAccount(item)).toList();
        debugPrint('   Items after account filter: ${filtered.length}');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // For Account Reports with account filter: ALWAYS use API summary values
        // The API already filtered by accountId and excluded Entry 1 collections
        // Backend correctly excludes Entry 1 at database level, so API values are accurate
        // DO NOT recalculate from filtered data - it could cause double counting if Entry 1 slips through
        final bool hasApiSummaryValues = _cashIn != 0.0 || _cashOut != 0.0 || _balance != 0.0;
        
        if (hasApiSummaryValues) {
          // API has correct values (already filtered and Entry 1 excluded) - ALWAYS use them
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          debugPrint('üìä [ACCOUNT REPORTS] Using API summary totals (backend already filtered correctly):');
          debugPrint('   Account ID: $_selectedAccountFilterId');
          debugPrint('   Cash In: $_cashIn (from API - Entry 1 excluded)');
          debugPrint('   Cash Out: $_cashOut (from API - Entry 1 excluded)');
          debugPrint('   Balance: $_balance (from API - Entry 1 excluded)');
          debugPrint('   Note: Backend excludes Entry 1 at database level, so API values are accurate');
          debugPrint('   Note: NOT recalculating from filtered data to prevent double counting');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          // Don't update - keep existing API values (already set correctly)
        } else if (filtered.isNotEmpty) {
          // Only recalculate if API values are 0 AND we have filtered data
          // This handles edge cases where API might return 0, 0, 0
        // Recalculate totals from filtered data (account-specific)
        double accountCashIn = 0.0;
        double accountCashOut = 0.0;
        
        // Get current user ID to check if user is expense owner or approver
        String? currentUserId;
        try {
          currentUserId = await AuthService.getUserId();
        } catch (e) {
          debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Could not get current user ID: $e');
        }
        
        for (final item in filtered) {
          final amount = _parseAmount(item['amount']);
          final type = item['type']?.toString() ?? '';
          
          if (type == 'Expenses') {
            // With new backend logic: Approver pays Expense Owner (reimbursement)
            // - Expense owner: Approved expense = Cash In (reimbursement received)
            // - Approver: Approved expense = Cash Out (payment made)
            if (_isItemApproved(item)) {
              // Get expense owner ID
              final expenseUserId = item['userId'] is Map
                  ? (item['userId']?['_id'] ?? item['userId']?['id'] ?? '').toString()
                  : (item['userId'] ?? '').toString();
              
              // Get approver ID
              final approvedByValue = item['approvedBy'];
              String? approverId;
              if (approvedByValue != null) {
                if (approvedByValue is Map) {
                  approverId = (approvedByValue['_id'] ?? approvedByValue['id'] ?? '').toString();
                } else if (approvedByValue is String) {
                  approverId = approvedByValue;
                } else {
                  approverId = approvedByValue.toString();
                }
              }
              
              // Check if current user is expense owner or approver
              if (currentUserId != null) {
                if (expenseUserId == currentUserId) {
                  // Current user is expense owner: Cash In (reimbursement received)
                  accountCashIn += amount;
                } else if (approverId != null && approverId == currentUserId) {
                  // Current user is approver: Cash Out (payment made)
                  accountCashOut += amount;
                }
              } else {
                // If we can't determine user, default to expense owner logic (Cash In)
                // This maintains backward compatibility
                accountCashIn += amount;
              }
            }
          } else if (type == 'Collections') {
              if (_isItemApproved(item)) {
              accountCashIn += amount;
            }
          } else if (type == 'Transactions') {
              if (_isItemApproved(item)) {
              accountCashIn += amount;
            }
          } else if (type == 'Add Amount' || type.toLowerCase() == 'add amount') {
            accountCashIn += amount;
          } else if (type == 'Withdraw' || type.toLowerCase() == 'withdraw') {
            accountCashOut += amount;
          }
        }
        
        final accountBalance = accountCashIn - accountCashOut;
        
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üìä [ACCOUNT REPORTS] Recalculated totals from filtered data:');
        debugPrint('   Account ID: $_selectedAccountFilterId');
        debugPrint('   Calculated Cash In: $accountCashIn');
        debugPrint('   Calculated Cash Out: $accountCashOut');
        debugPrint('   Calculated Balance: $accountBalance');
        debugPrint('   Current _cashIn: $_cashIn');
        debugPrint('   Current _cashOut: $_cashOut');
        debugPrint('   Current _balance: $_balance');
        debugPrint('   Values changed: ${_cashIn != accountCashIn || _cashOut != accountCashOut || _balance != accountBalance}');
        debugPrint('   mounted: $mounted');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // Update totals in setState
        if (mounted && (_cashIn != accountCashIn || _cashOut != accountCashOut || _balance != accountBalance)) {
          debugPrint('üîÑ [ACCOUNT REPORTS] Calling setState to update values from filtered data...');
          setState(() {
            _cashIn = accountCashIn;
            _cashOut = accountCashOut;
            _balance = accountBalance;
          });
          debugPrint('‚úÖ [ACCOUNT REPORTS] setState completed - values updated from filtered data');
          debugPrint('   After setState - _cashIn: $_cashIn');
          debugPrint('   After setState - _cashOut: $_cashOut');
          debugPrint('   After setState - _balance: $_balance');
        } else {
          if (!mounted) {
            debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Widget not mounted, cannot update values');
          } else {
            debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Values unchanged, skipping setState');
          }
        }
        } else {
          // No API values and no filtered data - ensure values are 0
          // This handles the case where API returned 0, 0, 0 (like Company Upi)
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          debugPrint('üìä [ACCOUNT REPORTS] No data - ensuring totals are 0:');
          debugPrint('   Account ID: $_selectedAccountFilterId');
          debugPrint('   Current Cash In: $_cashIn');
          debugPrint('   Current Cash Out: $_cashOut');
          debugPrint('   Current Balance: $_balance');
          debugPrint('   Setting to: Cash In=0, Cash Out=0, Balance=0');
          debugPrint('   mounted: $mounted');
          debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          
          // Always update to 0 to ensure UI reflects correct values
          // This is important when switching from an account with data (Cash: 500) to one without (Company Upi: 0)
          if (mounted) {
            debugPrint('üîÑ [ACCOUNT REPORTS] Calling setState to update values to 0...');
            setState(() {
              _cashIn = 0.0;
              _cashOut = 0.0;
              _balance = 0.0;
            });
            debugPrint('‚úÖ [ACCOUNT REPORTS] setState completed - Updated totals to 0, 0, 0');
            debugPrint('   After setState - _cashIn: $_cashIn');
            debugPrint('   After setState - _cashOut: $_cashOut');
            debugPrint('   After setState - _balance: $_balance');
          } else {
            debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Widget not mounted, cannot update values');
          }
        }
      } else if (_selectedItem == NavItem.accountReports && (_selectedAccountFilterId == null || _selectedAccountFilterId!.isEmpty)) {
        // No account filter: Only recalculate if data changed or totals not set
        // Skip if totals are already set from API and data hasn't changed
        final bool shouldRecalculate = !_accountReportsDataLoaded || 
            (_cashIn == 0.0 && _cashOut == 0.0 && _balance == 0.0);
        
        if (shouldRecalculate) {
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üìä [ACCOUNT REPORTS] No account filter - calculating totals from all data (all accounts)');
        debugPrint('   Items count: ${filtered.length}');
        
        double allAccountsCashIn = 0.0;
        double allAccountsCashOut = 0.0;
        
        for (final item in filtered) {
          final amount = _parseAmount(item['amount']);
          final type = item['type']?.toString() ?? '';
          
          if (type == 'Expenses') {
              // With new backend logic: Admin pays User1 (reimbursement)
              // So for expense owner: Approved expense = Cash In (reimbursement received)
              if (_isItemApproved(item)) {
                allAccountsCashIn += amount; // Expense owner receives reimbursement
            }
          } else if (type == 'Collections') {
              if (_isItemApproved(item)) {
              allAccountsCashIn += amount;
            }
          } else if (type == 'Transactions') {
              if (_isItemApproved(item)) {
              allAccountsCashIn += amount;
            }
          } else if (type == 'Add Amount' || type.toLowerCase() == 'add amount') {
            allAccountsCashIn += amount;
          } else if (type == 'Withdraw' || type.toLowerCase() == 'withdraw') {
            allAccountsCashOut += amount;
          }
        }
        
        final allAccountsBalance = allAccountsCashIn - allAccountsCashOut;
        
        debugPrint('   Calculated Cash In: $allAccountsCashIn');
        debugPrint('   Calculated Cash Out: $allAccountsCashOut');
        debugPrint('   Calculated Balance: $allAccountsBalance');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // Update totals in setState
        if (mounted) {
          setState(() {
            _cashIn = allAccountsCashIn;
            _cashOut = allAccountsCashOut;
            _balance = allAccountsBalance;
          });
          }
        } else {
          // Totals already calculated, skip duplicate calculation
          debugPrint('üìä [ACCOUNT REPORTS] Skipping duplicate calculation - totals already set');
        }
      }

      if (pendingMode) {
        filtered = filtered.where((item) {
          final statusValue = item['status']?.toString() ?? '';
          final normalizedStatus = _normalizeStatusKey(statusValue);
          // Include rejected items in Unapproved/Unaccounted for Status Count Table
          return normalizedStatus == 'unapproved' || 
                 normalizedStatus == 'unaccounted' || 
                 normalizedStatus == 'rejected';
        }).toList();
      }

      // Filter by type
      if (filterProvider.selectedType != null) {
        final beforeCount = filtered.length;
        filtered = filtered.where((item) => item['type'] == filterProvider.selectedType).toList();
        if (_selectedItem == NavItem.walletSelf) {
          debugPrint('üîç [SELF WALLET] Type filter applied: ${filterProvider.selectedType}');
          debugPrint('   Items before: $beforeCount, after: ${filtered.length}');
        }
      }

      // Filter by status (multi-select first)
      bool isFilteringForFlagged = false;
      if (_selectedStatusSet.isNotEmpty) {
        final beforeCount = filtered.length;
        isFilteringForFlagged = _selectedStatusSet.contains('Flagged');
        filtered = filtered.where((item) {
          final String type = item['type']?.toString() ?? '';
          final String status = item['status']?.toString() ?? '';
          return _selectedStatusSet.any(
            (selected) => _statusMatchesSelection(selected, status, type),
          );
        }).toList();
        if (_selectedItem == NavItem.walletSelf) {
          debugPrint('üîç [SELF WALLET] Status filter applied (multi-select): $_selectedStatusSet');
          debugPrint('   Items before: $beforeCount, after: ${filtered.length}');
        }
      } else if (filterProvider.selectedStatus != null) {
        final beforeCount = filtered.length;
        isFilteringForFlagged = filterProvider.selectedStatus == 'Flagged';
        filtered = filtered.where((item) {
          final String type = item['type']?.toString() ?? '';
          final String status = item['status']?.toString() ?? '';
          return _statusMatchesSelection(filterProvider.selectedStatus!, status, type);
        }).toList();
        if (_selectedItem == NavItem.walletSelf) {
          debugPrint('üîç [SELF WALLET] Status filter applied: ${filterProvider.selectedStatus}');
          debugPrint('   Items before: $beforeCount, after: ${filtered.length}');
        }
      }

      // If filtering for Flagged status, merge flagged items from timeline
      if (isFilteringForFlagged) {
        final flaggedItemsFromTimeline = _getFlaggedFinancialFlowItems(_timelineItems);
        final convertedFlaggedItems = flaggedItemsFromTimeline.map((timelineItem) {
          final financialData = timelineItem['financialData'] as Map<String, dynamic>? ?? {};
          final category = timelineItem['category']?.toString().toLowerCase() ?? '';
          
          // Determine item type
          String itemType = 'Transactions';
          if (category == 'expenses' || category == 'expense') {
            itemType = 'Expenses';
          } else if (category == 'collections' || category == 'collection') {
            itemType = 'Collections';
          }
          
          // Get ID based on category
          final itemId = category == 'expenses' || category == 'expense'
              ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
              : (category == 'collections' || category == 'collection'
                  ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
                  : (financialData['transactionId'] ?? 'N/A'));
          
          // Get timestamp
          DateTime? timestamp;
          if (timelineItem['timestamp'] != null) {
            if (timelineItem['timestamp'] is DateTime) {
              timestamp = timelineItem['timestamp'] as DateTime;
            } else {
              try {
                timestamp = DateTime.parse(timelineItem['timestamp'].toString());
              } catch (e) {
                timestamp = DateTime.now();
              }
            }
          } else {
            timestamp = DateTime.now();
          }
          
          // Build the item in the format expected by the table
          final convertedItem = <String, dynamic>{
            'id': itemId,
            'type': itemType,
            'status': 'Flagged',
            'date': timestamp.toIso8601String(),
            'amount': financialData['amount'] ?? 0.0,
            'mode': financialData['paymentMode'] ?? financialData['mode'] ?? 'Cash',
            'createdBy': financialData['createdBy'] ?? timelineItem['createdBy'],
          };
          
          // Add type-specific fields
          if (itemType == 'Collections') {
            convertedItem['from'] = financialData['from'] ?? financialData['collectedBy'] ?? '';
            convertedItem['to'] = financialData['assignedReceiver'] ?? financialData['to'] ?? '';
            convertedItem['customerName'] = financialData['customerName'] ?? '';
            convertedItem['notes'] = financialData['notes'] ?? '';
          } else if (itemType == 'Expenses') {
            convertedItem['from'] = financialData['from'] ?? financialData['createdBy'] ?? '';
            convertedItem['to'] = financialData['category'] ?? financialData['expenseType'] ?? '';
            convertedItem['description'] = financialData['description'] ?? '';
            convertedItem['category'] = financialData['category'] ?? financialData['expenseType'] ?? '';
          } else if (itemType == 'Transactions') {
            convertedItem['from'] = financialData['from'] ?? financialData['sender'] ?? '';
            convertedItem['to'] = financialData['receiver'] ?? financialData['to'] ?? '';
            convertedItem['purpose'] = financialData['purpose'] ?? '';
          }
          
          return convertedItem;
        }).toList();
        
        // Merge flagged items, avoiding duplicates based on ID
        final existingIds = filtered.map((item) => item['id']?.toString() ?? '').toSet();
        final newFlaggedItems = convertedFlaggedItems.where((item) {
          final itemId = item['id']?.toString() ?? '';
          return itemId.isNotEmpty && !existingIds.contains(itemId);
        }).toList();
        
        filtered = [...filtered, ...newFlaggedItems];
      }

      if (filterProvider.selectedUserIds.isNotEmpty || _selectedUserLabelMatchers.isNotEmpty) {
        filtered = filtered.where(_doesItemMatchSelectedUser).toList();
      }
      
      if (filterProvider.selectedMode != null) {
        final beforeCount = filtered.length;
        filtered = filtered.where((item) {
          // Try multiple fields for mode: mode, paymentMode (object), paymentMode.name
          String? itemMode;
          
          // First try direct 'mode' field
          if (item['mode'] != null) {
            itemMode = item['mode'].toString().trim();
          }
          // If mode is an object, try to get name from it
          else if (item['paymentMode'] != null) {
            if (item['paymentMode'] is Map) {
              itemMode = (item['paymentMode'] as Map)['name']?.toString().trim();
            } else {
              itemMode = item['paymentMode'].toString().trim();
            }
          }
          
          if (itemMode == null || itemMode.isEmpty) {
            if (_selectedItem == NavItem.walletSelf) {
              debugPrint('   ‚ö†Ô∏è  Item ${item['id']} has no mode field');
            }
            return false;
          }
          
          final selectedMode = filterProvider.selectedMode!.trim();
          final normalizedItemMode = itemMode.toLowerCase();
          final normalizedSelectedMode = selectedMode.toLowerCase();
          
          // Handle specific payment mode names
          if (selectedMode == 'Sales UPI') {
            return normalizedItemMode == 'upi' && (item['name']?.toString().toLowerCase().contains('sales') ?? false);
          } else if (selectedMode == 'Purchase UPI') {
            return normalizedItemMode == 'upi' && (item['name']?.toString().toLowerCase().contains('purchase') ?? false);
          } else if (selectedMode == 'Bank Transfer') {
            return normalizedItemMode == 'bank';
          } else {
            // Direct mode match (case-insensitive) for Cash, UPI, Bank, online, etc.
            final matches = normalizedItemMode == normalizedSelectedMode;
            if (_selectedItem == NavItem.walletSelf && !matches) {
              debugPrint('   ‚ùå Item ${item['id']} mode mismatch: itemMode="$itemMode" (normalized: "$normalizedItemMode") vs selected="$selectedMode" (normalized: "$normalizedSelectedMode")');
            }
            return matches;
          }
        }).toList();
        if (_selectedItem == NavItem.walletSelf) {
          debugPrint('üîç [SELF WALLET] Mode filter applied: ${filterProvider.selectedMode}');
          debugPrint('   Items before: $beforeCount, after: ${filtered.length}');
        }
      }

      // Filter by expense type category (ONLY for expense report)
      if (_selectedItem == NavItem.expenseReport && _selectedExpenseTypeCategory != null) {
        filtered = filtered.where((item) {
          final itemCategory = item['category']?.toString() ?? '';
          return itemCategory == _selectedExpenseTypeCategory;
        }).toList();
      }

      // Filter by date range
      if (filterProvider.startDate != null || filterProvider.endDate != null) {
        final beforeCount = filtered.length;
        if (_selectedItem == NavItem.walletSelf && beforeCount > 0) {
          debugPrint('üîç [SELF WALLET] Date range filter - checking ${beforeCount} items');
          debugPrint('   Filter range: ${filterProvider.startDate} to ${filterProvider.endDate}');
          // Log first few items to see their date fields
          for (int i = 0; i < (beforeCount > 3 ? 3 : beforeCount); i++) {
            final item = filtered[i];
            final dateField = item['date'];
            final createdAtField = item['createdAt'];
            debugPrint('   Item $i: date=$dateField, createdAt=$createdAtField, type=${item['type']}');
          }
        }
        filtered = filtered.where((item) {
          try {
            // Try multiple date field names in order of preference
            dynamic dateValue = item['date'] ?? item['createdAt'] ?? item['dateTime'];
            
            if (dateValue == null) {
              if (_selectedItem == NavItem.walletSelf) {
                debugPrint('   ‚ö†Ô∏è  Item ${item['id']} has no date field (checked: date, createdAt, dateTime)');
              }
              return false;
            }
            
            DateTime? itemDate;
            
            // Handle different date formats
            if (dateValue is DateTime) {
              itemDate = dateValue.toLocal();
            } else if (dateValue is String) {
              try {
                // Try parsing as ISO8601 first
                itemDate = DateTime.parse(dateValue).toLocal();
              } catch (e) {
                // If ISO8601 fails, try other common formats
                try {
                  // Try parsing as "dd-MMM-yyyy" format
                  final parts = dateValue.split('-');
                  if (parts.length == 3) {
                    final day = int.parse(parts[0]);
                    final monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    final month = monthNames.indexOf(parts[1]) + 1;
                    final year = int.parse(parts[2].length == 2 ? '20${parts[2]}' : parts[2]);
                    itemDate = DateTime(year, month, day).toLocal();
                  } else {
                    throw Exception('Unknown date format: $dateValue');
                  }
                } catch (e2) {
                  if (_selectedItem == NavItem.walletSelf) {
                    debugPrint('   ‚ö†Ô∏è  Could not parse date "$dateValue" for item ${item['id']}: $e2');
                  }
                  return false;
                }
              }
            } else {
              if (_selectedItem == NavItem.walletSelf) {
                debugPrint('   ‚ö†Ô∏è  Item ${item['id']} date field is not DateTime or String: ${dateValue.runtimeType}');
              }
              return false;
            }
            
            if (itemDate == null) {
              return false;
            }
            
            // Check start date: item must be on or after start date (start of day)
            bool passesStartDate = true;
            if (filterProvider.startDate != null) {
              final startOfDay = DateTime(
                filterProvider.startDate!.year,
                filterProvider.startDate!.month,
                filterProvider.startDate!.day,
              );
              passesStartDate = itemDate.isAfter(startOfDay.subtract(const Duration(seconds: 1)));
            }
            
            // Check end date: item must be on or before end date (end of day = 23:59:59)
            bool passesEndDate = true;
            if (filterProvider.endDate != null) {
              final endOfDay = DateTime(
                filterProvider.endDate!.year,
                filterProvider.endDate!.month,
                filterProvider.endDate!.day,
                23,
                59,
                59,
              );
              passesEndDate = itemDate.isBefore(endOfDay.add(const Duration(seconds: 1)));
            }
            
            if (!passesStartDate || !passesEndDate) {
              if (_selectedItem == NavItem.walletSelf) {
                debugPrint('   ‚ùå Item ${item['id']} filtered out: date=$itemDate, passesStartDate=$passesStartDate, passesEndDate=$passesEndDate');
              }
              return false;
            }
            
            if (_selectedItem == NavItem.walletSelf) {
              debugPrint('   ‚úÖ Item ${item['id']} passed date filter: date=$itemDate');
            }
            return true;
          } catch (e) {
            if (_selectedItem == NavItem.walletSelf) {
              debugPrint('   ‚ö†Ô∏è  Error parsing date for item ${item['id']}: $e');
            }
            return false;
          }
        }).toList();
        if (_selectedItem == NavItem.walletSelf) {
          debugPrint('üîç [SELF WALLET] Date range filter applied: ${filterProvider.startDate} to ${filterProvider.endDate}');
          debugPrint('   Items before: $beforeCount, after: ${filtered.length}');
        }
      }

      // For Self Wallet: Remove all dummy data when cash in, cash out, and balance are all zero
      if (_selectedItem == NavItem.walletSelf) {
        final bool allZero = _cashIn == 0.0 && _cashOut == 0.0 && _balance == 0.0;
        if (allZero) {
          filtered = filtered.where((item) {
            // Remove any entries marked as dummy data
            final isDummy = item['isDummy'] == true || 
                           (item['id']?.toString().startsWith('dummy-') ?? false);
            return !isDummy;
          }).toList();
        }
      }


      if (mounted) {
        setState(() {
          _filteredData = filtered;
          _expandedRows.clear();
          _pendingApprovalsMode = pendingMode;
        });
      }

      // For Self Wallet and All Wallet Report: Skip financial summary calculation (API provides correct values)
      // For other views: Calculate financial summary from filtered data
      if (_selectedItem == NavItem.walletSelf) {
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        debugPrint('üîç [SELF WALLET] _applyFilters() - FILTERING COMPLETE');
        debugPrint('   Final filtered items count: ${filtered.length}');
        debugPrint('   _filteredData will be updated with ${filtered.length} items');
        debugPrint('   ‚ö†Ô∏è  NOTE: Only local data filtered. API reload should be triggered by _onFilterChanged()');
        debugPrint('   Current state:');
        debugPrint('     - _isApplyingFilters: $_isApplyingFilters');
        debugPrint('     - _isLoadingFinancialData: $_isLoadingFinancialData');
        debugPrint('     - mounted: $mounted');
        debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      } else if (_selectedItem == NavItem.walletOverview) {
        // All Wallet Report: Skip financial summary calculation (API provides correct values)
        // Note: Do NOT trigger API reload here - the FilterProvider listener (_onFilterChanged) will handle it
        // This prevents duplicate API calls and infinite loops
        final filterProvider = _filterProvider;
        print('üìä [ALL WALLET REPORTS] _applyFilters() - Filters applied (listener will handle API reload)');
        print('   User filters: ${filterProvider.selectedUserIds.length} user(s)');
        print('   Date range: ${filterProvider.startDate} to ${filterProvider.endDate}');
        print('   Mode: ${filterProvider.selectedMode}');
        print('   Status: ${filterProvider.selectedStatus}');
        print('   Type: ${filterProvider.selectedType}');
        // Don't call _loadFinancialData here - _onFilterChanged listener will handle it
      } else if (_selectedItem == NavItem.accountReports) {
        // Account Reports: Skip _calculateFinancialSummary - totals already calculated above
        // This prevents duplicate calculations
        debugPrint('üìä [ACCOUNT REPORTS] Skipping _calculateFinancialSummary() - totals already calculated in _applyFilters');
      } else {
        // Always calculate financial summary from filtered data
        // For other views, it will calculate aggregated balances
        _calculateFinancialSummary(data: filtered);
      }
      _updateFilterBreakdown(data: filtered);
    } finally {
      _isApplyingFilters = false;
    }
  }

  void _clearFilters() {
    final filterProvider = _filterProvider;
    
    // Temporarily remove listener to prevent infinite loop when modifying filters
    filterProvider.removeListener(_onFilterChanged);
    
    setState(() {
      filterProvider.setType(null);
      // For All Account Reports, default status should be 'Approved' instead of 'All'
      if (_selectedItem == NavItem.accountReports) {
        filterProvider.setStatus('Approved');
      } else {
        filterProvider.setStatus(null);
      }
      _selectedStatusSet.clear();
      filterProvider.setMode(null);
      _selectedExpenseTypeCategory = null;
      filterProvider.clearUserFilter();
      _selectedUserLabelMatchers.clear();
      filterProvider.setQuickRange(null);
      filterProvider.clearDateRange();
      _pendingApprovalsMode = false;
      filterProvider.setUserStatus('Active');
    });
    
    // Re-add listener after modifications
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        filterProvider.addListener(_onFilterChanged);
        _applyFilters();
      }
    });
  }

  int _getActiveFilterCount() {
    final filterProvider = _filterProvider;
    int count = 0;
    if (filterProvider.selectedType != null) count++;
    if (filterProvider.selectedStatus != null || _selectedStatusSet.isNotEmpty) count++;
    if (filterProvider.selectedMode != null) count++;
    if (_selectedExpenseTypeCategory != null) count++;
    if (filterProvider.startDate != null || filterProvider.endDate != null) count++;
    if (filterProvider.selectedQuickRange != null) count++;
    if (filterProvider.selectedQuarter != null) count++;
    return count;
  }

  String _getActiveFilterSummary() {
    final filterProvider = _filterProvider;
    final List<String> parts = [];
    
    if (filterProvider.selectedQuickRange != null) {
      switch (filterProvider.selectedQuickRange) {
        case 'thisMonth':
          parts.add('This Month');
          break;
        case 'lastMonth':
          parts.add('Last Month');
          break;
        case 'thisFinancialYear':
          parts.add('This FY');
          break;
        case 'previousFinancialYear':
        case 'lastFinancialYear':
          parts.add('Previous FY');
          break;
      }
    } else if (filterProvider.selectedQuarter != null) {
      parts.add('Q${filterProvider.selectedQuarter}');
    } else if (filterProvider.startDate != null || filterProvider.endDate != null) {
      if (filterProvider.startDate != null && filterProvider.endDate != null) {
        parts.add('${DateFormat('dd MMM').format(filterProvider.startDate!)} - ${DateFormat('dd MMM').format(filterProvider.endDate!)}');
      } else if (filterProvider.startDate != null) {
        parts.add('From ${DateFormat('dd MMM').format(filterProvider.startDate!)}');
      } else if (filterProvider.endDate != null) {
        parts.add('Until ${DateFormat('dd MMM').format(filterProvider.endDate!)}');
      }
    }
    
    if (filterProvider.selectedMode != null) {
      parts.add(filterProvider.selectedMode!);
    }
    
    return parts.isEmpty ? 'No filters' : parts.join(' ‚Ä¢ ');
  }

  String _displayValue(dynamic value) {
    if (value == null) return '-';
    if (value is String) return value;
    if (value is Map) {
      return value['name']?.toString() ??
          value['username']?.toString() ??
          value['email']?.toString() ??
          value['id']?.toString() ??
          value.toString();
    }
    return value.toString();
  }

  _TableExportData _buildTableExportData({bool isAllAccounts = false}) {
    final List<String> headers = [
      if (isAllAccounts) 'Account',
      'Date',
      'Time',
      'Created By',
      'Type',
      'From',
      'To',
      'Mode',
      'Amount',
      'Approved By',
      'Status',
    ];

    final List<List<String>> rows = [];
    final List<double> amountValues = [];

    for (final raw in _filteredData) {
      final item = Map<String, dynamic>.from(raw);

      DateTime parsedDate;
      try {
        parsedDate = item['date'] != null
            ? DateTime.parse(item['date'].toString()).toLocal()
            : DateTime.now();
      } catch (_) {
        parsedDate = DateTime.now();
      }

      final dateStr = DateFormat('dd MMM yyyy').format(parsedDate);
      final timeStr = DateFormat('hh:mm a').format(parsedDate);
      final accountName = isAllAccounts 
          ? _displayValue(item['accountName'] ?? item['account'] ?? item['accountId'] ?? 'N/A').trim()
          : '';
      final createdBy = _displayValue(item['createdBy'] ?? item['created_by'] ?? item['user']).trim();
      final type = _displayValue(item['type']).trim();
      final from = _displayValue(item['from']).trim();
      final to = _displayValue(item['to']).trim();
      final mode = _displayValue(item['mode']).trim();
      final amountValue = _parseAmount(item['amount']);
      final approvedBy = _displayValue(item['approvedBy'] ?? item['approved_by']).trim();
      final status = _displayValue(item['status']).trim();

      amountValues.add(amountValue);
      final List<String> rowData = [
        if (isAllAccounts) accountName.isEmpty ? '-' : accountName,
        dateStr,
        timeStr,
        createdBy.isEmpty ? '-' : createdBy,
        type.isEmpty ? '-' : type,
        from.isEmpty ? '-' : from,
        to.isEmpty ? '-' : to,
        mode.isEmpty ? '-' : mode,
        _formatAmount(amountValue),
        approvedBy.isEmpty ? '-' : approvedBy,
        status.isEmpty ? '-' : status,
      ];
      rows.add(rowData);
    }

    return _TableExportData(headers: headers, rows: rows, amountValues: amountValues);
  }

  double _parseAmount(dynamic value) {
    if (value == null) {
      return 0.0;
    }
    if (value is num) {
      return value.toDouble();
    }
    if (value is String) {
      final normalized = value.replaceAll(RegExp(r'[^0-9\.\-]'), '');
      if (normalized.isEmpty) {
        return 0.0;
      }
      return double.tryParse(normalized) ?? 0.0;
    }
    return 0.0;
  }

  String _formatAmount(double amount) {
    // Format amount without trailing zeros
    final formatted = amount.toStringAsFixed(0).replaceAllMapped(
      RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'),
      (Match m) => '${m[1]},',
    );
    // Remove any trailing .00 if present
    return '‚Çπ${formatted.replaceAll(RegExp(r'\.00$'), '')}';
  }

  // Compact amount format - now shows full amount even on mobile
  String _formatAmountCompact(double amount, bool isMobile) {
    // Always return full formatted amount with commas
    return _formatAmount(amount);
  }

  bool _statusMatchesSelection(String selectedStatus, String status, String type) {
    final String normalizedSelected = selectedStatus == 'Accounted'
        ? 'accounted'
        : selectedStatus == 'Unaccounted'
            ? 'unaccounted'
            : selectedStatus == 'Flagged'
                ? 'flagged'
                : _normalizeStatusKey(selectedStatus);
    String normalizedStatus = _normalizeStatusKey(status);
    final String normalizedType = type.toLowerCase();

    // For Expenses, map 'Pending' status to 'unapproved'
    if (normalizedType == 'expenses') {
      if (normalizedStatus == 'unaccounted' || normalizedStatus == 'pending') {
        normalizedStatus = 'unapproved';
      }
    }

    if (normalizedSelected == 'approved') {
      return normalizedStatus == 'approved';
    }
    if (normalizedSelected == 'unapproved') {
      // For expenses, 'unapproved' includes 'Pending', 'rejected', 'unaccounted', and anything not 'approved' or 'flagged'
      if (normalizedType == 'expenses') {
        return normalizedStatus != 'approved' && 
               normalizedStatus != 'flagged';
      }
      // For transactions, 'unapproved' includes 'Pending', 'rejected', and anything not 'approved' or 'flagged'
      if (normalizedType == 'transactions') {
        return normalizedStatus != 'approved' && 
               normalizedStatus != 'flagged';
      }
      return normalizedStatus == 'unapproved' || normalizedStatus == 'rejected';
    }
    if (normalizedSelected == 'flagged') {
      return normalizedStatus == 'flagged';
    }
    if (normalizedSelected == 'rejected') {
      return normalizedStatus == 'rejected';
    }

    if (normalizedType == 'collections') {
    if (normalizedSelected == 'accounted') {
        return normalizedStatus == 'accounted' || normalizedStatus == 'approved';
      }
      if (normalizedSelected == 'unaccounted') {
        // Unaccounted includes rejected items for Status Count Table
        return normalizedStatus == 'unaccounted' || normalizedStatus == 'rejected';
      }
    } else {
      if (normalizedSelected == 'accounted') {
        return normalizedStatus == 'accounted' || normalizedStatus == 'approved';
      }
      if (normalizedSelected == 'unaccounted') {
        return normalizedStatus == 'unaccounted';
      }
    }

    return normalizedStatus == normalizedSelected;
  }

  String _getStatusDisplayText() {
    final filterProvider = _filterProvider;
    if (_selectedStatusSet.isNotEmpty) {
      if (_selectedStatusSet.length == 1) {
        return _selectedStatusSet.first;
      }
      return '${_selectedStatusSet.length} selected';
    }

    if (filterProvider.selectedType == 'Collections') {
      if (filterProvider.selectedStatus == 'Accounted') return 'Accounted';
      if (filterProvider.selectedStatus == 'Unaccounted') return 'Unaccounted';
      if (filterProvider.selectedStatus == 'Flagged') return 'Flagged';
      if (filterProvider.selectedStatus == 'Rejected') return 'Rejected';
    } else if (filterProvider.selectedType == 'Expenses' || filterProvider.selectedType == 'Transactions') {
      if (filterProvider.selectedStatus == 'Approved') return 'Approved';
      if (filterProvider.selectedStatus == 'Unapproved') return 'Unapproved';
      if (filterProvider.selectedStatus == 'Flagged') return 'Flagged';
      if (filterProvider.selectedStatus == 'Rejected') return 'Rejected';
    } else {
      if (filterProvider.selectedStatus == 'Accounted') return 'Accounted';
      if (filterProvider.selectedStatus == 'Unaccounted') return 'Unaccounted';
      if (filterProvider.selectedStatus == 'Flagged') return 'Flagged';
      if (filterProvider.selectedStatus == 'Approved') return 'Approved';
      if (filterProvider.selectedStatus == 'Unapproved') return 'Unapproved';
      if (filterProvider.selectedStatus == 'Rejected') return 'Rejected';
    }
    return 'All';
  }

  List<String> _getStatusOptions() {
    final filterProvider = _filterProvider;
    if (filterProvider.selectedType == 'Collections') {
      return ['All', 'Accounted', 'Unaccounted', 'Flagged', 'Rejected'];
    } else if (filterProvider.selectedType == 'Expenses' || filterProvider.selectedType == 'Transactions') {
      return ['All', 'Approved', 'Unapproved', 'Flagged', 'Rejected'];
    }
    return ['All', 'Approved', 'Unapproved', 'Accounted', 'Unaccounted', 'Flagged', 'Rejected'];
  }


  void _toggleSidebarCollapse() {
    setState(() {
      _isSidebarCollapsed = !_isSidebarCollapsed;
      if (_isSidebarCollapsed) {
        _usersExpanded = false;
        _walletExpanded = false;
        _accountExpanded = false;
        _expensesExpanded = false;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final isMobile = Responsive.isMobile(context);

    PreferredSizeWidget? appBar;
    if (isMobile) {
      Widget? leadingWidget;
      // Always show hamburger menu button on mobile
      leadingWidget = AnimatedBuilder(
        animation: _hamburgerRotationAnimation,
        builder: (context, child) {
          return Transform.rotate(
            angle: _hamburgerRotationAnimation.value * 0.5 * 3.14159, // 90 degrees rotation
            child: IconButton(
              icon: Icon(_isDrawerOpen ? Icons.close : Icons.menu),
              onPressed: () {
                setState(() {
                  _isDrawerOpen = !_isDrawerOpen;
                  if (_isDrawerOpen) {
                    _hamburgerAnimationController.forward();
                  } else {
                    _hamburgerAnimationController.reverse();
                  }
                });
              },
              tooltip: _isDrawerOpen ? 'Close menu' : 'Open menu',
            ),
          );
        },
      );

      appBar = AppBar(
        elevation: 0,
        leading: leadingWidget,
        centerTitle: false,
        titleSpacing: 0,
        title: Text(
          _getPageTitle(),
          style: const TextStyle(fontWeight: FontWeight.w600),
          overflow: TextOverflow.ellipsis,
          maxLines: 1,
        ),
        actions: _buildMobileHeaderActions(),
      );
    }

    // Provide FilterProvider locally for this screen instance
    // This ensures each screen has its own private filter state
    return ChangeNotifierProvider.value(
      value: _filterProvider,
      child: Scaffold(
      appBar: appBar,
      body: Stack(
        children: [
          Row(
        children: [
          // Sidebar Navigation (Desktop/Tablet only)
          if (!isMobile) _buildSidebar(isCollapsed: _isSidebarCollapsed),

          // Main Content
          Expanded(
            child: Column(
              children: [
                if (!isMobile) _buildDesktopTopBar(),
                Expanded(
                  child: _getContentForItem(_selectedItem),
                ),
              ],
                ),
              ),
            ],
          ),
          if (isMobile && _isDrawerOpen)
            GestureDetector(
              onTap: () {
                setState(() {
                  _isDrawerOpen = false;
                  _hamburgerAnimationController.reverse();
                });
              },
              child: Container(
                color: Colors.black.withOpacity(0.5),
              ),
            ),
          if (isMobile && _isDrawerOpen)
            Align(
              alignment: Alignment.centerLeft,
              child: SizedBox(
                width: MediaQuery.of(context).size.width * 0.8,
                child: _buildMobileDrawer(),
            ),
          ),
        ],
      ),
      ),
    );
  }

  Widget _buildDesktopTopBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        border: Border(
          bottom: BorderSide(color: AppTheme.borderColor),
        ),
      ),
      child: Row(
        children: [
          // Back button - ALWAYS show (even on dashboard)
          IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () {
              if (Navigator.canPop(context)) {
                Navigator.pop(context);
              } else {
                // If at root, navigate to dashboard if not already there
                if (_selectedItem != NavItem.dashboard) {
                  setState(() {
                    _selectedItem = NavItem.dashboard;
                  });
                }
              }
            },
            tooltip: 'Back',
          ),
          const SizedBox(width: 12),
          // Title - Now shows "Welcome, [Name]!" for dashboard
          Expanded(
            child: Text(
              _getPageTitle(),
              style: AppTheme.headingMedium.copyWith(
                fontWeight: FontWeight.w600,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 12),
          ..._buildHeaderActions(isCompact: false),
        ],
      ),
    );
  }

  /// Builds optimized header actions for mobile view
  /// Uses icon-only buttons for better space utilization
  List<Widget> _buildMobileHeaderActions() {
    final Color progressColor = Theme.of(context).colorScheme.onPrimary;
    const double spacing = 8.0;

    return [
      // Quick Actions as icon-only button (only if permission enabled)
      if (_canEnableQuickActions)
        IconButton(
          icon: const Icon(Icons.bolt),
          onPressed: () => _showQuickActionsMenu(context, true, true),
          tooltip: 'Quick Actions',
        ),
      if (_canEnableQuickActions) SizedBox(width: spacing),
      // Refresh button (always visible for quick access)
      IconButton(
        icon: _isRefreshing
            ? SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(progressColor),
                ),
              )
            : const Icon(Icons.refresh),
        onPressed: _isRefreshing ? null : () => _refreshDashboardAndFinancialData(),
        tooltip: 'Refresh',
      ),
      SizedBox(width: spacing),
      // Logout as icon button (directly accessible)
      IconButton(
        icon: const Icon(Icons.logout),
        onPressed: _handleLogout,
        tooltip: 'Logout',
      ),
    ];
  }

  List<Widget> _buildHeaderActions({required bool isCompact}) {
    final double spacing = isCompact ? 8 : 12;
    final EdgeInsets buttonPadding = EdgeInsets.symmetric(
      horizontal: isCompact ? 12 : 16,
      vertical: isCompact ? 10 : 12,
    );
    final Color progressColor = isCompact
        ? Theme.of(context).colorScheme.onPrimary
        : AppTheme.primaryColor;

    return [
      // Quick Actions button (only if permission enabled)
      if (_canEnableQuickActions)
        ElevatedButton.icon(
          onPressed: () => _showQuickActionsMenu(context, isCompact, isCompact),
          icon: const Icon(Icons.bolt, size: 18),
          label: const Text('Quick Actions'),
          style: ElevatedButton.styleFrom(
            backgroundColor: AppTheme.primaryColor,
            foregroundColor: Colors.white,
            padding: buttonPadding,
          ),
        ),
      if (_canEnableQuickActions) SizedBox(width: spacing),
      SizedBox(width: spacing),
      IconButton(
        icon: _isRefreshing
            ? SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(progressColor),
                ),
              )
            : const Icon(Icons.refresh),
        onPressed: _isRefreshing ? null : () => _refreshDashboardAndFinancialData(),
        tooltip: 'Refresh',
      ),
      SizedBox(width: spacing),
      IconButton(
        icon: const Icon(Icons.logout),
        onPressed: _handleLogout,
        tooltip: 'Logout',
      ),
    ];
  }

  Future<void> _handleLogout() async {
    if (!mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => const Center(
        child: CircularProgressIndicator(),
      ),
    );

    try {
      await AuthService.logout();
      if (!mounted) {
        return;
      }
      Navigator.of(context).pop(); // Close loading dialog
      context.go('/login');
    } catch (e) {
      if (!mounted) {
        return;
      }
      Navigator.of(context).pop(); // Close loading dialog
      context.go('/login');
    }
  }

  String _getPageTitle() {
    final item = _selectedItem;

    // For dashboard, show welcome message with user name
    if (item == NavItem.dashboard) {
      final userName = _dashboardUserName ?? 'User';
      return 'Welcome, $userName!';
    }

    if (item == NavItem.walletSelf) return 'My Wallet';
    if (item == NavItem.walletAll) return 'All User Wallets';
    if (item == NavItem.walletOverview) return 'All Wallet Report';
    if (item == NavItem.transactionCollection) return 'Collections';
    if (item == NavItem.transactionTransfer) return 'Transfer';
    if (item == NavItem.transactionExpense) return 'Expenses';
    if (item == NavItem.transactionTransactions) return 'Transactions';
    if (item == NavItem.users) return 'User Management';
    if (item == NavItem.roles) return 'Roles';
    if (item == NavItem.accountReports) return 'Account Reports';
    if (item == NavItem.paymentModes) return 'Payment Mode';
    if (item == NavItem.expenseType) return 'Expenses Type';
    if (item == NavItem.expenseReport) return 'Expense Report';
    if (item == NavItem.smartApprovals) return 'Smart Approvals';
    if (item == NavItem.collectionCustomField) return 'Collection Custom Field';

    return 'Dashboard';
  }

  /// Get route path for a given NavItem
  String _getRoutePathForNavItem(NavItem item, {String? userId, String? userLabel}) {
    switch (item) {
      case NavItem.dashboard:
        return '/dashboard';
      case NavItem.walletSelf:
        return '/wallet/self';
      case NavItem.walletAll:
        return '/wallet/all';
      case NavItem.walletOverview:
        if (userId != null || userLabel != null) {
          final uri = Uri(
            path: '/wallet/overview',
            queryParameters: {
              if (userId != null) 'userId': userId,
              if (userLabel != null) 'userLabel': userLabel,
            },
          );
          return uri.toString();
        }
        return '/wallet/overview';
      case NavItem.transactionCollection:
        return '/transactions/collections';
      case NavItem.transactionTransfer:
        return '/transactions/transfer';
      case NavItem.transactionExpense:
        return '/transactions/expense';
      case NavItem.transactionTransactions:
        return '/transactions/all';
      case NavItem.users:
        return '/users';
      case NavItem.roles:
        return '/roles';
      case NavItem.assignWallets:
        return '/users/assign-wallets';
      case NavItem.accountReports:
        return '/reports/accounts';
      case NavItem.paymentModes:
        return '/payment-modes';
      case NavItem.expenseType:
        return '/expenses/types';
      case NavItem.expenseReport:
        return '/reports/expenses';
      case NavItem.smartApprovals:
        return '/approvals/smart';
      case NavItem.collectionCustomField:
        return '/settings/collection-custom-field';
    }
  }

  /// Navigate to a route based on NavItem
  void _navigateToRoute(NavItem item, {String? userId, String? userLabel}) {
    if (!mounted) return;
    
    // Get FilterProvider for filter management
    final filterProvider = _filterProvider;
    
    // Determine screen types for filter clearing logic
    final bool isCurrentWalletScreen = _selectedItem == NavItem.walletSelf || 
                                       _selectedItem == NavItem.walletAll || 
                                       _selectedItem == NavItem.walletOverview;
    final bool isTargetWalletScreen = item == NavItem.walletSelf || 
                                      item == NavItem.walletAll || 
                                      item == NavItem.walletOverview;
    
    // Clear filters when navigating to different screen types
    // This ensures filters from one screen don't apply to unrelated screens
    if (_selectedItem != item) {
      // Temporarily remove listener to prevent infinite loop when modifying filters during navigation
      filterProvider.removeListener(_onFilterChanged);
      
      // If navigating TO dashboard, clear all filters
      if (item == NavItem.dashboard) {
        filterProvider.clearAllFilters();
        _selectedStatusSet.clear();
        if (_selectedExpenseTypeCategory != null || _isExpenseReportMode) {
          setState(() {
            _selectedExpenseTypeCategory = null;
            _isExpenseReportMode = false;
          });
        }
      }
      // If navigating FROM wallet screens to non-wallet screens (except dashboard), clear wallet filters
      else if (isCurrentWalletScreen && !isTargetWalletScreen && item != NavItem.dashboard) {
        filterProvider.clearDateRange();
        filterProvider.setMode(null);
        filterProvider.setType(null);
        filterProvider.setStatus(null);
        _selectedStatusSet.clear();
        // Clear user filters unless explicitly navigating to walletOverview with user
        if (item != NavItem.walletOverview || (userId == null && userLabel == null)) {
          filterProvider.clearUserFilter();
          _selectedUserLabelMatchers.clear();
        }
      }
      // If navigating FROM non-wallet screens to wallet screens without explicit user, clear user filters
      else if (!isCurrentWalletScreen && isTargetWalletScreen && userId == null && userLabel == null) {
        filterProvider.clearUserFilter();
        _selectedUserLabelMatchers.clear();
      }
      
      // Re-add listener after modifications
      filterProvider.addListener(_onFilterChanged);
    }
    
    // Check if currently in expense report mode and navigating away from it
    final bool isCurrentlyExpenseReport = _selectedItem == NavItem.expenseReport;
    final bool isNavigatingToExpenseReport = item == NavItem.expenseReport;
    final bool isNavigatingAwayFromExpenseReport = isCurrentlyExpenseReport && item != NavItem.expenseReport;
    final bool hasExpenseReportFilters = _selectedExpenseTypeCategory != null || _isExpenseReportMode;
    
    // If navigating TO expense report, set expense report mode and reload data
    if (isNavigatingToExpenseReport && !isCurrentlyExpenseReport) {
      setState(() {
        _isExpenseReportMode = true;
      });
      // Clear status filter to show ALL expenses including Flagged by default
      filterProvider.setStatus(null);
      _selectedStatusSet.clear();
      // Reload data with expense report mode enabled
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          _loadFinancialData(forceRefresh: true, isSelfWallet: false);
        }
      });
    }
    
    // If navigating TO Account Reports, clear account filter (show all accounts by default)
    final bool isNavigatingToAccountReports = item == NavItem.accountReports;
    final bool isCurrentlyAccountReports = _selectedItem == NavItem.accountReports;
    final bool isNavigatingAwayFromAccountReports = isCurrentlyAccountReports && item != NavItem.accountReports;
    
    if (isNavigatingToAccountReports && !isCurrentlyAccountReports) {
      setState(() {
        _selectedAccountFilterId = null; // Clear filter - show all accounts by default
        _accountReportsDataLoaded = false; // Reset to allow fresh data load
        _accountReportsInitialized = false; // Reset initialization flag
        _isInitializingAccountReports = false; // Reset initialization flag
        _accountReportsCallbackScheduled = false; // Reset callback scheduled flag
      });
      // Clear status filter to show ALL expenses including Flagged by default
      filterProvider.setStatus(null);
      _selectedStatusSet.clear();
      debugPrint('üìä [ACCOUNT REPORTS] Navigating to Account Reports - cleared filter (showing all accounts and all statuses including Flagged)');
    }
    
    // If navigating AWAY from Account Reports, reset initialization flags
    if (isNavigatingAwayFromAccountReports) {
      setState(() {
        _accountReportsInitialized = false;
        _isInitializingAccountReports = false;
        _accountReportsCallbackScheduled = false; // Reset callback scheduled flag
      });
    }
    
    // If navigating TO Wallet Overview, ensure status filter is cleared to show all including Flagged
    final bool isNavigatingToWalletOverview = item == NavItem.walletOverview;
    final bool isCurrentlyWalletOverview = _selectedItem == NavItem.walletOverview;
    if (isNavigatingToWalletOverview && !isCurrentlyWalletOverview && userId == null && userLabel == null) {
      // Clear status filter when opening Wallet Overview without specific user filter
      // This ensures all expenses including Flagged are shown by default
      filterProvider.setStatus(null);
      _selectedStatusSet.clear();
    }
    
    // If leaving expense report, clear expense report specific filters
    // Note: General filter clearing above already handles FilterProvider filters
    // This handles expense report specific local state
    if (isNavigatingAwayFromExpenseReport && hasExpenseReportFilters) {
      // Clear expense report specific local state
      setState(() {
        _selectedExpenseTypeCategory = null;
        _isExpenseReportMode = false;
      });
    }
    
    // Auto-refresh removed - refresh only occurs on socket events (when changes happen)
    
    // Navigate to the target
    final path = _getRoutePathForNavItem(item, userId: userId, userLabel: userLabel);
    context.go(path);
  }

  void _handleNavSelection(NavItem target) {
    if (!mounted) return;
    
    // Navigate to the target - filter clearing logic is handled in _navigateToRoute
    if (_selectedItem != target) {
      _navigateToRoute(target);
    }
    
    // Load dashboard data if switching to self wallet
    if (target == NavItem.walletSelf) {
      _loadDashboardData();
      _refreshSelfWalletView(force: true); // Fire and forget
    }
  }

  Widget _buildSidebar({required bool isCollapsed}) {
    final double targetWidth =
        isCollapsed ? _sidebarCollapsedWidth : _sidebarExpandedWidth;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 240),
      width: targetWidth,
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor,
        border: Border(
          right: BorderSide(color: AppTheme.borderColor),
        ),
      ),
      child: Column(
        children: [
          _buildSidebarHeader(isCollapsed),
          Expanded(
            child: isCollapsed
                ? _buildCollapsedSidebarContent()
                : _buildExpandedSidebarContent(),
          ),
        ],
      ),
    );
  }

  Widget _buildSidebarHeader(bool isCollapsed) {
    final Color iconBackground =
        AppTheme.primaryColor.withValues(alpha: 0.1);

    if (isCollapsed) {
      return Container(
        height: 108,
        decoration: BoxDecoration(
          border: Border(bottom: BorderSide(color: AppTheme.borderColor)),
        ),
        child: Center(
          child: Tooltip(
            message: 'Expand sidebar',
            child: Container(
              decoration: BoxDecoration(
                color: AppTheme.primaryColor.withValues(alpha: 0.08),
                borderRadius: BorderRadius.circular(12),
              ),
              child: IconButton(
                icon: const Icon(Icons.menu),
                color: AppTheme.textSecondary,
                onPressed: _toggleSidebarCollapse,
              ),
            ),
          ),
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),
      decoration: BoxDecoration(
        border: Border(bottom: BorderSide(color: AppTheme.borderColor)),
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
              color: iconBackground,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                  Icons.admin_panel_settings,
                    color: AppTheme.primaryColor,
                    size: 28,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                  _userName ?? 'Super Admin',
                        style: AppTheme.headingSmall.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                        'Financial Management',
                        style: AppTheme.bodySmall.copyWith(
                          color: AppTheme.textSecondary,
                        ),
                      ),
                    ],
                  ),
                ),
          Tooltip(
            message: 'Collapse sidebar',
            child: IconButton(
              icon: const Icon(Icons.close_fullscreen),
              color: AppTheme.textSecondary,
              onPressed: _toggleSidebarCollapse,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildExpandedSidebarContent() {
    // Build menu items list based on permissions
    final List<Widget> menuItems = [];
    
    // Dashboard - only show if user has permission AND is not non-wallet user
    if (_canViewDashboard && !_isNonWalletUser) {
      menuItems.add(
        _buildNavItem(
          icon: Icons.dashboard_outlined,
          title: SuperAdminMenuNames.dashboard,
          isSelected: _selectedItem == NavItem.dashboard,
          onTap: () => _navigateToRoute(NavItem.dashboard),
        ),
      );
    }
    
    // Wallet menu - show if user has any wallet permission
    if (_canViewWalletMenu) {
      final List<Widget> walletChildren = [];
      
      // Debug logging for menu item visibility
      debugPrint('üîç [MENU] Building Wallet menu - _canViewWalletMenu=$_canViewWalletMenu');
      debugPrint('üîç [MENU] Wallet menu children visibility:');
      debugPrint('   _canViewWalletSelf=$_canViewWalletSelf');
      debugPrint('   _canViewWalletAll=$_canViewWalletAll');
      debugPrint('   _canViewWalletOverview=$_canViewWalletOverview');
      
      // My Wallet - only show if user has permission AND is not non-wallet user
      if (_canViewWalletSelf && !_isNonWalletUser) {
        walletChildren.add(
          _buildSubNavItem(
            title: SuperAdminMenuNames.walletSelf,
            isSelected: _selectedItem == NavItem.walletSelf,
            onTap: () => _handleNavSelection(NavItem.walletSelf),
          ),
        );
      }
      if (_canViewWalletAll) {
        walletChildren.add(
          _buildSubNavItem(
            title: 'All User Wallets',
            isSelected: _selectedItem == NavItem.walletAll,
            onTap: () => _navigateToRoute(NavItem.walletAll),
          ),
        );
      }
      if (_canViewWalletOverview) {
        debugPrint('‚úÖ [MENU] Adding All Wallet Report menu item');
        walletChildren.add(
          _buildSubNavItem(
            title: 'All Wallet Report',
            isSelected: _selectedItem == NavItem.walletOverview,
            onTap: () {
              _navigateToRoute(NavItem.walletOverview);
              // Force refresh when switching to All Wallet Report to apply current filters
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted) {
                  _loadFinancialData(forceRefresh: true, isSelfWallet: false);
                }
              });
            },
          ),
        );
      } else {
        debugPrint('‚ùå [MENU] All Wallet Report menu item NOT added - _canViewWalletOverview=false');
      }
      
      // Only show wallet menu if at least one child is visible
      if (walletChildren.isNotEmpty) {
        menuItems.add(
          _buildExpandableNavItem(
            icon: Icons.account_balance_wallet_outlined,
            title: 'Wallet',
            isExpanded: _walletExpanded,
            hasSelectedChild: _selectedItem.toString().startsWith('NavItem.wallet'),
            onTap: () {
              setState(() {
                _walletExpanded = true;
              });
            },
            children: walletChildren,
          ),
        );
      }
    }
    
    // Smart Approvals
    if (_canViewSmartApprovals) {
      menuItems.add(
        _buildNavItem(
          icon: Icons.hourglass_bottom,
          title: 'Smart Approvals',
          isSelected: _selectedItem == NavItem.smartApprovals,
          badge: _pendingCollections + _pendingTransactions + _pendingExpenses > 0
              ? _pendingCollections + _pendingTransactions + _pendingExpenses
              : null,
          onTap: () => _navigateToRoute(NavItem.smartApprovals),
        ),
      );
    }
    
    // All Users menu - show if user has any user management permission
    if (_canViewUsersMenu) {
      final List<Widget> usersChildren = [];
      if (_canViewUsers) {
        usersChildren.add(
          _buildSubNavItem(
            title: 'User Management',
            isSelected: _selectedItem == NavItem.users,
            onTap: () {
              setState(() {
                _usersExpanded = true;
              });
              _navigateToRoute(NavItem.users);
            },
          ),
        );
      }
      if (_canViewRoles) {
        usersChildren.add(
          _buildSubNavItem(
            title: 'Roles',
            isSelected: _selectedItem == NavItem.roles,
            onTap: () {
              setState(() {
                _usersExpanded = true;
              });
              _navigateToRoute(NavItem.roles);
            },
          ),
        );
      }
      usersChildren.add(
        _buildSubNavItem(
          title: 'Assign Wallets',
          isSelected: _selectedItem == NavItem.assignWallets,
          onTap: () {
            setState(() {
              _usersExpanded = true;
            });
            _navigateToRoute(NavItem.assignWallets);
          },
        ),
      );
      
      // Only show users menu if at least one child is visible
      if (usersChildren.isNotEmpty) {
        menuItems.add(
          _buildExpandableNavItem(
            icon: Icons.people_outlined,
            title: 'All Users',
            isExpanded: _usersExpanded,
            hasSelectedChild:
                _selectedItem == NavItem.users || 
                _selectedItem == NavItem.roles ||
                _selectedItem == NavItem.assignWallets,
            onTap: () {
              setState(() {
                _usersExpanded = true;
              });
            },
            children: usersChildren,
          ),
        );
      }
    }
    
    // Payment Accounts menu - show if user has any payment account permission
    if (_canViewPaymentAccountsMenu) {
      final List<Widget> accountChildren = [];
      if (_canViewPaymentModes) {
        accountChildren.add(
          _buildSubNavItem(
            title: 'Payment Mode',
            isSelected: _selectedItem == NavItem.paymentModes,
            onTap: () {
              setState(() {
                _accountExpanded = true;
              });
              _navigateToRoute(NavItem.paymentModes);
            },
          ),
        );
      }
      if (_canViewAccountReports) {
        accountChildren.add(
          _buildSubNavItem(
            title: 'Account Reports',
            isSelected: _selectedItem == NavItem.accountReports,
            onTap: () {
              setState(() {
                _accountExpanded = true;
              });
              _navigateToRoute(NavItem.accountReports);
              // Load accounts immediately when Account Reports is selected
              if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
                _loadAccountsList();
              }
            },
          ),
        );
      }
      
      // Only show payment accounts menu if at least one child is visible
      if (accountChildren.isNotEmpty) {
        menuItems.add(
          _buildExpandableNavItem(
            icon: Icons.account_circle_outlined,
            title: 'Payment Accounts',
            isExpanded: _accountExpanded,
            hasSelectedChild:
                _selectedItem == NavItem.accountReports ||
                _selectedItem == NavItem.paymentModes,
            onTap: () {
              setState(() {
                _accountExpanded = true;
              });
            },
            children: accountChildren,
          ),
        );
      }
    }
    
    // Expenses menu - show if user has any expense permission
    if (_canViewExpensesMenu) {
      final List<Widget> expenseChildren = [];
      if (_canViewExpenseType) {
        expenseChildren.add(
          _buildSubNavItem(
            title: 'Expenses Type',
            isSelected: _selectedItem == NavItem.expenseType,
            onTap: () {
              setState(() {
                _expensesExpanded = true;
              });
              _navigateToRoute(NavItem.expenseType);
            },
          ),
        );
      }
      if (_canViewExpenseReport) {
        expenseChildren.add(
          _buildSubNavItem(
            title: 'Expense Report',
            isSelected: _selectedItem == NavItem.expenseReport,
            onTap: () {
              setState(() {
                _expensesExpanded = true;
              });
              _navigateToRoute(NavItem.expenseReport);
            },
          ),
        );
      }
      
      // Only show expenses menu if at least one child is visible
      if (expenseChildren.isNotEmpty) {
        menuItems.add(
          _buildExpandableNavItem(
            icon: Icons.receipt_long_outlined,
            title: 'Expenses',
            isExpanded: _expensesExpanded,
            hasSelectedChild:
                _selectedItem == NavItem.transactionExpense ||
                _selectedItem == NavItem.expenseType ||
                _selectedItem == NavItem.expenseReport,
            onTap: () {
              setState(() {
                _expensesExpanded = true;
              });
            },
            children: expenseChildren,
          ),
        );
      }
    }
    
    // Settings menu
    if (_canViewSettingsMenu) {
    final List<Widget> settingsChildren = [];
    settingsChildren.add(
      _buildSubNavItem(
        title: 'Collection',
          isSelected: _selectedItem == NavItem.collectionCustomField,
        onTap: () {
          setState(() {
            _settingsExpanded = true;
          });
            _navigateToRoute(NavItem.collectionCustomField);
        },
      ),
    );
    
    menuItems.add(
      _buildExpandableNavItem(
        icon: Icons.settings_outlined,
        title: 'Settings',
        isExpanded: _settingsExpanded,
          hasSelectedChild: _selectedItem == NavItem.collectionCustomField,
        onTap: () {
          setState(() {
            _settingsExpanded = true;
          });
        },
        children: settingsChildren,
      ),
    );
    }
    
    return Column(
      children: [
        Expanded(
          child: ListView(
            padding: const EdgeInsets.symmetric(vertical: 8),
            children: menuItems,
          ),
        ),
        _buildSidebarFooter(isCollapsed: false),
      ],
    );
  }

  Widget _buildCollapsedSidebarContent() {
    final int pendingTotal = _pendingCollections + _pendingTransactions + _pendingExpenses;
    
    // Build menu items list based on permissions
    final List<Widget> menuItems = [];
    
    // Dashboard
    if (_canViewDashboard) {
      menuItems.add(
        _buildCollapsedNavIcon(
          icon: Icons.dashboard_outlined,
          label: 'Dashboard',
          isSelected: _selectedItem == NavItem.dashboard,
          onTap: () => _navigateToRoute(NavItem.dashboard),
        ),
      );
    }
    
    // Wallet menu
    if (_canViewWalletMenu) {
      final List<_CollapsedMenuOption> walletOptions = [];
      if (_canViewWalletSelf) {
        walletOptions.add(
          _CollapsedMenuOption(
            id: 'walletSelf',
            label: 'Self Wallet',
            isSelected: _selectedItem == NavItem.walletSelf,
            onSelected: () => _handleNavSelection(NavItem.walletSelf),
          ),
        );
      }
      if (_canViewWalletAll) {
        walletOptions.add(
          _CollapsedMenuOption(
            id: 'walletAll',
            label: 'All User Wallets',
            isSelected: _selectedItem == NavItem.walletAll,
            onSelected: () => _navigateToRoute(NavItem.walletAll),
          ),
        );
      }
      if (_canViewWalletOverview) {
        walletOptions.add(
          _CollapsedMenuOption(
            id: 'walletOverview',
            label: 'All Wallet Report',
            isSelected: _selectedItem == NavItem.walletOverview,
            onSelected: () {
              _navigateToRoute(NavItem.walletOverview);
              // Force refresh when switching to All Wallet Report to apply current filters
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted) {
                  _loadFinancialData(forceRefresh: true, isSelfWallet: false);
                }
              });
            },
          ),
        );
      }
      
      if (walletOptions.isNotEmpty) {
        menuItems.add(
          _buildCollapsedMenuGroup(
            icon: Icons.account_balance_wallet_outlined,
            label: 'Wallet',
            isActive: _selectedItem.toString().startsWith('NavItem.wallet'),
            options: walletOptions,
          ),
        );
      }
    }
    
    // Smart Approvals
    if (_canViewSmartApprovals) {
      menuItems.add(
        _buildCollapsedNavIcon(
          icon: Icons.hourglass_bottom,
          label: 'Smart Approvals',
          isSelected: _selectedItem == NavItem.smartApprovals,
          badge: pendingTotal > 0 ? pendingTotal : null,
          onTap: () => _navigateToRoute(NavItem.smartApprovals),
        ),
      );
    }
    
    // All Users menu
    if (_canViewUsersMenu) {
      final List<_CollapsedMenuOption> usersOptions = [];
      if (_canViewUsers) {
        usersOptions.add(
          _CollapsedMenuOption(
            id: 'users',
            label: 'User Management',
            isSelected: _selectedItem == NavItem.users,
            onSelected: () => _navigateToRoute(NavItem.users),
          ),
        );
      }
      if (_canViewRoles) {
        usersOptions.add(
          _CollapsedMenuOption(
            id: 'roles',
            label: 'Roles',
            isSelected: _selectedItem == NavItem.roles,
            onSelected: () => _navigateToRoute(NavItem.roles),
          ),
        );
      }
      usersOptions.add(
        _CollapsedMenuOption(
          id: 'assignWallets',
          label: 'Assign Wallets',
          isSelected: _selectedItem == NavItem.assignWallets,
          onSelected: () => _navigateToRoute(NavItem.assignWallets),
        ),
      );
      
      if (usersOptions.isNotEmpty) {
        menuItems.add(
          _buildCollapsedMenuGroup(
            icon: Icons.people_outlined,
            label: 'All Users',
            isActive: _selectedItem == NavItem.users || 
                     _selectedItem == NavItem.roles ||
                     _selectedItem == NavItem.assignWallets,
            options: usersOptions,
          ),
        );
      }
    }
    
    // Payment Accounts menu
    if (_canViewPaymentAccountsMenu) {
      final List<_CollapsedMenuOption> accountOptions = [];
      if (_canViewPaymentModes) {
        accountOptions.add(
          _CollapsedMenuOption(
            id: 'paymentModes',
            label: 'Payment Mode',
            isSelected: _selectedItem == NavItem.paymentModes,
            onSelected: () => _navigateToRoute(NavItem.paymentModes),
          ),
        );
      }
      if (_canViewAccountReports) {
        accountOptions.add(
          _CollapsedMenuOption(
            id: 'accountReports',
            label: 'Account Reports',
            isSelected: _selectedItem == NavItem.accountReports,
            onSelected: () {
              _navigateToRoute(NavItem.accountReports);
              // Load accounts immediately when Account Reports is selected
              if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
                _loadAccountsList();
              }
            },
          ),
        );
      }
      
      if (accountOptions.isNotEmpty) {
        menuItems.add(
          _buildCollapsedMenuGroup(
            icon: Icons.account_circle_outlined,
            label: 'Payment Accounts',
            isActive: _selectedItem == NavItem.accountReports ||
                     _selectedItem == NavItem.paymentModes,
            options: accountOptions,
          ),
        );
      }
    }
    
    // Expenses menu
    if (_canViewExpensesMenu) {
      final List<_CollapsedMenuOption> expenseOptions = [];
      if (_canViewExpenseType) {
        expenseOptions.add(
          _CollapsedMenuOption(
            id: 'expenseType',
            label: 'Expenses Type',
            isSelected: _selectedItem == NavItem.expenseType,
            onSelected: () => _navigateToRoute(NavItem.expenseType),
          ),
        );
      }
      if (_canViewExpenseReport) {
        expenseOptions.add(
          _CollapsedMenuOption(
            id: 'expenseReport',
            label: 'Expense Report',
            isSelected: _selectedItem == NavItem.expenseReport,
            onSelected: () => _navigateToRoute(NavItem.expenseReport),
          ),
        );
      }
      
      if (expenseOptions.isNotEmpty) {
        menuItems.add(
          _buildCollapsedMenuGroup(
            icon: Icons.receipt_long_outlined,
            label: 'Expenses',
            isActive: _selectedItem == NavItem.transactionExpense ||
                     _selectedItem == NavItem.expenseType ||
                     _selectedItem == NavItem.expenseReport,
            options: expenseOptions,
          ),
        );
      }
    }
    
    // Settings menu
    if (_canViewSettingsMenu) {
    final List<_CollapsedMenuOption> settingsOptions = [];
    settingsOptions.add(
      _CollapsedMenuOption(
        id: 'collection',
        label: 'Collection',
          isSelected: _selectedItem == NavItem.collectionCustomField,
          onSelected: () => _navigateToRoute(NavItem.collectionCustomField),
      ),
    );
    
    menuItems.add(
      _buildCollapsedMenuGroup(
        icon: Icons.settings_outlined,
        label: 'Settings',
          isActive: _selectedItem == NavItem.collectionCustomField,
        options: settingsOptions,
      ),
    );
    }

    return Column(
      children: [
        Expanded(
          child: ListView(
            padding: const EdgeInsets.symmetric(vertical: 12),
            children: menuItems,
          ),
        ),
        _buildSidebarFooter(isCollapsed: true),
      ],
    );
  }

  Widget _buildSidebarFooter({required bool isCollapsed}) {
    return Padding(
      padding: EdgeInsets.fromLTRB(
        isCollapsed ? 12 : 24,
        12,
        isCollapsed ? 12 : 24,
        24,
      ),
      child: isCollapsed
          ? _buildCollapsedBrandingIcon()
          : _buildStaticBrandingWidget(),
    );
  }

  Widget _buildCollapsedBrandingIcon() {
    return Tooltip(
      message: 'Powered by Blumdata',
        child: Container(
              width: 48,
              height: 48,
          decoration: BoxDecoration(
          gradient: const LinearGradient(
            colors: [
              Colors.white, // White
              Color(0xFFF9FAFB), // Slightly off-white for subtle gradient
            ],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                borderRadius: BorderRadius.circular(24),
                border: Border.all(
                  color: AppTheme.accentBlue.withValues(alpha: 0.3),
                  width: 1.5,
                ),
            boxShadow: [
              BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 8,
              offset: const Offset(0, 2),
              ),
            ],
          ),
        child: Center(
                      child: _buildLogoIcon(),
        ),
      ),
    );
  }

  Widget _buildStaticBrandingWidget() {
    return Container(
            padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 12),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(
                color: AppTheme.accentBlue.withValues(alpha: 0.3),
                width: 1.5,
              ),
              boxShadow: [
                BoxShadow(
                  color: AppTheme.accentBlue.withValues(alpha: 0.1),
                  blurRadius: 12,
                  offset: const Offset(0, 4),
                  spreadRadius: 0,
                ),
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 8,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
      child: _buildBrandingLabel(),
    );
  }

  Widget _buildLogoIcon() {
    return Container(
      width: 24,
      height: 24,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Image.asset(
        'images/blumdata_logo.png',
        width: 24,
        height: 24,
        fit: BoxFit.contain,
        errorBuilder: (context, error, stackTrace) {
          // Fallback icon if image is not found
          return Container(
            color: Colors.white,
            child: Icon(
              Icons.star,
              color: AppTheme.accentBlue,
              size: 24,
            ),
          );
        },
      ),
    );
  }

  Widget _buildBrandingLabel() {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        // "Powered by " text
        Text(
          'Powered by ',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: Colors.black,
            letterSpacing: 0.2,
          ),
        ),
        // Image (blumdata_logo.png)
        Image.asset(
          'images/blumdata_logo.png',
          width: 20,
          height: 20,
          fit: BoxFit.contain,
          errorBuilder: (context, error, stackTrace) {
            // Fallback icon if image is not found
            return Icon(
              Icons.account_tree,
              color: Color(0xFFD4AF37), // Golden fallback
              size: 20,
            );
          },
        ),
        const SizedBox(width: 6),
        // Clickable "Blumdata" text
        InkWell(
          onTap: () => _openBlumdataWebsite(),
          child: Text(
            'Blumdata',
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: AppTheme.accentBlue, // Blue
              letterSpacing: 0.2,
              decoration: TextDecoration.underline,
              decorationColor: AppTheme.accentBlue,
            ),
          ),
        ),
      ],
    );
  }

  Future<void> _openBlumdataWebsite() async {
    final urlString = 'https://www.blumdata.com/';
    final url = Uri.parse(urlString);
    
    try {
      // Try to launch URL using url_launcher
      final launched = await launchUrl(
        url,
        mode: kIsWeb 
            ? LaunchMode.platformDefault 
            : LaunchMode.externalApplication,
      );
      
      if (!launched && mounted) {
        _showUrlDialog(urlString);
      }
    } catch (e) {
      // If url_launcher fails (missing plugin), show URL in dialog
      if (mounted) {
        _showUrlDialog(urlString);
      }
    }
  }

  void _showWalletUpdateNotification(String operation, Map<String, dynamic> data) {
    if (!mounted) return;
    
    String message = '';
    Color color = Colors.blue;
    
    switch (operation) {
      case 'expense_approved':
        final amount = (data['expense']?['amount'] as num?)?.toDouble() ?? 
                       (data['cashOut'] as num?)?.toDouble() ?? 0.0;
        message = 'Expense approved: ‚Çπ${amount.toStringAsFixed(2)} deducted';
        color = Colors.red;
        break;
      case 'transaction_received':
        final amount = (data['transaction']?['amount'] as num?)?.toDouble() ?? 
                       (data['cashIn'] as num?)?.toDouble() ?? 0.0;
        message = 'Received: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.green;
        break;
      case 'transaction_sent':
        final amount = (data['transaction']?['amount'] as num?)?.toDouble() ?? 
                       (data['cashOut'] as num?)?.toDouble() ?? 0.0;
        message = 'Sent: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.orange;
        break;
      case 'collection_received':
        final amount = (data['collection']?['amount'] as num?)?.toDouble() ?? 
                       (data['cashIn'] as num?)?.toDouble() ?? 0.0;
        message = 'Collection received: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.green;
        break;
      case 'wallet_add':
        final amount = (data['transaction']?['amount'] as num?)?.toDouble() ?? 0.0;
        message = 'Amount added: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.green;
        break;
      case 'wallet_withdraw':
        final amount = (data['transaction']?['amount'] as num?)?.toDouble() ?? 0.0;
        message = 'Amount withdrawn: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.orange;
        break;
      case 'collection_created':
        final amount = (data['collection']?['amount'] as num?)?.toDouble() ?? 0.0;
        message = 'Collection created: ‚Çπ${amount.toStringAsFixed(2)}';
        color = Colors.blue;
        break;
      default:
        message = 'Wallet updated';
    }
    
    // Show snackbar
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: color,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  void _showComingSoonMessage(String featureName) {
    if (!mounted) return;
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$featureName - Coming Soon'),
        backgroundColor: AppTheme.secondaryColor,
        duration: const Duration(seconds: 2),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  void _showUrlDialog(String url) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text('Open Website'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Please visit:'),
            SizedBox(height: 8),
            SelectableText(
              url,
              style: TextStyle(
                color: AppTheme.primaryColor,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(),
            child: Text('Close'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(dialogContext).pop();
              // Copy URL to clipboard
              Clipboard.setData(ClipboardData(text: url));
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('URL copied to clipboard'),
                  backgroundColor: AppTheme.secondaryColor,
                ),
              );
            },
            child: Text('Copy URL'),
          ),
        ],
      ),
    );
  }

  Widget _buildCollapsedNavIcon({
    required IconData icon,
    required String label,
    required bool isSelected,
    int? badge,
    required VoidCallback onTap,
  }) {
    return Tooltip(
      message: label,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(12),
            child: _buildCollapsedIconSurface(
              icon: icon,
              isSelected: isSelected,
              badge: badge,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildCollapsedMenuGroup({
    required IconData icon,
    required String label,
    required bool isActive,
    required List<_CollapsedMenuOption> options,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: Tooltip(
        message: label,
        child: PopupMenuButton<String>(
          offset: const Offset(0, 46),
          elevation: 8,
          shadowColor: Colors.black.withOpacity(0.08),
          surfaceTintColor: Colors.transparent,
          color: AppTheme.surfaceColor,
          constraints: const BoxConstraints(minWidth: 180),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          onSelected: (value) {
            for (final option in options) {
              if (option.id == value) {
                option.onSelected();
                break;
              }
            }
          },
          itemBuilder: (context) {
            return options.map<PopupMenuEntry<String>>((option) {
              final bool isSelected = option.isSelected;

              return PopupMenuItem<String>(
                value: option.id,
                padding: EdgeInsets.zero,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? AppTheme.primaryColor.withValues(alpha: 0.08)
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Row(
                    children: [
                      _buildPopupSelectionIndicator(isSelected),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          option.label,
                          style: AppTheme.bodyMedium.copyWith(
                            fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                            color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            }).toList();
          },
          child: _buildCollapsedIconSurface(
            icon: icon,
            isSelected: isActive,
          ),
        ),
      ),
    );
  }

  Widget _buildCollapsedIconSurface({
    required IconData icon,
    required bool isSelected,
    int? badge,
  }) {
    final Color iconColor =
        isSelected ? AppTheme.primaryColor : AppTheme.textSecondary;

    return Ink(
      decoration: BoxDecoration(
        color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.1) : Colors.transparent,
        borderRadius: BorderRadius.circular(12),
      ),
      child: SizedBox(
        height: 48,
        width: double.infinity,
        child: Center(
          child: Stack(
            clipBehavior: Clip.none,
            alignment: Alignment.center,
            children: [
              Icon(
                icon,
                color: iconColor,
                size: 24,
              ),
              if (badge != null && badge > 0)
                Positioned(
                  right: -6,
                  top: -8,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: BoxDecoration(
                      color: AppTheme.errorColor,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      badge > 9 ? '9+' : badge.toString(),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPopupSelectionIndicator(bool isSelected) {
    final Color borderColor =
        isSelected ? AppTheme.primaryColor : AppTheme.borderColor;

    return SizedBox(
      width: 18,
      height: 18,
      child: DecoratedBox(
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: 1.6),
          color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.12) : Colors.transparent,
        ),
        child: Center(
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 160),
            width: isSelected ? 8 : 0,
            height: isSelected ? 8 : 0,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: isSelected ? AppTheme.primaryColor : Colors.transparent,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildNavItem({
    required IconData icon,
    required String title,
    required bool isSelected,
    int? badge,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.1) : null,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: isSelected ? AppTheme.primaryColor : AppTheme.textSecondary,
              size: 22,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                title,
                style: AppTheme.bodyMedium.copyWith(
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                  color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                ),
              ),
            ),
            if (badge != null && badge > 0)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: AppTheme.errorColor,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  badge.toString(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandableNavItem({
    required IconData icon,
    required String title,
    required bool isExpanded,
    required VoidCallback onTap,
    required List<Widget> children,
    bool hasSelectedChild = false,
  }) {
    final isSelected = isExpanded || hasSelectedChild;
    return Column(
      children: [
        InkWell(
          onTap: onTap,
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            decoration: BoxDecoration(
              color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.1) : null,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Row(
              children: [
                Icon(
                  icon,
                  color: isSelected ? AppTheme.primaryColor : AppTheme.textSecondary,
                  size: 22,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    title,
                    style: AppTheme.bodyMedium.copyWith(
                      fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                      color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                    ),
                  ),
                ),
                Icon(
                  isExpanded ? Icons.expand_less : Icons.expand_more,
                  color: isSelected ? AppTheme.primaryColor : AppTheme.textSecondary,
                  size: 20,
                ),
              ],
            ),
          ),
        ),
        if (isExpanded) ...children,
      ],
    );
  }

  Widget _buildSubNavItem({
    required String title,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(left: 40, right: 8, top: 4, bottom: 4),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.1) : null,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            Container(
              width: 4,
              height: 16,
              decoration: BoxDecoration(
                color: isSelected ? AppTheme.primaryColor : Colors.transparent,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                title,
                style: AppTheme.bodyMedium.copyWith(
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                  color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                  fontSize: 14,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMobileDrawer() {
    // Build menu items list based on permissions (same logic as desktop)
    final List<Widget> menuItems = [];
    
    // Dashboard - always show if user has permission
    if (_canViewDashboard) {
      menuItems.add(
                _buildMobileNavItem(
                  icon: Icons.dashboard_outlined,
                  title: SuperAdminMenuNames.dashboard,
                  isSelected: _selectedItem == NavItem.dashboard,
                  onTap: () {
                    setState(() {
                      _isDrawerOpen = false;
                    });
                    _navigateToRoute(NavItem.dashboard);
                  },
                ),
      );
    }
    
    // Wallet menu - show if user has any wallet permission
    if (_canViewWalletMenu) {
      final List<Widget> walletChildren = [];
      if (_canViewWalletSelf) {
        walletChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.account_balance_wallet,
                      title: SuperAdminMenuNames.walletSelf,
                      isSelected: _selectedItem == NavItem.walletSelf,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                        });
                        _handleNavSelection(NavItem.walletSelf);
                      },
                    ),
        );
      }
      if (_canViewWalletAll) {
        walletChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.account_balance_wallet_outlined,
                      title: 'All User Wallets',
                      isSelected: _selectedItem == NavItem.walletAll,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                        });
                        _navigateToRoute(NavItem.walletAll);
                      },
                    ),
        );
      }
      if (_canViewWalletOverview) {
        walletChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.assessment_outlined,
                      title: 'All Wallet Report',
                      isSelected: _selectedItem == NavItem.walletOverview,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                        });
                        _navigateToRoute(NavItem.walletOverview);
                        // Force refresh when switching to All Wallet Report to apply current filters
                        WidgetsBinding.instance.addPostFrameCallback((_) {
                          if (mounted) {
                            _loadFinancialData(forceRefresh: true, isSelfWallet: false);
                          }
                        });
                      },
                    ),
        );
      }
      
      // Only show wallet menu if at least one child is visible
      if (walletChildren.isNotEmpty) {
        menuItems.add(
          ExpansionTile(
            leading: Icon(
              Icons.account_balance_wallet_outlined,
              color: AppTheme.textSecondary,
                ),
            initiallyExpanded:
                _selectedItem.toString().startsWith('NavItem.wallet'),
            title: Text(
              'Wallet',
              style: TextStyle(
                fontWeight: _selectedItem.toString().startsWith('NavItem.wallet')
                    ? FontWeight.w600
                    : FontWeight.normal,
                color: _selectedItem.toString().startsWith('NavItem.wallet')
                    ? AppTheme.primaryColor
                    : AppTheme.textPrimary,
              ),
            ),
            children: walletChildren,
          ),
        );
      }
    }
    
    // Smart Approvals
    if (_canViewSmartApprovals) {
      menuItems.add(
                _buildMobileNavItem(
                  icon: Icons.hourglass_bottom,
                  title: 'Smart Approvals',
                  isSelected: _selectedItem == NavItem.smartApprovals,
                  badge: _pendingCollections + _pendingTransactions + _pendingExpenses > 0
                      ? _pendingCollections + _pendingTransactions + _pendingExpenses
                      : null,
                  onTap: () {
                    setState(() {
                      _isDrawerOpen = false;
                    });
                    _navigateToRoute(NavItem.smartApprovals);
                  },
                ),
      );
    }
    
    // All Users menu - show if user has any user management permission
    if (_canViewUsersMenu) {
      final List<Widget> usersChildren = [];
      if (_canViewUsers) {
        usersChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.manage_accounts_outlined,
                      title: 'User Management',
                      isSelected: _selectedItem == NavItem.users,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _usersExpanded = true;
                          _selectedItem = NavItem.users;
                        });
                      },
                    ),
        );
      }
      if (_canViewRoles) {
        usersChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.security_outlined,
                      title: 'Roles',
                      isSelected: _selectedItem == NavItem.roles,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _usersExpanded = true;
                          _selectedItem = NavItem.roles;
                        });
                      },
                    ),
        );
      }
      usersChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.account_balance_wallet_outlined,
                      title: 'Assign Wallets',
                      isSelected: _selectedItem == NavItem.assignWallets,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _usersExpanded = true;
                        });
                        _navigateToRoute(NavItem.assignWallets);
                      },
                    ),
      );
                
      // Only show users menu if at least one child is visible
      if (usersChildren.isNotEmpty) {
        menuItems.add(
                ExpansionTile(
                  leading: Icon(
              Icons.people_outlined,
                    color: AppTheme.textSecondary,
                  ),
                  initiallyExpanded:
                _selectedItem == NavItem.users || 
                _selectedItem == NavItem.roles ||
                _selectedItem == NavItem.assignWallets,
                  title: Text(
              'All Users',
                    style: TextStyle(
                fontWeight: (_selectedItem == NavItem.users ||
                        _selectedItem == NavItem.roles ||
                        _selectedItem == NavItem.assignWallets)
                          ? FontWeight.w600
                          : FontWeight.normal,
                color: (_selectedItem == NavItem.users ||
                        _selectedItem == NavItem.roles ||
                        _selectedItem == NavItem.assignWallets)
                          ? AppTheme.primaryColor
                          : AppTheme.textPrimary,
                    ),
                  ),
            children: usersChildren,
          ),
        );
      }
    }
    
    // Payment Accounts menu - show if user has any payment account permission
    if (_canViewPaymentAccountsMenu) {
      final List<Widget> accountChildren = [];
      if (_canViewPaymentModes) {
        accountChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.payment_outlined,
                      title: 'Payment Mode',
                      isSelected: _selectedItem == NavItem.paymentModes,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _accountExpanded = true;
                          _selectedItem = NavItem.paymentModes;
                        });
                      },
                    ),
        );
      }
      if (_canViewAccountReports) {
        accountChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.assessment_outlined,
                      title: 'Account Reports',
                      isSelected: _selectedItem == NavItem.accountReports,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _accountExpanded = true;
                          _selectedItem = NavItem.accountReports;
                        });
                        // Load accounts immediately when Account Reports is selected
                        if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
                          _loadAccountsList();
                        }
                      },
                    ),
        );
      }
                
      // Only show payment accounts menu if at least one child is visible
      if (accountChildren.isNotEmpty) {
        menuItems.add(
                ExpansionTile(
                  leading: Icon(
              Icons.account_circle_outlined,
                    color: AppTheme.textSecondary,
                  ),
                  initiallyExpanded:
                _selectedItem == NavItem.accountReports ||
                _selectedItem == NavItem.paymentModes,
                  title: Text(
              'Payment Accounts',
                    style: TextStyle(
                fontWeight: (_selectedItem == NavItem.accountReports ||
                        _selectedItem == NavItem.paymentModes)
                          ? FontWeight.w600
                          : FontWeight.normal,
                color: (_selectedItem == NavItem.accountReports ||
                        _selectedItem == NavItem.paymentModes)
                          ? AppTheme.primaryColor
                          : AppTheme.textPrimary,
                    ),
                  ),
            children: accountChildren,
          ),
        );
      }
    }
    
    // Expenses menu - show if user has any expense permission
    if (_canViewExpensesMenu) {
      final List<Widget> expenseChildren = [];
      if (_canViewExpenseType) {
        expenseChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.category_outlined,
                      title: 'Expenses Type',
                      isSelected: _selectedItem == NavItem.expenseType,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _expensesExpanded = true;
                          _selectedItem = NavItem.expenseType;
                        });
                      },
                    ),
        );
      }
      if (_canViewExpenseReport) {
        expenseChildren.add(
                    _buildMobileNavItem(
                      icon: Icons.assessment_outlined,
                      title: 'Expense Report',
                      isSelected: _selectedItem == NavItem.expenseReport,
                      isSubItem: true,
                      onTap: () {
                        setState(() {
                          _isDrawerOpen = false;
                          _expensesExpanded = true;
                          _selectedItem = NavItem.expenseReport;
                        });
                      },
                    ),
        );
      }
      
      // Only show expenses menu if at least one child is visible
      if (expenseChildren.isNotEmpty) {
        menuItems.add(
          ExpansionTile(
            leading: Icon(
              Icons.receipt_long_outlined,
              color: AppTheme.textSecondary,
            ),
            initiallyExpanded:
                _selectedItem == NavItem.transactionExpense ||
                _selectedItem == NavItem.expenseType ||
                _selectedItem == NavItem.expenseReport,
            title: Text(
              'Expenses',
              style: TextStyle(
                fontWeight: (_selectedItem == NavItem.transactionExpense ||
                        _selectedItem == NavItem.expenseType ||
                        _selectedItem == NavItem.expenseReport)
                    ? FontWeight.w600
                    : FontWeight.normal,
                color: (_selectedItem == NavItem.transactionExpense ||
                        _selectedItem == NavItem.expenseType ||
                        _selectedItem == NavItem.expenseReport)
                    ? AppTheme.primaryColor
                    : AppTheme.textPrimary,
              ),
            ),
            children: expenseChildren,
          ),
        );
      }
    }
    
    // Settings menu - show if user has any settings permission
    if (_canViewSettingsMenu) {
      final List<Widget> settingsChildren = [];
      settingsChildren.add(
        _buildMobileNavItem(
          icon: Icons.collections_outlined,
          title: 'Collection',
          isSelected: _selectedItem == NavItem.collectionCustomField,
          isSubItem: true,
          onTap: () {
            setState(() {
              _isDrawerOpen = false;
              _settingsExpanded = true;
            });
            _navigateToRoute(NavItem.collectionCustomField);
          },
        ),
      );
      
      // Only show settings menu if at least one child is visible
      if (settingsChildren.isNotEmpty) {
        menuItems.add(
          ExpansionTile(
            leading: Icon(
              Icons.settings_outlined,
              color: AppTheme.textSecondary,
            ),
            initiallyExpanded: _selectedItem == NavItem.collectionCustomField,
            title: Text(
              'Settings',
              style: TextStyle(
                fontWeight: _selectedItem == NavItem.collectionCustomField
                    ? FontWeight.w600
                    : FontWeight.normal,
                color: _selectedItem == NavItem.collectionCustomField
                    ? AppTheme.primaryColor
                    : AppTheme.textPrimary,
              ),
            ),
            children: settingsChildren,
          ),
        );
      }
    }
    
    return Material(
      color: Colors.white,
      child: Column(
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              gradient: AppTheme.primaryGradient,
            ),
            child: Row(
              children: [
                const Icon(Icons.admin_panel_settings, color: Colors.white, size: 32),
                const SizedBox(width: 12),
                Text(
                  _userName ?? 'Super Admin',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
          
          // Navigation Items
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(vertical: 8),
              children: menuItems,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMobileNavItem({
    required IconData icon,
    required String title,
    required bool isSelected,
    int? badge,
    required VoidCallback onTap,
    bool isSubItem = false,
  }) {
    return InkWell(
      onTap: onTap,
      child: Container(
        margin: EdgeInsets.only(
          left: isSubItem ? 40 : 8,
          right: 8,
          top: 4,
          bottom: 4,
        ),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.1) : null,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            if (isSubItem)
              Container(
                width: 4,
                height: 20,
                decoration: BoxDecoration(
                  color: isSelected ? AppTheme.primaryColor : Colors.transparent,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            if (isSubItem) const SizedBox(width: 12),
            Icon(
              icon,
              color: isSelected ? AppTheme.primaryColor : AppTheme.textSecondary,
              size: 20,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
        title,
                style: AppTheme.bodyMedium.copyWith(
          fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
          color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                  fontSize: 14,
        ),
      ),
            ),
            if (badge != null && badge > 0)
              Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: AppTheme.errorColor,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                badge.toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _getContentForItem(NavItem item) {
    switch (item) {
      case NavItem.dashboard:
        // Block non-wallet users from viewing dashboard
        if (_isNonWalletUser) {
          // Non-wallet user - redirect to All User Wallets
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted && _selectedItem == NavItem.dashboard) {
              setState(() {
                _selectedItem = NavItem.walletAll;
              });
            }
          });
          return const Center(
            child: Text('Redirecting to All User Wallets...'),
          );
        }
        return _buildMainDashboard();
      case NavItem.walletSelf:
        // Block non-wallet users from viewing My Wallet
        if (_isNonWalletUser) {
          // Non-wallet user - redirect to All User Wallets
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted && _selectedItem == NavItem.walletSelf) {
              setState(() {
                _selectedItem = NavItem.walletAll;
              });
            }
          });
          return const Center(
            child: Text('Redirecting to All User Wallets...'),
          );
        }
        return _buildDashboardContent(isSelfWallet: true);
      case NavItem.walletAll:
        return const AllUserWalletsScreen(showAppBar: false);
      case NavItem.walletOverview:
        return _buildDashboardContent(
          isSelfWallet: false,
          customTitle: 'Wallet Report',
        );
      case NavItem.transactionCollection:
        return const CollectionsScreen(role: 'Super Admin', embedInDashboard: true);
      case NavItem.transactionTransfer:
        return const TransferScreen(embedInDashboard: true);
      case NavItem.transactionExpense:
        return const Center(
          child: Text('Expenses feature is currently unavailable'),
        );
      case NavItem.transactionTransactions:
        return const AllTransactionsScreen(embedInDashboard: true);
      case NavItem.users:
        return ManageUsersScreen(
          onNavigateToRoles: (roleName) {
            setState(() {
              _selectedItem = NavItem.roles;
              _highlightRole = roleName; // Store role to highlight
            });
          },
        );
      case NavItem.roles:
        return RolesScreen(
          embedInDashboard: true,
          highlightRole: _highlightRole, // Pass role to highlight
        );
      case NavItem.assignWallets:
        return _buildComingSoonScreen('Assign Wallets');
      case NavItem.accountReports:
        return _buildDashboardContent(
          isAllAccounts: true,
          customTitle: 'Account Reports',
        );
      case NavItem.paymentModes:
        return const PaymentModesScreen(showAppBar: false);
      case NavItem.expenseType:
        return const ManageExpenseTypesScreen();
      case NavItem.expenseReport:
        return _buildDashboardContent(
          isSelfWallet: false,
          customTitle: 'Expense Report',
          isAllAccounts: false,
          isExpenseReportOnly: true,
        );
      case NavItem.smartApprovals:
        return PendingApprovalsScreen(
          key: _pendingApprovalsRefreshKey,
          embedInDashboard: true,
        );
      case NavItem.collectionCustomField:
        return CollectionCustomFieldScreen(
          key: _collectionCustomFieldRefreshKey,
          showAppBar: false,
        );
    }
  }

  /// Build a "Coming Soon" screen
  Widget _buildComingSoonScreen(String featureName) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.construction_outlined,
              size: 80,
              color: AppTheme.primaryColor.withOpacity(0.6),
            ),
            const SizedBox(height: 24),
            Text(
              featureName,
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: AppTheme.textPrimary,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'Coming Soon',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                color: AppTheme.textSecondary,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'This feature is under development and will be available soon.',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: AppTheme.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  // Modal dialog for Add Amount
  Future<void> _showAddAmountWithdrawDialog() async {
    // Reset form state
    _amountController.clear();
    _remarkController.clear();
    bool dialogIsSubmitting = false;
    bool dialogIsAddAmountMode = true;
    
    setState(() {
      _selectedAccountId = null;
      _isAddAmountMode = true;
      _isSubmitting = false;
    });
    _addAmountWithdrawFormKey.currentState?.reset();

    final isMobile = Responsive.isMobile(context);
    final isTablet = Responsive.isTablet(context);

    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
              backgroundColor: Colors.white,
              child: Container(
                constraints: BoxConstraints(
                  maxWidth: isMobile ? double.infinity : 600,
                  maxHeight: MediaQuery.of(context).size.height * 0.9,
                ),
            decoration: BoxDecoration(
              color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                ),
                padding: EdgeInsets.all(isMobile ? 20 : 24),
                child: SingleChildScrollView(
                  child: Form(
                    key: _addAmountWithdrawFormKey,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Header
                        Row(
              children: [
                Container(
                              width: 40,
                              height: 40,
                  decoration: BoxDecoration(
                                color: AppTheme.secondaryColor,
                                shape: BoxShape.circle,
                  ),
                  child: const Icon(
                                Icons.add,
                                color: Colors.white,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                                'Add Amount / Withdraw',
                                style: AppTheme.headingMedium,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 24),
                        
                        // Mode Toggle Buttons
                        Container(
                          decoration: BoxDecoration(
                            color: AppTheme.backgroundColor,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(color: AppTheme.borderColor),
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: InkWell(
                                  onTap: () {
                                    setDialogState(() {
                                      dialogIsAddAmountMode = true;
                    });
                  },
                                  borderRadius: const BorderRadius.only(
                                    topLeft: Radius.circular(12),
                                    bottomLeft: Radius.circular(12),
                                  ),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(vertical: 12),
                                    decoration: BoxDecoration(
                                      color: dialogIsAddAmountMode ? AppTheme.secondaryColor.withOpacity(0.1) : Colors.transparent,
                                      borderRadius: const BorderRadius.only(
                                        topLeft: Radius.circular(12),
                                        bottomLeft: Radius.circular(12),
                                      ),
                                    ),
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                                        Icon(
                                          Icons.add_circle_outline,
                                          color: dialogIsAddAmountMode ? AppTheme.secondaryColor : AppTheme.textSecondary,
                                          size: 20,
                                        ),
                                        const SizedBox(width: 8),
                    Text(
                                          'Add Amount',
                                          style: TextStyle(
                                            color: dialogIsAddAmountMode ? AppTheme.secondaryColor : AppTheme.textPrimary,
                                            fontWeight: dialogIsAddAmountMode ? FontWeight.w600 : FontWeight.normal,
                                            fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
                                ),
                              ),
                              Expanded(
                                child: InkWell(
                                  onTap: () {
                                    setDialogState(() {
                                      dialogIsAddAmountMode = false;
                                    });
                                  },
                                  borderRadius: const BorderRadius.only(
                                    topRight: Radius.circular(12),
                                    bottomRight: Radius.circular(12),
                                  ),
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(vertical: 12),
                                    decoration: BoxDecoration(
                                      color: !dialogIsAddAmountMode ? AppTheme.errorColor.withOpacity(0.1) : Colors.transparent,
                                      borderRadius: const BorderRadius.only(
                                        topRight: Radius.circular(12),
                                        bottomRight: Radius.circular(12),
                                      ),
                                    ),
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                                          Icons.remove_circle_outline,
                                          color: !dialogIsAddAmountMode ? AppTheme.errorColor : AppTheme.textSecondary,
                                          size: 20,
                                        ),
                                        const SizedBox(width: 8),
                    Text(
                                          'Withdraw',
                                          style: TextStyle(
                                            color: !dialogIsAddAmountMode ? AppTheme.errorColor : AppTheme.textPrimary,
                                            fontWeight: !dialogIsAddAmountMode ? FontWeight.w600 : FontWeight.normal,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                      ),
                    ),
                  ],
                ),
              ),
                        const SizedBox(height: 32),
                        
                        // Account Selection - Using PopupMenuButton with bottom alignment (same as Add Collection)
                        Builder(
                          builder: (context) {
                            // GlobalKey to measure actual height of the InputDecorator
                            final GlobalKey inputKey = GlobalKey();
                            
                            // Get selected account display text
                            String displayText = 'Select Account';
                            if (_selectedAccountId != null) {
                              final selectedAccount = _allAccountsList.firstWhere(
                                (acc) {
                                  final accId = (acc['id'] ?? acc['_id'])?.toString() ?? '';
                                  return accId == _selectedAccountId;
                                },
                                orElse: () => <String, dynamic>{},
                              );
                              if (selectedAccount.isNotEmpty) {
                                displayText = (selectedAccount['name'] ?? 'Unknown Account').toString();
                              }
                            }
                            
                            // Calculate button height for proper menu offset (aligned at bottom of text box)
                            // InputDecorator with label actual height:
                            // Mobile: ~74px, Desktop: ~82px (including label, padding, border)
                            final double buttonHeight = isMobile ? 74.0 : 82.0;
                            final Offset menuOffset = Offset(0, buttonHeight + 4); // 4px gap below text box
                            
                            return SizedBox(
                              width: double.infinity,
                              child: Material(
                                elevation: 8,
                                color: Colors.transparent,
                                shadowColor: Colors.transparent,
                                child: PopupMenuButton<String>(
                                  offset: menuOffset, // Position menu at bottom of text box with 4px gap
                                  // Ensure menu always opens below (prevent auto-positioning above)
                                  clipBehavior: Clip.none,
                                elevation: 8,
                                shadowColor: Colors.black.withOpacity(0.08),
                                surfaceTintColor: Colors.transparent,
                                color: Colors.white,
                                constraints: BoxConstraints(
                                  minWidth: isMobile ? double.infinity : 300,
                                  maxWidth: isMobile ? double.infinity : 400,
                                  maxHeight: isMobile ? 300 : 400,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                onSelected: (String? newValue) {
                                  if (newValue != null) {
                            setDialogState(() {
                                      _selectedAccountId = newValue;
                            });
                                  }
                                },
                                itemBuilder: (context) {
                                  return _allAccountsList.map<PopupMenuEntry<String>>((account) {
                                    final accountId = (account['id'] ?? account['_id'])?.toString() ?? '';
                                    final accountName = (account['name'] ?? account['modeName'] ?? 'Unknown Account').toString();
                                    final isSelected = accountId == _selectedAccountId;
                                    
                                    return PopupMenuItem<String>(
                                      value: accountId,
                                      padding: EdgeInsets.symmetric(
                                        horizontal: 12,
                                        vertical: isMobile ? 10 : 8,
                                      ),
                                      child: Row(
                                        children: [
                                          if (isSelected)
                                            Icon(
                                              Icons.check,
                                              size: 18,
                                              color: AppTheme.primaryColor,
                                            )
                                          else
                                            const SizedBox(width: 18),
                                          if (isSelected) const SizedBox(width: 8),
                                          Icon(
                                            Icons.account_balance_outlined,
                                            size: 20,
                                            color: AppTheme.primaryColor,
                                          ),
                                          const SizedBox(width: 12),
                                          Expanded(
                                            child: Text(
                                              accountName,
                                              overflow: TextOverflow.ellipsis,
                                              style: TextStyle(
                                                fontSize: 14,
                                                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                                                color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                                              ),
                                            ),
                                          ),
                                        ],
                                      ),
                                    );
                                  }).toList();
                                },
                                // Child: Button that looks exactly like DropdownButtonFormField (same as Add Collection)
                                child: InputDecorator(
                                  decoration: InputDecoration(
                                    labelText: 'Account Selection',
                                    hintText: 'Select an account',
                                    prefixIcon: const Icon(Icons.account_balance_outlined),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 10 : 14,
                                    ),
                                    suffixIcon: const Icon(Icons.arrow_drop_down),
                                  ),
                                  isFocused: false,
                                  isEmpty: _selectedAccountId == null,
                                  child: Text(
                                    displayText,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ),
                            ),
                            );
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Amount Input
                        TextFormField(
                          controller: _amountController,
                          keyboardType: const TextInputType.numberWithOptions(decimal: true),
                          decoration: const InputDecoration(
                            labelText: 'Amount',
                            hintText: 'Enter amount',
                            prefixIcon: Icon(Icons.currency_rupee_outlined),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter an amount';
                            }
                            final amount = double.tryParse(value);
                            if (amount == null || amount <= 0) {
                              return 'Please enter a valid amount';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Remark Input
                        TextFormField(
                          controller: _remarkController,
                          maxLines: 3,
                          decoration: const InputDecoration(
                            labelText: 'Remark',
                            hintText: 'Enter remark (optional)',
                            prefixIcon: Icon(Icons.note_outlined),
                          ),
                        ),
                        const SizedBox(height: 32),
                        
                        // Buttons
                        Row(
                          children: [
                            Expanded(
                              child: OutlinedButton(
                                onPressed: dialogIsSubmitting ? null : () {
                                  Navigator.of(dialogContext).pop();
                                  _amountController.clear();
                                  _remarkController.clear();
                                  setState(() {
                                    _selectedAccountId = null;
                                  });
                                },
                                style: OutlinedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  side: const BorderSide(color: AppTheme.borderColor),
                                  foregroundColor: AppTheme.primaryColor,
                                ),
                                child: const Text(
                                  'Cancel',
                                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              flex: 2,
                              child: ElevatedButton(
                                onPressed: dialogIsSubmitting ? null : () async {
                                  if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                    if (_selectedAccountId == null || _selectedAccountId!.isEmpty) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: const Text('Please select an account'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    setDialogState(() {
                                      dialogIsSubmitting = true;
                                      _isSubmitting = true;
                                    });

                                    try {
                                      final amount = double.parse(_amountController.text);
                                      final remark = _remarkController.text.trim();

                                      final result = dialogIsAddAmountMode
                                          ? await WalletService.addAmountToAccount(
                                              accountId: _selectedAccountId!,
                                              amount: amount,
                                              remark: remark.isEmpty ? null : remark,
                                            )
                                          : await WalletService.withdrawFromAccount(
                                              accountId: _selectedAccountId!,
                                              amount: amount,
                                              remark: remark.isEmpty ? null : remark,
                                            );

                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        if (result['success'] == true) {
                                          Navigator.of(dialogContext).pop();

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 
                                                (dialogIsAddAmountMode 
                                                  ? 'Amount added successfully'
                                                  : 'Amount withdrawn successfully')),
                                              backgroundColor: AppTheme.secondaryColor,
                                              duration: const Duration(seconds: 2),
                                            ),
                                          );

                                          // Clear form
                                          _amountController.clear();
                                          _remarkController.clear();
                                          setState(() {
                                            _selectedAccountId = null;
                                          });

                                          // Refresh wallet data if available
                                          if (result['wallet'] != null) {
                                            _loadDashboardData();
                                          }

                                          // Refresh All Accounts data
                                          _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                        } else {
                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Operation failed'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    } catch (e) {
                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                            backgroundColor: AppTheme.errorColor,
                                            duration: const Duration(seconds: 3),
                                          ),
                                        );
                                      }
                                    }
                                  }
                                },
                                style: ElevatedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  backgroundColor: dialogIsAddAmountMode 
                                      ? AppTheme.secondaryColor 
                                      : AppTheme.errorColor,
                                  foregroundColor: Colors.white,
                                ),
                                child: dialogIsSubmitting
                                    ? const SizedBox(
                                        height: 20,
                                        width: 20,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                        ),
                                      )
                                    : Text(
                                        dialogIsAddAmountMode ? 'Add Amount' : 'Withdraw',
                                        style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                      ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  // Simplified Add Amount Dialog (no mode toggle)
  Future<void> _showAddAmountDialog() async {
    try {
      // Load accounts in background if needed (don't wait)
      if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
        _loadAccountsList();
      }
      
      // Reset form state
      _amountController.clear();
      _remarkController.clear();
      bool dialogIsSubmitting = false;
      
      // Preserve selected account if already set
      final String? preservedAccountId = _selectedAccountId;
      
      setState(() {
        _isSubmitting = false;
      });
      _addAmountWithdrawFormKey.currentState?.reset();

      final isMobile = Responsive.isMobile(context);
      final isTablet = Responsive.isTablet(context);

      if (!mounted) return;
      
      await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
      shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
        ),
              backgroundColor: Colors.white,
      child: Container(
                constraints: BoxConstraints(
                  maxWidth: isMobile ? double.infinity : 600,
                  maxHeight: MediaQuery.of(context).size.height * 0.9,
                ),
        decoration: BoxDecoration(
          color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                ),
                padding: EdgeInsets.all(isMobile ? 20 : 24),
                child: SingleChildScrollView(
                  child: Form(
                    key: _addAmountWithdrawFormKey,
        child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      mainAxisSize: MainAxisSize.min,
          children: [
                        // Header
                        Text(
                          'Add Amount',
                          style: AppTheme.headingMedium,
                        ),
                        const SizedBox(height: 24),
                        
                        // Account Selection - Using PopupMenuButton with bottom alignment
                        _allAccountsList.isEmpty
                            ? Container(
                                padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                                  color: AppTheme.backgroundColor,
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(color: AppTheme.borderColor),
                                ),
                                child: Row(
                                  children: [
                                    const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(strokeWidth: 2),
                                    ),
                                    const SizedBox(width: 12),
                                    Flexible(
                                      child: Text(
                                      'Loading accounts...',
                                      style: AppTheme.bodyMedium.copyWith(
                                        color: AppTheme.textSecondary,
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                  ),
                ),
              ],
            ),
                              )
                            : Builder(
                                builder: (context) {
                                  // Get selected account display text
                                  final currentValue = preservedAccountId ?? _selectedAccountId;
                                  String displayText = 'Select Account';
                                  if (currentValue != null) {
                                    final selectedAccount = _allAccountsList.firstWhere(
                                      (acc) {
                                        final accId = (acc['id'] ?? acc['_id'])?.toString() ?? '';
                                        return accId == currentValue;
                                      },
                                      orElse: () => <String, dynamic>{},
                                    );
                                    if (selectedAccount.isNotEmpty) {
                                      displayText = (selectedAccount['name'] ?? selectedAccount['modeName'] ?? 'Unknown Account').toString();
                                    }
                                  }
                                  
                                  // Calculate button height for proper menu offset (aligned at bottom of text box)
                                  // InputDecorator with label actual height:
                                  // Mobile: ~76px, Desktop: ~84px (including label, padding, border)
                                  // Using slightly higher offset to ensure menu appears exactly at bottom
                                  final double buttonHeight = isMobile ? 76.0 : 84.0;
                                  final Offset menuOffset = Offset(0, buttonHeight); // Menu starts exactly at bottom of button
                                  
                                  return SizedBox(
                                    width: double.infinity,
                                    child: Material(
                                      elevation: 8,
                                      color: Colors.transparent,
                                      shadowColor: Colors.transparent,
                                      child: PopupMenuButton<String>(
                                        offset: menuOffset, // Position menu at bottom of text box
                                        // Ensure menu always opens below (prevent auto-positioning above)
                                        clipBehavior: Clip.none,
                                        elevation: 8,
                                        shadowColor: Colors.black.withOpacity(0.08),
                                        surfaceTintColor: Colors.transparent,
                                        color: Colors.white,
                                        constraints: BoxConstraints(
                                          minWidth: isMobile ? double.infinity : 300,
                                          maxWidth: isMobile ? double.infinity : 400,
                                          maxHeight: isMobile ? 300 : 400,
                                        ),
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                                        onSelected: (String? newValue) {
                                          if (newValue != null) {
                                  setDialogState(() {
                                              _selectedAccountId = newValue;
                                            });
                                          }
                                        },
                                        itemBuilder: (context) {
                                          return _allAccountsList.map<PopupMenuEntry<String>>((account) {
                                            final accountId = (account['id'] ?? account['_id'])?.toString() ?? '';
                                            final accountName = (account['name'] ?? account['modeName'] ?? 'Unknown Account').toString();
                                            final isSelected = accountId == currentValue;
                                            
                                            return PopupMenuItem<String>(
                                              value: accountId,
                                              padding: EdgeInsets.symmetric(
                                                horizontal: 12,
                                                vertical: isMobile ? 10 : 8,
                                              ),
                                              child: Row(
                                                children: [
                                                  if (isSelected)
                                                    Icon(
                                                      Icons.check,
                                                      size: 18,
                                                      color: AppTheme.primaryColor,
                                                    )
                                                  else
                                                    const SizedBox(width: 18),
                                                  if (isSelected) const SizedBox(width: 8),
                                                  Icon(
                                                    Icons.account_balance_outlined,
                                                    size: 20,
                                                    color: AppTheme.primaryColor,
                                                  ),
                                                  const SizedBox(width: 12),
                                                  Expanded(
                                                    child: Text(
                                                      accountName,
                                                      overflow: TextOverflow.ellipsis,
                                                      style: TextStyle(
                                                        fontSize: 14,
                                                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                                                        color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                                                      ),
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            );
                                          }).toList();
                                        },
                                        // Child: Button that looks exactly like DropdownButtonFormField
                                        child: InputDecorator(
                                          decoration: InputDecoration(
                                            labelText: 'Account Selection',
                                            hintText: 'Select an account',
                                            prefixIcon: const Icon(Icons.account_balance_outlined),
                                            border: OutlineInputBorder(
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            contentPadding: EdgeInsets.symmetric(
                                              horizontal: 16,
                                              vertical: isMobile ? 10 : 14,
                                            ),
                                            suffixIcon: const Icon(Icons.arrow_drop_down),
                                          ),
                                          isFocused: false,
                                          isEmpty: currentValue == null,
                                          child: Text(
                                            displayText,
                                            overflow: TextOverflow.ellipsis,
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                },
                              ),
                        const SizedBox(height: 20),
                        
                        // Amount Input
                        TextFormField(
                          controller: _amountController,
                          keyboardType: const TextInputType.numberWithOptions(decimal: true),
                          decoration: const InputDecoration(
                            labelText: 'Amount',
                            hintText: 'Enter amount',
                            prefixIcon: Icon(Icons.currency_rupee_outlined),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter an amount';
                            }
                            final amount = double.tryParse(value);
                            if (amount == null || amount <= 0) {
                              return 'Please enter a valid amount';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Remark Input
                        TextFormField(
                          controller: _remarkController,
                          maxLines: 3,
                          decoration: const InputDecoration(
                            labelText: 'Remark',
                            hintText: 'Enter remark (optional)',
                            prefixIcon: Icon(Icons.note_outlined),
                          ),
                        ),
                        const SizedBox(height: 32),
                        
                        // Buttons
            Row(
              children: [
                Expanded(
                              child: OutlinedButton(
                                onPressed: dialogIsSubmitting ? null : () {
                                  Navigator.of(dialogContext).pop();
                                  _amountController.clear();
                                  _remarkController.clear();
                      setState(() {
                                    if (preservedAccountId == null) {
                                      _selectedAccountId = null;
                                    }
                      });
                    },
                    style: OutlinedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  side: const BorderSide(color: AppTheme.borderColor),
                                  foregroundColor: AppTheme.primaryColor,
                                ),
                                child: const Text(
                                  'Cancel',
                                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                Expanded(
                              flex: 2,
                              child: ElevatedButton(
                                onPressed: dialogIsSubmitting ? null : () async {
                                  if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                    final accountId = preservedAccountId ?? _selectedAccountId;
                                    if (accountId == null || accountId.isEmpty) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: const Text('Please select an account'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    setDialogState(() {
                                      dialogIsSubmitting = true;
                                      _isSubmitting = true;
                                    });

                                    try {
                                      final amount = double.parse(_amountController.text);
                                      final remark = _remarkController.text.trim();

                                      final result = await WalletService.addAmountToAccount(
                                        accountId: accountId,
                                        amount: amount,
                                        remark: remark.isEmpty ? null : remark,
                                      );

                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        if (result['success'] == true) {
                                          Navigator.of(dialogContext).pop();

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Amount added successfully'),
                                              backgroundColor: AppTheme.secondaryColor,
                                              duration: const Duration(seconds: 2),
                                            ),
                                          );

                                          // Clear form
                                          _amountController.clear();
                                          _remarkController.clear();
                      setState(() {
                                            if (preservedAccountId == null) {
                                              _selectedAccountId = null;
                                            }
                                          });

                                          // Refresh wallet data if available
                                          if (result['wallet'] != null) {
                                            _loadDashboardData();
                                          }

                                          // Refresh All Accounts data
                                          _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                        } else {
                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Operation failed'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    } catch (e) {
                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                            backgroundColor: AppTheme.errorColor,
                                            duration: const Duration(seconds: 3),
                                          ),
                                        );
                                      }
                                    }
                                  }
                                },
                                style: ElevatedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  backgroundColor: AppTheme.secondaryColor,
                                  foregroundColor: Colors.white,
                                ),
                                child: dialogIsSubmitting
                                    ? const SizedBox(
                                        height: 20,
                                        width: 20,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                        ),
                                      )
                                    : const Text(
                                        'Add Amount',
                                        style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                      ),
                  ),
                ),
              ],
            ),
                      ],
                ),
              ),
            ),
              ),
            );
          },
        );
      },
    );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Simplified Withdraw Dialog (no mode toggle)
  Future<void> _showWithdrawDialog() async {
    try {
      // Load accounts in background if needed (don't wait)
      if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
        _loadAccountsList();
      }
      
      // Reset form state
      _amountController.clear();
      _remarkController.clear();
      bool dialogIsSubmitting = false;
      
      // Preserve selected account if already set
      final String? preservedAccountId = _selectedAccountId;
      
      setState(() {
        _isSubmitting = false;
      });
      _addAmountWithdrawFormKey.currentState?.reset();

      final isMobile = Responsive.isMobile(context);
      final isTablet = Responsive.isTablet(context);

      if (!mounted) return;
      
      await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
              backgroundColor: Colors.white,
              child: Container(
                constraints: BoxConstraints(
                  maxWidth: isMobile ? double.infinity : 600,
                  maxHeight: MediaQuery.of(context).size.height * 0.9,
                ),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                ),
                padding: EdgeInsets.all(isMobile ? 20 : 24),
                child: SingleChildScrollView(
                  child: Form(
      key: _addAmountWithdrawFormKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
                        // Header
                        Text(
                          'Withdraw',
                    style: AppTheme.headingMedium,
            ),
            const SizedBox(height: 24),
                        
                        // Account Selection - Using PopupMenuButton with bottom alignment
                        _allAccountsList.isEmpty
                            ? Container(
                                padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: AppTheme.backgroundColor,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: AppTheme.borderColor),
            ),
            child: Row(
              children: [
                                    const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(strokeWidth: 2),
                                    ),
                                    const SizedBox(width: 12),
                                    Flexible(
                                      child: Text(
                                      'Loading accounts...',
                                      style: AppTheme.bodyMedium.copyWith(
                                        color: AppTheme.textSecondary,
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                      ),
                                    ),
                                  ],
                                ),
                              )
                            : Builder(
                                builder: (context) {
                                  // Get selected account display text
                                  final currentValue = preservedAccountId ?? _selectedAccountId;
                                  String displayText = 'Select Account';
                                  if (currentValue != null) {
                                    final selectedAccount = _allAccountsList.firstWhere(
                                      (acc) {
                                        final accId = (acc['id'] ?? acc['_id'])?.toString() ?? '';
                                        return accId == currentValue;
                                      },
                                      orElse: () => <String, dynamic>{},
                                    );
                                    if (selectedAccount.isNotEmpty) {
                                      displayText = (selectedAccount['name'] ?? selectedAccount['modeName'] ?? 'Unknown Account').toString();
                                    }
                                  }
                                  
                                  // Calculate button height for proper menu offset (aligned at bottom of text box)
                                  // InputDecorator with label actual height:
                                  // Mobile: ~76px, Desktop: ~84px (including label, padding, border)
                                  // Using slightly higher offset to ensure menu appears exactly at bottom
                                  final double buttonHeight = isMobile ? 76.0 : 84.0;
                                  final Offset menuOffset = Offset(0, buttonHeight); // Menu starts exactly at bottom of button
                                  
                                  return SizedBox(
                                    width: double.infinity,
                                    child: Material(
                                      elevation: 8,
                                      color: Colors.transparent,
                                      shadowColor: Colors.transparent,
                                      child: PopupMenuButton<String>(
                                        offset: menuOffset, // Position menu at bottom of text box
                                        // Ensure menu always opens below (prevent auto-positioning above)
                                        clipBehavior: Clip.none,
                                        elevation: 8,
                                        shadowColor: Colors.black.withOpacity(0.08),
                                        surfaceTintColor: Colors.transparent,
                                        color: Colors.white,
                                        constraints: BoxConstraints(
                                          minWidth: isMobile ? double.infinity : 300,
                                          maxWidth: isMobile ? double.infinity : 400,
                                          maxHeight: isMobile ? 300 : 400,
                                        ),
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                                        onSelected: (String? newValue) {
                                          if (newValue != null) {
                                  setDialogState(() {
                                              _selectedAccountId = newValue;
                                            });
                                          }
                                        },
                                        itemBuilder: (context) {
                                          return _allAccountsList.map<PopupMenuEntry<String>>((account) {
                                            final accountId = (account['id'] ?? account['_id'])?.toString() ?? '';
                                            final accountName = (account['name'] ?? account['modeName'] ?? 'Unknown Account').toString();
                                            final isSelected = accountId == currentValue;
                                            
                                            return PopupMenuItem<String>(
                                              value: accountId,
                                              padding: EdgeInsets.symmetric(
                                                horizontal: 12,
                                                vertical: isMobile ? 10 : 8,
                                              ),
                                              child: Row(
                                                children: [
                                                  if (isSelected)
                                                    Icon(
                                                      Icons.check,
                                                      size: 18,
                                                      color: AppTheme.primaryColor,
                                                    )
                                                  else
                                                    const SizedBox(width: 18),
                                                  if (isSelected) const SizedBox(width: 8),
                                                  Icon(
                                                    Icons.account_balance_outlined,
                                                    size: 20,
                                                    color: AppTheme.primaryColor,
                                                  ),
                                                  const SizedBox(width: 12),
                                                  Expanded(
                                                    child: Text(
                                                      accountName,
                                                      overflow: TextOverflow.ellipsis,
                                                      style: TextStyle(
                                                        fontSize: 14,
                                                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                                                        color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                                                      ),
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            );
                                          }).toList();
                                        },
                                        // Child: Button that looks exactly like DropdownButtonFormField
                                        child: InputDecorator(
                                          decoration: InputDecoration(
                                            labelText: 'Account Selection',
                                            hintText: 'Select an account',
                                            prefixIcon: const Icon(Icons.account_balance_outlined),
                                            border: OutlineInputBorder(
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            contentPadding: EdgeInsets.symmetric(
                                              horizontal: 16,
                                              vertical: isMobile ? 10 : 14,
                                            ),
                                            suffixIcon: const Icon(Icons.arrow_drop_down),
                                          ),
                                          isFocused: false,
                                          isEmpty: currentValue == null,
                                          child: Text(
                                            displayText,
                                            overflow: TextOverflow.ellipsis,
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                },
                              ),
                        const SizedBox(height: 20),
                        
                        // Amount Input
                        TextFormField(
                          controller: _amountController,
                          keyboardType: const TextInputType.numberWithOptions(decimal: true),
                          decoration: const InputDecoration(
                            labelText: 'Amount',
                            hintText: 'Enter amount',
                            prefixIcon: Icon(Icons.currency_rupee_outlined),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter an amount';
                            }
                            final amount = double.tryParse(value);
                            if (amount == null || amount <= 0) {
                              return 'Please enter a valid amount';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Remark Input
                        TextFormField(
                          controller: _remarkController,
                          maxLines: 3,
                          decoration: const InputDecoration(
                            labelText: 'Remark',
                            hintText: 'Enter remark (optional)',
                            prefixIcon: Icon(Icons.note_outlined),
                          ),
                        ),
                        const SizedBox(height: 32),
                        
                        // Buttons
                        Row(
                        children: [
                            Expanded(
                              child: OutlinedButton(
                                onPressed: dialogIsSubmitting ? null : () {
                                  Navigator.of(dialogContext).pop();
                                  _amountController.clear();
                                  _remarkController.clear();
                                  setState(() {
                                    if (preservedAccountId == null) {
                                      _selectedAccountId = null;
                                    }
                                  });
                                },
                                style: OutlinedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  side: const BorderSide(color: AppTheme.borderColor),
                                  foregroundColor: AppTheme.primaryColor,
                                ),
                                child: const Text(
                                  'Cancel',
                                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              flex: 2,
                              child: ElevatedButton(
                                onPressed: dialogIsSubmitting ? null : () async {
                                  if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                    final accountId = preservedAccountId ?? _selectedAccountId;
                                    if (accountId == null || accountId.isEmpty) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: const Text('Please select an account'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    setDialogState(() {
                                      dialogIsSubmitting = true;
                                      _isSubmitting = true;
                                    });

                                    try {
                                      final amount = double.parse(_amountController.text);
                                      final remark = _remarkController.text.trim();

                                      final result = await WalletService.withdrawFromAccount(
                                        accountId: accountId,
                                        amount: amount,
                                        remark: remark.isEmpty ? null : remark,
                                      );

                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        if (result['success'] == true) {
                                          Navigator.of(dialogContext).pop();

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Amount withdrawn successfully'),
                                              backgroundColor: AppTheme.secondaryColor,
                                              duration: const Duration(seconds: 2),
                                            ),
                                          );

                                          // Clear form
                                          _amountController.clear();
                                          _remarkController.clear();
                                          setState(() {
                                            if (preservedAccountId == null) {
                                              _selectedAccountId = null;
                                            }
                                          });

                                          // Refresh wallet data if available
                                          if (result['wallet'] != null) {
                                            _loadDashboardData();
                                          }

                                          // Refresh All Accounts data
                                          _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                        } else {
                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Operation failed'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    } catch (e) {
                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                            backgroundColor: AppTheme.errorColor,
                                            duration: const Duration(seconds: 3),
                                          ),
                                        );
                                      }
                                    }
                                  }
                                },
                                style: ElevatedButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  backgroundColor: AppTheme.errorColor,
                                  foregroundColor: Colors.white,
                                ),
                                child: dialogIsSubmitting
                                    ? const SizedBox(
                                        height: 20,
                                        width: 20,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                        ),
                                      )
                                    : const Text(
                                        'Withdraw',
                                        style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                                      ),
                            ),
                          ),
                        ],
                      ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // New Add Amount Dialog with improved UI
  Future<void> _showNewAddAmountDialog() async {
    try {
      // Load payment modes in background if needed (don't wait)
      if (_paymentModes.isEmpty && !_isLoadingPaymentModes) {
        _loadPaymentModes();
      }
      
      // Reset form state
      _amountController.clear();
      _remarkController.clear();
      bool dialogIsSubmitting = false;
      
      // Preserve selected payment mode if already set
      final String? preservedPaymentModeId = _selectedAccountId;
      
      setState(() {
        _isSubmitting = false;
      });
      _addAmountWithdrawFormKey.currentState?.reset();

      final isMobile = Responsive.isMobile(context);
      final isTablet = Responsive.isTablet(context);

      if (!mounted) return;
      
      await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return StatefulBuilder(
            builder: (context, setDialogState) {
            return Dialog(
              backgroundColor: Colors.transparent,
              insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
                    child: Container(
                width: isMobile ? double.infinity : 500,
                constraints: BoxConstraints(
                  maxHeight: MediaQuery.of(context).size.height * 0.85,
                  minHeight: 400,
                ),
                      decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                ),
                    child: Form(
                      key: _addAmountWithdrawFormKey,
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                      // Header with User Name
                              Container(
                        padding: EdgeInsets.all(isMobile ? 16 : 20),
                                    decoration: BoxDecoration(
                                      color: AppTheme.primaryColor,
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                                    ),
                        child: isMobile
                            ? Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      const Icon(
                                        Icons.add_circle_outline,
                                        color: Colors.white,
                                        size: 28,
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Text(
                                          'Add Amount',
                                          style: AppTheme.headingMedium.copyWith(
                                            color: Colors.white,
                                            fontWeight: FontWeight.bold,
                                            fontSize: 18,
                                          ),
                                        ),
                                      ),
                                      // Close button - always visible
                                      IconButton(
                                        onPressed: () => Navigator.of(dialogContext).pop(),
                                        icon: const Icon(
                                          Icons.close_rounded,
                                          color: Colors.white,
                                          size: 24,
                                        ),
                                        tooltip: 'Close',
                                        padding: EdgeInsets.zero,
                                        constraints: const BoxConstraints(),
                                      ),
                                    ],
                                  ),
                                  // User name below on mobile
                                  if (_userName != null) ...[
                                    const SizedBox(height: 8),
                                    Row(
                                      children: [
                                        const Icon(
                                          Icons.person,
                                          color: Colors.white,
                                          size: 18,
                                        ),
                                        const SizedBox(width: 6),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 12,
                                            vertical: 6,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.white.withOpacity(0.2),
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                          child: Text(
                                            _userName!,
                                            style: const TextStyle(
                                              color: Colors.white,
                                              fontWeight: FontWeight.w600,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ],
                                ],
                              )
                            : Row(
                                children: [
                                  const Icon(
                                    Icons.add_circle_outline,
                                    color: Colors.white,
                                    size: 28,
                                  ),
                                  const SizedBox(width: 12),
                                  Expanded(
                                    child: Text(
                                      'Add Amount',
                                      style: AppTheme.headingMedium.copyWith(
                                        color: Colors.white,
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                  ),
                                  // User name on the right
                                  if (_userName != null)
                                    Row(
                                      children: [
                                        const Icon(
                                          Icons.person,
                                          color: Colors.white,
                                          size: 18,
                                        ),
                                        const SizedBox(width: 6),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 12,
                                            vertical: 6,
                                          ),
                                          decoration: BoxDecoration(
                                            color: Colors.white.withOpacity(0.2),
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                          child: Text(
                                            _userName!,
                                            style: const TextStyle(
                                              color: Colors.white,
                                              fontWeight: FontWeight.w600,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                ],
                              ),
                      ),

                      // Form Content
                      Flexible(
                        child: SingleChildScrollView(
                          padding: EdgeInsets.all(isMobile ? 16 : 24),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            mainAxisSize: MainAxisSize.min,
                            children: [
          // Payment Mode Selection
                          _paymentModes.isEmpty
                              ? Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                        color: AppTheme.surfaceColor,
                                    borderRadius: BorderRadius.circular(12),
                                    border: Border.all(color: AppTheme.borderColor),
                                  ),
                                  child: Row(
                                    children: [
                                      const SizedBox(
                                        width: 20,
                                        height: 20,
                                        child: CircularProgressIndicator(strokeWidth: 2),
                                      ),
                                      const SizedBox(width: 12),
                                      Flexible(
                                        child: Text(
                                        'Loading payment modes...',
                                        style: AppTheme.bodyMedium.copyWith(
                                          color: AppTheme.textSecondary,
                                          ),
                                          overflow: TextOverflow.ellipsis,
                                          maxLines: 1,
                                        ),
                                      ),
                                    ],
                                  ),
                                )
                              : DropdownButtonFormField<String>(
                                  value: () {
                                    final selectedValue = preservedPaymentModeId ?? _selectedAccountId;
                                    if (selectedValue == null) return null;
                                    return _paymentModes.any((mode) => (mode['_id'] ?? mode['id'])?.toString() == selectedValue)
                                        ? selectedValue
                                        : null;
                                  }(),
                                  decoration: InputDecoration(
                                    labelText: 'Payment Mode',
                                    prefixIcon: const Icon(Icons.payment),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                  style: TextStyle(
                                    fontSize: isMobile ? 16 : 15,
                                  ),
                                  items: _paymentModes.map((mode) {
                                    final modeId = (mode['_id'] ?? mode['id'])?.toString() ?? '';
                                    final modeName = mode['modeName']?.toString() ?? 'Unknown Payment Mode';
                                    return DropdownMenuItem<String>(
                                      value: modeId,
                                      child: Text(modeName),
                                    );
                                  }).toList(),
                                  onChanged: (value) {
                                    setDialogState(() {
                                      _selectedAccountId = value;
                                    });
                                  },
                                  validator: (value) {
                                    if (value == null || value.isEmpty) {
                                      return 'Please select a payment mode';
                                    }
                                    return null;
                                  },
                                ),
          SizedBox(height: isMobile ? 16 : 20),
          
          // Amount Input
          TextFormField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                decoration: InputDecoration(
              labelText: 'Amount',
                                  prefixIcon: const Icon(Icons.currency_rupee),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  contentPadding: EdgeInsets.symmetric(
                                    horizontal: 16,
                                    vertical: isMobile ? 16 : 14,
                                  ),
            ),
            style: TextStyle(
              fontSize: isMobile ? 16 : 15,
            ),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter an amount';
              }
              final amount = double.tryParse(value);
              if (amount == null || amount <= 0) {
                return 'Please enter a valid amount';
              }
              return null;
            },
          ),
          SizedBox(height: isMobile ? 16 : 20),
          
          // Remark Input
          TextFormField(
            controller: _remarkController,
            maxLines: 3,
                                decoration: InputDecoration(
              labelText: 'Remark',
              hintText: 'Enter remark (optional)',
                                  prefixIcon: const Icon(Icons.note_outlined),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  contentPadding: EdgeInsets.symmetric(
                                    horizontal: 16,
                                    vertical: isMobile ? 16 : 14,
                                  ),
                                ),
            style: TextStyle(
              fontSize: isMobile ? 16 : 15,
            ),
                              ),
                            ],
            ),
          ),
                      ),
          
                      // Action Buttons
                      Container(
                        padding: EdgeInsets.all(isMobile ? 16 : 20),
                        decoration: BoxDecoration(
                          border: Border(
                            top: BorderSide(color: AppTheme.borderColor),
                          ),
                        ),
                        child: isMobile
                            ? Column(
                                children: [
                                  SizedBox(
                                    width: double.infinity,
                                    child: ElevatedButton(
                                        onPressed: dialogIsSubmitting ? null : () async {
                                    if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                      final paymentModeId = preservedPaymentModeId ?? _selectedAccountId;
                                      if (paymentModeId == null || paymentModeId.isEmpty) {
                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: const Text('Please select a payment mode'),
                                            backgroundColor: AppTheme.errorColor,
                                          ),
                                        );
                                        return;
                                      }

                                      setDialogState(() {
                                        dialogIsSubmitting = true;
                                        _isSubmitting = true;
                                      });

                                      try {
                                        final amount = double.parse(_amountController.text);
                                        final remark = _remarkController.text.trim();

                                        final result = await WalletService.addAmountToAccount(
                                          accountId: paymentModeId,
                                          amount: amount,
                                          remark: remark.isEmpty ? null : remark,
                                        );

                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                            _isSubmitting = false;
                                          });

                                          if (result['success'] == true) {
                                            Navigator.of(dialogContext).pop();

                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text(result['message'] ?? 'Amount added successfully'),
                                                backgroundColor: AppTheme.secondaryColor,
                                                duration: const Duration(seconds: 2),
                                              ),
                                            );

                                            // Clear form
                                            _amountController.clear();
                                            _remarkController.clear();
                                            setState(() {
                                              if (preservedPaymentModeId == null) {
                                                _selectedAccountId = null;
                                              }
                                            });

                                            // Refresh wallet data if available
                                            if (result['wallet'] != null) {
                                              _loadDashboardData();
                                            }

                                            // Refresh All Accounts data
                                            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                          } else {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text(result['message'] ?? 'Operation failed'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      } catch (e) {
                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                            _isSubmitting = false;
                                          });

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    }
                                  },
                  style: ElevatedButton.styleFrom(
                                    backgroundColor: AppTheme.secondaryColor,
                    foregroundColor: Colors.white,
                                padding: EdgeInsets.symmetric(
                                  horizontal: 32,
                                  vertical: isMobile ? 16 : 14,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                  ),
                                  child: dialogIsSubmitting
                      ? const SizedBox(
                          width: 20,
                                      height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                                      : Text(
                                      'Submit',
                                      style: TextStyle(
                                        fontSize: isMobile ? 16 : 16,
                                        fontWeight: FontWeight.w600,
                        ),
                ),
              ),
                                    ),
                                  const SizedBox(height: 12),
                                  SizedBox(
                                    width: double.infinity,
                                    child: TextButton(
                                      onPressed: dialogIsSubmitting
                                          ? null
                                          : () {
                                            Navigator.of(dialogContext).pop();
                                            _amountController.clear();
                                            _remarkController.clear();
                                            setState(() {
                                              if (preservedPaymentModeId == null) {
                                                _selectedAccountId = null;
                                              }
                                            });
                                          },
                                      style: TextButton.styleFrom(
                                        padding: EdgeInsets.symmetric(
                                          vertical: isMobile ? 16 : 12,
                                        ),
                                      ),
                                      child: Text(
                                        'Cancel',
                                        style: TextStyle(
                                          color: AppTheme.primaryColor,
                                          fontSize: isMobile ? 16 : 15,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              )
                            : Row(
                                mainAxisAlignment: MainAxisAlignment.end,
            children: [
                                  TextButton(
                                    onPressed: dialogIsSubmitting
                                        ? null
                                        : () {
                                          Navigator.of(dialogContext).pop();
                                          _amountController.clear();
                                          _remarkController.clear();
                                          setState(() {
                                            if (preservedPaymentModeId == null) {
                                              _selectedAccountId = null;
                                            }
                                          });
                                        },
                                    child: Text(
                                      'Cancel',
                                      style: TextStyle(color: AppTheme.primaryColor),
                                    ),
                                  ),
                                  const SizedBox(width: 12),
                                  ElevatedButton(
                                        onPressed: dialogIsSubmitting ? null : () async {
                                    if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                      final paymentModeId = preservedPaymentModeId ?? _selectedAccountId;
                                      if (paymentModeId == null || paymentModeId.isEmpty) {
                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: const Text('Please select a payment mode'),
                                            backgroundColor: AppTheme.errorColor,
                                          ),
                                        );
                                        return;
                                      }

                                      setDialogState(() {
                                        dialogIsSubmitting = true;
                                        _isSubmitting = true;
                                      });

                                      try {
                                        final amount = double.parse(_amountController.text);
                                        final remark = _remarkController.text.trim();

                                        final result = await WalletService.addAmountToAccount(
                                          accountId: paymentModeId,
                                          amount: amount,
                                          remark: remark.isEmpty ? null : remark,
                                        );

                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                            _isSubmitting = false;
                                          });

                                          if (result['success'] == true) {
                                            Navigator.of(dialogContext).pop();

                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text(result['message'] ?? 'Amount added successfully'),
                                                backgroundColor: AppTheme.secondaryColor,
                                                duration: const Duration(seconds: 2),
                                              ),
                                            );

                                            // Clear form
                                            _amountController.clear();
                                            _remarkController.clear();
                                            setState(() {
                                              if (preservedPaymentModeId == null) {
                                                _selectedAccountId = null;
                                              }
                                            });

                                            // Refresh wallet data if available
                                            if (result['wallet'] != null) {
                                              _loadDashboardData();
                                            }

                                            // Refresh All Accounts data
                                            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                          } else {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text(result['message'] ?? 'Failed to add amount'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      } catch (e) {
                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                            _isSubmitting = false;
                                          });

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    }
                                  },
                  style: ElevatedButton.styleFrom(
                                    backgroundColor: AppTheme.secondaryColor,
                    foregroundColor: Colors.white,
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 32,
                                  vertical: 14,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                  ),
                                  child: dialogIsSubmitting
                      ? const SizedBox(
                          width: 20,
                                      height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                                      : const Text(
                                      'Submit',
                                      style: TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                        ),
                ),
              ),
                                ],
                        ),
          ),
        ],
                    ),
                  ),
                ),
              );
            },
          );
        },
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // New Withdraw Dialog with improved UI
  Future<void> _showNewWithdrawDialog() async {
    try {
      // Load accounts in background if needed (don't wait)
      if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
        _loadAccountsList();
      }
      
    // Reset form state
    _amountController.clear();
    _remarkController.clear();
    bool dialogIsSubmitting = false;
      
      // Preserve selected account if already set
      final String? preservedAccountId = _selectedAccountId;
    
    setState(() {
      _isSubmitting = false;
    });
    _addAmountWithdrawFormKey.currentState?.reset();

    final isMobile = Responsive.isMobile(context);
    final isTablet = Responsive.isTablet(context);

      if (!mounted) return;

    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              backgroundColor: Colors.transparent,
              insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: Container(
                width: isMobile ? double.infinity : 500,
                constraints: BoxConstraints(
                  maxHeight: MediaQuery.of(context).size.height * 0.85,
                  minHeight: 400,
                ),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                ),
                  child: Form(
                    key: _addAmountWithdrawFormKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                      // Header with User Name
                              Container(
                        padding: const EdgeInsets.all(20),
                                    decoration: BoxDecoration(
                                      color: AppTheme.secondaryColor,
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                                    ),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.remove_circle_outline,
                                      color: Colors.white,
                              size: 28,
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                  'Withdraw',
                                  style: AppTheme.headingMedium.copyWith(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            // User name on the right
                            if (_userName != null)
                              Row(
                                children: [
                                  const Icon(
                                    Icons.person,
                                    color: Colors.white,
                                    size: 18,
                                  ),
                                  const SizedBox(width: 6),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 12,
                                      vertical: 6,
                                    ),
                                    decoration: BoxDecoration(
                                      color: Colors.white.withOpacity(0.2),
                                      borderRadius: BorderRadius.circular(8),
                                    ),
                                    child: Text(
                                      _userName!,
                                      style: const TextStyle(
                                        color: Colors.white,
                                        fontWeight: FontWeight.w600,
                                        fontSize: 14,
                                  ),
                              ),
                            ),
                          ],
                        ),
                          ],
                        ),
                      ),

                      // Form Content
                      Flexible(
                        child: SingleChildScrollView(
                          padding: const EdgeInsets.all(24),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                        // Account Selection
                          _allAccountsList.isEmpty
                              ? Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                        color: AppTheme.surfaceColor,
                                    borderRadius: BorderRadius.circular(12),
                                    border: Border.all(color: AppTheme.borderColor),
                                  ),
                                  child: Row(
                                    children: [
                                      const SizedBox(
                                        width: 20,
                                        height: 20,
                                        child: CircularProgressIndicator(strokeWidth: 2),
                                      ),
                                      const SizedBox(width: 12),
                                      Flexible(
                                        child: Text(
                                        'Loading accounts...',
                                        style: AppTheme.bodyMedium.copyWith(
                                          color: AppTheme.textSecondary,
                                          ),
                                          overflow: TextOverflow.ellipsis,
                                          maxLines: 1,
                                        ),
                                      ),
                                    ],
                                  ),
                                )
                              : DropdownButtonFormField<String>(
                                  value: () {
                                    final selectedValue = preservedAccountId ?? _selectedAccountId;
                                    if (selectedValue == null) return null;
                                    return _allAccountsList.any((account) => account['id']?.toString() == selectedValue)
                                        ? selectedValue
                                        : null;
                                  }(),
                                      decoration: InputDecoration(
                                        labelText: 'Account',
                                        prefixIcon: const Icon(Icons.account_balance),
                                        border: OutlineInputBorder(
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                          ),
                                  items: _allAccountsList.map((account) {
                                    final accountId = account['id']?.toString() ?? '';
                                    final accountName = account['name']?.toString() ?? 'Unknown Account';
                            return DropdownMenuItem<String>(
                                      value: accountId,
                                      child: Text(accountName),
                            );
                          }).toList(),
                          onChanged: (value) {
                            setDialogState(() {
                              _selectedAccountId = value;
                            });
                          },
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please select an account';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Amount Input
                        TextFormField(
                          controller: _amountController,
                          keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                decoration: InputDecoration(
                            labelText: 'Amount',
                                  prefixIcon: const Icon(Icons.currency_rupee),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Please enter an amount';
                            }
                            final amount = double.tryParse(value);
                            if (amount == null || amount <= 0) {
                              return 'Please enter a valid amount';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 20),
                        
                        // Remark Input
                        TextFormField(
                          controller: _remarkController,
                          maxLines: 3,
                                decoration: InputDecoration(
                            labelText: 'Remark',
                            hintText: 'Enter remark (optional)',
                                  prefixIcon: const Icon(Icons.note_outlined),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                        
                      // Action Buttons
                      Container(
                        padding: const EdgeInsets.all(20),
                        decoration: BoxDecoration(
                          border: Border(
                            top: BorderSide(color: AppTheme.borderColor),
                          ),
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            TextButton(
                              onPressed: dialogIsSubmitting
                                  ? null
                                  : () {
                                  Navigator.of(dialogContext).pop();
                                  _amountController.clear();
                                  _remarkController.clear();
                                  setState(() {
                                      if (preservedAccountId == null) {
                                    _selectedAccountId = null;
                                      }
                                  });
                                },
                              child: Text(
                                  'Cancel',
                                style: TextStyle(color: AppTheme.primaryColor),
                              ),
                            ),
                            const SizedBox(width: 12),
                            ElevatedButton(
                                onPressed: dialogIsSubmitting ? null : () async {
                                  if (_addAmountWithdrawFormKey.currentState!.validate()) {
                                      final accountId = preservedAccountId ?? _selectedAccountId;
                                      if (accountId == null || accountId.isEmpty) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: const Text('Please select an account'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    setDialogState(() {
                                      dialogIsSubmitting = true;
                                      _isSubmitting = true;
                                    });

                                    try {
                                      final amount = double.parse(_amountController.text);
                                      final remark = _remarkController.text.trim();

                                        final result = await WalletService.withdrawFromAccount(
                                          accountId: accountId,
                                        amount: amount,
                                        remark: remark.isEmpty ? null : remark,
                                      );

                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        if (result['success'] == true) {
                                          Navigator.of(dialogContext).pop();

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                                content: Text(result['message'] ?? 'Amount withdrawn successfully'),
                                              backgroundColor: AppTheme.secondaryColor,
                                              duration: const Duration(seconds: 2),
                                            ),
                                          );

                                          // Clear form
                                          _amountController.clear();
                                          _remarkController.clear();
                                          setState(() {
                                              if (preservedAccountId == null) {
                                            _selectedAccountId = null;
                                              }
                                          });

                                          // Refresh wallet data if available
                                          if (result['wallet'] != null) {
                                            _loadDashboardData();
                                          }

                                          // Refresh All Accounts data
                                          _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                        } else {
                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text(result['message'] ?? 'Operation failed'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    } catch (e) {
                                      if (mounted) {
                                        setDialogState(() {
                                          dialogIsSubmitting = false;
                                          _isSubmitting = false;
                                        });

                                        ScaffoldMessenger.of(context).showSnackBar(
                                          SnackBar(
                                            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                            backgroundColor: AppTheme.errorColor,
                                            duration: const Duration(seconds: 3),
                                          ),
                                        );
                                      }
                                    }
                                  }
                                },
                                style: ElevatedButton.styleFrom(
                                backgroundColor: AppTheme.secondaryColor,
                                  foregroundColor: Colors.white,
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 32,
                                  vertical: 14,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                ),
                                child: dialogIsSubmitting
                                    ? const SizedBox(
                                        width: 20,
                                      height: 20,
                                        child: CircularProgressIndicator(
                                          strokeWidth: 2,
                                        valueColor:
                                            AlwaysStoppedAnimation<Color>(Colors.white),
                                        ),
                                      )
                                    : const Text(
                                      'Submit',
                                      style: TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                              ),
                            ),
                          ],
                        ),
                        ),
                      ],
                  ),
                ),
              ),
            );
          },
        );
      },
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Edit transaction from flagged item
  Future<void> _showEditTransactionFromFlagged(Map<String, dynamic> data, bool isMobile, bool isTablet) async {
    print('\nüö© ===== EDIT TRANSACTION FROM FLAGGED =====');
    print('üö© [EDIT FROM FLAGGED] Opening edit dialog for flagged transaction');
    try {
      final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
      final category = data['category']?.toString().toLowerCase() ?? '';
      print('üö© [EDIT FROM FLAGGED] Category: $category');
      
      // Get transaction ID - check multiple sources
      final transactionId = data['id']?.toString() ?? 
                            financialData['transactionId']?.toString() ?? 
                            '';
      print('üö© [EDIT FROM FLAGGED] Transaction ID: $transactionId');
      
      if (transactionId == '' || transactionId == 'N/A') {
        print('üö© [EDIT FROM FLAGGED] ‚ùå Transaction ID not found!');
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Transaction ID not found'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }
      
      // Extract transaction data - check both data and financialData
      final amount = (data['amount'] as num?)?.toDouble() ?? 
                    (financialData['amount'] as num?)?.toDouble() ?? 0.0;
      final paymentMode = data['mode']?.toString() ?? 
                         financialData['paymentMode']?.toString() ?? 
                         financialData['mode']?.toString() ?? 'Cash';
      final purpose = data['purpose']?.toString() ?? 
                     financialData['purpose']?.toString() ?? '';
      final proofUrl = data['proofUrl']?.toString() ?? 
                      financialData['proofUrl']?.toString();
      
      print('üö© [EDIT FROM FLAGGED] Transaction data:');
      print('   amount: $amount');
      print('   mode: $paymentMode');
      print('   purpose: $purpose');
      
      // Prepare transaction data for edit mode
      final existingTransactionData = {
        'transactionId': transactionId,
        'amount': amount,
        'mode': paymentMode,
        'purpose': purpose,
        'proofUrl': proofUrl,
        'fromFlaggedItem': true, // Flag to indicate this is from a flagged item
        'flaggedItemId': transactionId,
        'flaggedItemCategory': category,
      };
      
      print('üö© [EDIT FROM FLAGGED] ‚úÖ Prepared existingTransactionData:');
      print('   transactionId: ${existingTransactionData['transactionId']}');
      print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
      print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
      print('   flaggedItemCategory: ${existingTransactionData['flaggedItemCategory']}');
      // Safe debug logging
      try {
        debugPrint('üö© [EDIT FROM FLAGGED] Opening _showNewAddTransactionDialog...');
        debugPrint('==========================================\n');
      } catch (e) {
        // Ignore debug errors
      }
      
      // Open transaction form in edit mode
      await _showNewAddTransactionDialog(
        existingTransactionData: existingTransactionData,
        isEditMode: true,
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening edit form: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Edit expense from flagged item
  Future<void> _showEditExpenseFromFlagged(Map<String, dynamic> data, bool isMobile, bool isTablet) async {
    try {
      // Check permissions before allowing edit (must match backend exactly)
      // Admin/SuperAdmin always have access (matches backend middleware)
      final userRole = await AuthService.getUserRole();
      final isAdmin = userRole == 'Admin';
      final isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
      final hasManagePermission = await UIPermissionChecker.hasPermission('expenses.manage');
      final hasEditPermission = await UIPermissionChecker.hasPermission('wallet.all.expenses.edit');
      
      if (!isAdmin && !isSuperAdmin && !hasManagePermission && !hasEditPermission) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('You do not have permission to edit expenses'),
              backgroundColor: AppTheme.errorColor,
            ),
          );
        }
        return;
      }
      
      final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
      final category = data['category']?.toString().toLowerCase() ?? '';
      
      // Get expense ID
      final expenseId = financialData['expenseId'] ?? financialData['transactionId'] ?? '';
      if (expenseId == '' || expenseId == 'N/A') {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Expense ID not found'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }
      
      // Extract expense data
      final amount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
      final paymentMode = financialData['paymentMode']?.toString() ?? financialData['mode']?.toString() ?? 'Cash';
      final expenseType = financialData['expenseType']?.toString() ?? financialData['category']?.toString() ?? '';
      final account = financialData['account']?.toString() ?? '';
      final accountId = financialData['accountId']?.toString();
      final description = financialData['description']?.toString() ?? '';
      final proofUrl = financialData['proofUrl']?.toString();
      
      // Prepare expense data for edit mode
      final existingExpenseData = {
        'expenseId': expenseId,
        'id': expenseId, // Also set 'id' for compatibility with other code paths
        'amount': amount,
        'mode': paymentMode,
        'category': expenseType,
        'description': description,
        'proofUrl': proofUrl,
        'account': account,
        'accountId': accountId,
        'fromFlaggedItem': true, // Flag to indicate this is from a flagged item
        'flaggedItemId': expenseId,
        'flaggedItemCategory': category,
      };
      
      // Open expense form in edit mode
      await _showNewAddExpensesDialog(
        existingExpenseData: existingExpenseData,
        isEditMode: true,
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening edit form: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Edit collection from flagged item
  Future<void> _showEditCollectionFromFlagged(Map<String, dynamic> data, bool isMobile, bool isTablet) async {
    try {
      final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
      final category = data['category']?.toString().toLowerCase() ?? '';
      
      // Get collection ID - check multiple sources
      final collectionId = data['id']?.toString() ?? 
                          financialData['collectionId']?.toString() ?? 
                          financialData['transactionId']?.toString() ?? 
                          '';
      if (collectionId == '' || collectionId == 'N/A') {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Collection ID not found'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }
      
      // Extract collection data - check both data and financialData
      final amount = (data['amount'] as num?)?.toDouble() ?? 
                    (financialData['amount'] as num?)?.toDouble() ?? 0.0;
      final paymentMode = data['mode']?.toString() ?? 
                         financialData['paymentMode']?.toString() ?? 
                         financialData['mode']?.toString() ?? 'Cash';
      final customerName = data['customerName']?.toString() ?? 
                          financialData['customerName']?.toString() ?? '';
      final notes = data['notes']?.toString() ?? 
                   financialData['notes']?.toString() ?? 
                   financialData['description']?.toString() ?? '';
      final proofUrl = data['proofUrl']?.toString() ?? 
                      financialData['proofUrl']?.toString();
      final paymentModeId = data['paymentModeId']?.toString() ?? 
                           financialData['paymentModeId']?.toString();
      
      // Prepare collection data for edit mode
      final collectionData = {
        'id': collectionId,
        'collectionId': collectionId,
        'amount': amount,
        'mode': paymentMode,
        'customerName': customerName,
        'notes': notes,
        if (proofUrl != null) 'proofUrl': proofUrl,
        if (paymentModeId != null) 'paymentModeId': paymentModeId,
        'fromFlaggedItem': true, // Flag to indicate this is from a flagged item
        'flaggedItemId': collectionId,
        'flaggedItemCategory': category,
      };
      
      // Open collection edit dialog
      _showEditCollectionDialog(collectionData);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening edit form: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // New Add Expenses Dialog with improved UI
  Future<void> _showNewAddExpensesDialog({Map<String, dynamic>? existingExpenseData, bool isEditMode = false}) async {
    try {
      // Load accounts in background if needed (don't wait)
      if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
        _loadAccountsList();
      }
      
      // Reset or pre-fill form state based on edit mode
      bool dialogIsSubmitting = false;
      
      // Preserve selected account if already set
      final String? preservedAccountId = _selectedExpenseAccountId;
      
      if (isEditMode && existingExpenseData != null) {
        // Pre-fill data for edit mode
        final amount = existingExpenseData['amount'] ?? 0.0;
        final mode = existingExpenseData['mode']?.toString() ?? 'Cash';
        final category = existingExpenseData['category']?.toString() ?? '';
        final description = existingExpenseData['description']?.toString() ?? '';
        final remarks = existingExpenseData['remarks']?.toString() ?? '';
        final accountId = existingExpenseData['accountId']?.toString();
        final proofUrl = existingExpenseData['proofUrl']?.toString();
        
        // Find expense type from category
        Map<String, dynamic>? selectedType;
        if (category.isNotEmpty) {
          selectedType = _expenseTypesWithImages.firstWhere(
            (type) => type['name']?.toString().toLowerCase() == category.toLowerCase(),
            orElse: () => <String, dynamic>{},
          );
          if (selectedType.isEmpty) {
            // Try to find in categories
            selectedType = {
              'name': category,
              'imageUrl': _getExpenseTypeImageUrl(category),
            };
          }
        }
        
        _expenseAmountController.text = amount.toString();
        _expenseDescriptionController.text = description;
        _expenseRemarkController.text = remarks;
        
        setState(() {
          _expenseDialogStep = 2; // Start with step 2 (details) in edit mode
          _selectedExpenseTypeForDialog = selectedType?.isNotEmpty == true ? selectedType : null;
          _selectedExpenseCategory = category.isNotEmpty ? category : 'Office';
          _selectedExpenseMode = mode;
          _selectedExpensePaymentAccountId = accountId;
          // XFile is for local files only, so set to null if we have a URL
          // The existing proofUrl will be stored in existingExpenseData and used during submission
          _selectedExpenseProofImage = null;
        });
      } else {
        // Reset for add mode
        _expenseAmountController.clear();
        _expenseDescriptionController.clear();
        _expenseRemarkController.clear();
        
        setState(() {
          _expenseDialogStep = 1; // Start with step 1
          _selectedExpenseTypeForDialog = null; // Reset selected type
          _selectedExpenseCategory = 'Office';
          _selectedExpenseMode = 'Cash';
          _selectedExpensePaymentAccountId = null;
          _selectedExpenseProofImage = null;
        });
      }
      _addExpenseFormKey.currentState?.reset();

    final isMobile = Responsive.isMobile(context);
    final isTablet = Responsive.isTablet(context);
      final ImagePicker imagePicker = ImagePicker();

      if (!mounted) return;
      
      await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return StatefulBuilder(
            builder: (context, setDialogState) {
              // Filter accounts by type for payment mode
              final filteredPaymentAccounts = _selectedExpenseMode != 'Cash'
                  ? _allAccountsList.where((account) {
                      final accountType = account['type']?.toString() ?? '';
                      return accountType == _selectedExpenseMode;
                    }).toList()
                  : <Map<String, dynamic>>[];

              return Dialog(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
                backgroundColor: Colors.white,
                child: Container(
          constraints: BoxConstraints(
                    maxWidth: isMobile ? double.infinity : (isTablet ? 700 : 800),
                    maxHeight: MediaQuery.of(context).size.height * (isMobile ? 0.95 : 0.85),
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                  ),
              padding: EdgeInsets.zero,
                  child: _expenseDialogStep == 1
                      ? _buildExpenseTypeSelectionStep(
                          context: context,
                          setDialogState: setDialogState,
                          isMobile: isMobile,
                          isTablet: isTablet,
                          isEditMode: isEditMode,
                        )
                      : _buildExpenseDetailsStep(
                          context: context,
                          dialogContext: dialogContext,
                          setDialogState: setDialogState,
                          isMobile: isMobile,
                          isTablet: isTablet,
                          imagePicker: imagePicker,
                          preservedAccountId: preservedAccountId,
                          dialogIsSubmitting: dialogIsSubmitting,
                          isEditMode: isEditMode,
                          existingExpenseData: existingExpenseData,
                        ),
                ),
              );
            },
          );
        },
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Step 1: Expense Type Selection
  Widget _buildExpenseTypeSelectionStep({
    required BuildContext context,
    required StateSetter setDialogState,
    required bool isMobile,
    required bool isTablet,
    bool isEditMode = false,
  }) {
    // Get expense types with images
    final expenseTypes = _expenseTypesWithImages.isNotEmpty
        ? _expenseTypesWithImages
        : _expenseCategories.map((name) => <String, dynamic>{
              'name': name,
              'imageUrl': _getExpenseTypeImageUrl(name),
            }).toList();

    return LayoutBuilder(
      builder: (context, constraints) {
    return isMobile
        ? ConstrainedBox(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(context).size.height * 0.9,
            ),
            child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
                // Header
                              Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                    decoration: BoxDecoration(
                                      color: AppTheme.warningColor,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(16),
              topRight: Radius.circular(16),
                                    ),
          ),
          child: Row(
            children: [
              Icon(
                                      Icons.receipt_long,
                                      color: Colors.white,
                        size: 18,
                              ),
                      const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                  'Select Expense Type',
                                  style: AppTheme.headingMedium.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                            fontSize: 14,
                  ),
                ),
              ),
                      IconButton(
                        onPressed: () => Navigator.pop(context),
                        icon: const Icon(
                          Icons.close_rounded,
                      color: Colors.white,
                      size: 18,
                        ),
                        tooltip: 'Close',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(
                          minWidth: 28,
                          minHeight: 28,
                        ),
                      ),
                    ],
                  ),
                ),
                // Scrollable Content
                Flexible(
                  child: SingleChildScrollView(
                    padding: const EdgeInsets.fromLTRB(10, 8, 10, 6),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          'Choose an expense category',
                          style: AppTheme.bodyMedium.copyWith(
                            color: AppTheme.textSecondary,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        // Expense Type Grid
                        GridView.builder(
                          shrinkWrap: true,
                          physics: const NeverScrollableScrollPhysics(),
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 3,
                            crossAxisSpacing: 6,
                            mainAxisSpacing: 6,
                            childAspectRatio: 0.95,
                          ),
                          itemCount: expenseTypes.length,
                          itemBuilder: (context, index) {
                            final expenseType = expenseTypes[index];
                            final typeName = expenseType['name']?.toString() ?? '';
                            final imageUrl = expenseType['imageUrl']?.toString();
                            final isSelected = _selectedExpenseTypeForDialog != null &&
                                _selectedExpenseTypeForDialog!['name'] == typeName;

                            return InkWell(
                              onTap: () {
                                setState(() {
                                  _selectedExpenseTypeForDialog = expenseType;
                                  _selectedExpenseCategory = typeName;
                                });
                                setDialogState(() {});
                              },
                              borderRadius: BorderRadius.circular(8),
                              child: Container(
                                decoration: BoxDecoration(
                                  color: isSelected
                                      ? AppTheme.warningColor.withOpacity(0.1)
                                      : Colors.white,
                                  borderRadius: BorderRadius.circular(8),
                                  border: Border.all(
                                    color: isSelected
                                        ? AppTheme.warningColor
                                        : AppTheme.borderColor,
                                    width: isSelected ? 1.5 : 0.5,
                                  ),
                                ),
                                child: Padding(
                                  padding: const EdgeInsets.all(4),
                                  child: Column(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      // Image
                                      Expanded(
                                        flex: 3,
                                        child: Container(
                                          width: double.infinity,
                                          decoration: BoxDecoration(
                                            borderRadius: BorderRadius.circular(4),
                                            border: Border.all(
                                              color: AppTheme.borderColor.withOpacity(0.3),
                                              width: 0.5,
                                            ),
                                          ),
                                          child: ClipRRect(
                                            borderRadius: BorderRadius.circular(4),
                                            child: imageUrl != null && imageUrl.isNotEmpty
                                                ? Image.network(
                                                    imageUrl,
                                                    fit: BoxFit.cover,
                                                    errorBuilder: (context, error, stackTrace) {
                                                      return Icon(
                                                        Icons.category_outlined,
                                                        size: 18,
                                                        color: AppTheme.textSecondary,
                                                      );
                                                    },
                                                  )
                                                : Icon(
                                                    Icons.category_outlined,
                                                    size: 18,
                                                    color: AppTheme.textSecondary,
                                                  ),
                                          ),
                                        ),
                                      ),
                                      const SizedBox(height: 2),
                                      // Name
                                      Expanded(
                                        flex: 1,
                                        child: Center(
                                          child: Text(
                                            typeName,
                                            style: AppTheme.bodyMedium.copyWith(
                                              fontWeight: isSelected
                                                  ? FontWeight.w600
                                                  : FontWeight.normal,
                                              fontSize: 9,
                                              color: isSelected
                                                  ? AppTheme.warningColor
                                                  : AppTheme.textPrimary,
                                            ),
                                            textAlign: TextAlign.center,
                                            maxLines: 1,
                                            overflow: TextOverflow.ellipsis,
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ],
                    ),
                  ),
                ),
                // Continue Button at Bottom
                Container(
                  padding: const EdgeInsets.fromLTRB(10, 8, 10, 8),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 8,
                        offset: const Offset(0, -2),
                      ),
                    ],
                  ),
                  child: SizedBox(
                    width: double.infinity,
                    child: ElevatedButton(
                      onPressed: _selectedExpenseTypeForDialog == null
                          ? null
                          : () {
                              setState(() {
                                _expenseDialogStep = 2;
                              });
                              setDialogState(() {});
                            },
                      style: ElevatedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 10),
                        backgroundColor: AppTheme.warningColor,
                        foregroundColor: Colors.white,
                        disabledBackgroundColor: AppTheme.borderColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            'Continue',
                            style: const TextStyle(
                              fontSize: 13,
                              fontWeight: FontWeight.w600,
                            ),
                    ),
                    const SizedBox(width: 6),
                          Icon(
                            Icons.arrow_forward_rounded,
                            size: 15,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          )
        : Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Header with User Name
                    Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [
                      AppTheme.warningColor,
                      AppTheme.warningColor.withOpacity(0.95),
                    ],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: AppTheme.warningColor.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: const Icon(
                        Icons.receipt_long,
                        color: Colors.white,
                        size: 24,
                      ),
                      ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Text(
                        'Select Expense Type',
                        style: AppTheme.headingMedium.copyWith(
                          color: Colors.white,
                          fontWeight: FontWeight.w700,
                          fontSize: 21,
                          letterSpacing: 0.3,
                        ),
                      ),
                    ),
                    // User name on the right
                    if (_userName != null)
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 10,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.white.withOpacity(0.25),
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Colors.white.withOpacity(0.3),
                            width: 1,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.person_outline,
                              color: Colors.white,
                              size: 18,
                            ),
                            const SizedBox(width: 8),
                            Text(
                        _userName!,
                        style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.w600,
                          fontSize: 14,
                                letterSpacing: 0.2,
                              ),
                            ),
                          ],
                                ),
                              ),
                    const SizedBox(width: 16),
                    // Close button
                    Container(
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: IconButton(
                onPressed: () => Navigator.pop(context),
                        icon: const Icon(
                  Icons.close_rounded,
                  color: Colors.white,
                          size: 22,
                ),
                tooltip: 'Close',
                        padding: const EdgeInsets.all(8),
                        constraints: const BoxConstraints(
                          minWidth: 36,
                          minHeight: 36,
                        ),
                      ),
                ),
            ],
          ),
                          ),
              // Content area with proper padding
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: AppTheme.surfaceColor.withOpacity(0.3),
                  ),
          child: SingleChildScrollView(
                    padding: const EdgeInsets.fromLTRB(24, 24, 24, 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // Instructions text
                        Text(
                          'Choose an expense category',
                          style: AppTheme.bodyMedium.copyWith(
                            color: AppTheme.textSecondary,
                            fontSize: 15,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 16),
                        // Expense Type Grid
                        GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 4,
                            crossAxisSpacing: 12,
                            mainAxisSpacing: 12,
                            childAspectRatio: 1.1,
              ),
              itemCount: expenseTypes.length,
              itemBuilder: (context, index) {
                final expenseType = expenseTypes[index];
                final typeName = expenseType['name']?.toString() ?? '';
                final imageUrl = expenseType['imageUrl']?.toString();
                final isSelected = _selectedExpenseTypeForDialog != null &&
                    _selectedExpenseTypeForDialog!['name'] == typeName;

                            return Material(
                              color: Colors.transparent,
                              child: InkWell(
                  onTap: () {
                    setState(() {
                      _selectedExpenseTypeForDialog = expenseType;
                      _selectedExpenseCategory = typeName;
                    });
                    setDialogState(() {});
                  },
                                borderRadius: BorderRadius.circular(18),
                                child: AnimatedContainer(
                                  duration: const Duration(milliseconds: 250),
                                  curve: Curves.easeInOut,
                                  decoration: BoxDecoration(
                      color: isSelected
                                        ? AppTheme.warningColor.withOpacity(0.12)
                          : Colors.white,
                                    borderRadius: BorderRadius.circular(18),
                      border: Border.all(
                        color: isSelected
                            ? AppTheme.warningColor
                                          : AppTheme.borderColor.withOpacity(0.4),
                                      width: isSelected ? 2.5 : 1.5,
                      ),
                                    boxShadow: isSelected
                                        ? [
                                            BoxShadow(
                                              color: AppTheme.warningColor.withOpacity(0.25),
                                              blurRadius: 12,
                                              offset: const Offset(0, 6),
                                              spreadRadius: 0,
                                            ),
                                          ]
                                        : [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.06),
                                              blurRadius: 6,
                                              offset: const Offset(0, 3),
                                              spreadRadius: 0,
                                            ),
                                          ],
                                  ),
                    child: Padding(
                                    padding: const EdgeInsets.all(12),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        mainAxisSize: MainAxisSize.min,
                                    children: [
                                        // Image with selection indicator
                                        Stack(
                                          children: [
                        Container(
                                              width: 75,
                                              height: 75,
                                              margin: const EdgeInsets.only(bottom: 8),
                          decoration: BoxDecoration(
                                                borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                                                  color: isSelected
                                                      ? AppTheme.warningColor.withOpacity(0.4)
                                                      : AppTheme.borderColor.withOpacity(0.3),
                                                  width: isSelected ? 2 : 1.5,
                                                ),
                                                boxShadow: [
                                                  BoxShadow(
                                                    color: Colors.black.withOpacity(0.05),
                                                    blurRadius: 4,
                                                    offset: const Offset(0, 2),
                            ),
                                                ],
                          ),
                          child: ClipRRect(
                                                borderRadius: BorderRadius.circular(14),
                            child: imageUrl != null && imageUrl.isNotEmpty
                                ? Image.network(
                                    imageUrl,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                                          return Container(
                                                            color: AppTheme.surfaceColor,
                                                            child: Icon(
                                        Icons.category_outlined,
                                                              size: 40,
                                        color: AppTheme.textSecondary,
                                                            ),
                                      );
                                    },
                                  )
                                                    : Container(
                                                        color: AppTheme.surfaceColor,
                                                        child: Icon(
                                    Icons.category_outlined,
                                                          size: 50,
                                          color: AppTheme.textSecondary,
                                  ),
                          ),
                                              ),
                                            ),
                                            // Selection checkmark
                                            if (isSelected)
                                              Positioned(
                                                top: 2,
                                                right: 2,
                                                child: Container(
                                                  width: 24,
                                                  height: 24,
                                                  decoration: BoxDecoration(
                                                    color: AppTheme.warningColor,
                                                    shape: BoxShape.circle,
                                                    boxShadow: [
                                                      BoxShadow(
                                                        color: AppTheme.warningColor.withOpacity(0.4),
                                                        blurRadius: 3,
                                                        offset: const Offset(0, 2),
                                                      ),
                                                    ],
                                                  ),
                                                  child: const Icon(
                                                    Icons.check,
                                                    color: Colors.white,
                                                    size: 16,
                                                  ),
                                                ),
                                              ),
                                          ],
                        ),
                        // Name
                                        Text(
                            typeName,
                            style: AppTheme.bodyMedium.copyWith(
                              fontWeight: isSelected
                                                ? FontWeight.w700
                                                : FontWeight.w600,
                                            fontSize: 13,
                              color: isSelected
                                  ? AppTheme.warningColor
                                  : AppTheme.textPrimary,
                                            letterSpacing: 0.2,
                            ),
                            textAlign: TextAlign.center,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                                      ),
                                    ],
                                    ),
                                  ),
                    ),
                  ),
                );
              },
            ),
                      ],
          ),
        ),
                ),
              ),
              // Continue Button at Bottom
              Container(
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  color: Colors.white,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 10,
                      offset: const Offset(0, -2),
                    ),
                  ],
                ),
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(14),
                    boxShadow: _selectedExpenseTypeForDialog != null
                        ? [
                            BoxShadow(
                              color: AppTheme.warningColor.withOpacity(0.3),
                              blurRadius: 8,
                              offset: const Offset(0, 4),
                            ),
                          ]
                        : null,
                  ),
          child: ElevatedButton(
            onPressed: _selectedExpenseTypeForDialog == null
                ? null
                : () {
                    setState(() {
                      _expenseDialogStep = 2;
                    });
                    setDialogState(() {});
                  },
            style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 14),
              backgroundColor: AppTheme.warningColor,
              foregroundColor: Colors.white,
                      disabledBackgroundColor: AppTheme.borderColor.withOpacity(0.5),
                      disabledForegroundColor: AppTheme.textSecondary,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14),
                      ),
                      elevation: _selectedExpenseTypeForDialog != null ? 4 : 0,
            ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          'Continue',
                          style: TextStyle(
                            fontSize: 17,
                            fontWeight: FontWeight.w700,
                            letterSpacing: 0.5,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Icon(
                          Icons.arrow_forward_rounded,
                          size: 20,
                        ),
                      ],
                    ),
            ),
          ),
        ),
          ],
        );
      },
    );
  }

  // Step 2: Expense Details Form
  Widget _buildExpenseDetailsStep({
    required BuildContext context,
    required BuildContext dialogContext,
    required StateSetter setDialogState,
    required bool isMobile,
    required bool isTablet,
    required ImagePicker imagePicker,
    required String? preservedAccountId,
    required bool dialogIsSubmitting,
    bool isEditMode = false,
    Map<String, dynamic>? existingExpenseData,
  }) {
    final selectedType = _selectedExpenseTypeForDialog;
    final typeName = selectedType?['name']?.toString() ?? 'Unknown';
    final imageUrl = selectedType?['imageUrl']?.toString();

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
                        // Header with User Name
                        Container(
                          padding: EdgeInsets.all(isMobile ? 10 : 20),
                          decoration: BoxDecoration(
                            color: AppTheme.warningColor,
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(16),
                              topRight: Radius.circular(16),
                            ),
                          ),
                          child: Row(
                            children: [
                              // Selected expense type image
                              Container(
                                width: isMobile ? 32 : 40,
                                height: isMobile ? 32 : 40,
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(8),
                                  border: Border.all(
                                    color: Colors.white.withOpacity(0.3),
                                  ),
                                ),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(8),
                                  child: imageUrl != null && imageUrl.isNotEmpty
                                      ? Image.network(
                                          imageUrl,
                                          fit: BoxFit.cover,
                                          errorBuilder: (context, error, stackTrace) {
                                            return Icon(
                                              Icons.category_outlined,
                                              size: isMobile ? 18 : 24,
                                              color: Colors.white,
                                            );
                                          },
                                        )
                                      : Icon(
                                          Icons.category_outlined,
                                          size: isMobile ? 18 : 24,
                                          color: Colors.white,
                                        ),
                                ),
                                ),
                              SizedBox(width: isMobile ? 8 : 12),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Text(
                                      isEditMode ? 'Edit Expense' : 'Add Expense',
                                      style: AppTheme.headingMedium.copyWith(
                                        color: Colors.white,
                                        fontWeight: FontWeight.bold,
                                        fontSize: isMobile ? 16 : null,
                                      ),
                                    ),
                                    SizedBox(height: isMobile ? 2 : 4),
                                    Text(
                                      typeName,
                                      style: TextStyle(
                                        color: Colors.white70,
                                        fontWeight: FontWeight.w500,
                                        fontSize: isMobile ? 12 : 14,
                                      ),
                            ),
                                  ],
                                ),
                              ),
                              // User name on the right - hide on mobile to prevent overflow
                              if (_userName != null && !isMobile)
                                Row(
                                  children: [
                                    const Icon(
                                      Icons.person,
                                      color: Colors.white,
                                      size: 18,
                                    ),
                                    const SizedBox(width: 6),
                                    Container(
                                      padding: const EdgeInsets.symmetric(
                                        horizontal: 12,
                                        vertical: 6,
                                      ),
                                      decoration: BoxDecoration(
                                        color: Colors.white.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: Text(
                                        _userName!,
                                        style: const TextStyle(
                                          color: Colors.white,
                                          fontWeight: FontWeight.w600,
                                          fontSize: 14,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                            ],
                          ),
                        ),

                        // Form Content
                        Flexible(
                          child: SingleChildScrollView(
                            padding: EdgeInsets.all(isMobile ? 12 : 24),
                            child: Form(
                              key: _addExpenseFormKey,
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.stretch,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                          // Amount Input
                          TextFormField(
                            controller: _expenseAmountController,
                            keyboardType: const TextInputType.numberWithOptions(decimal: true),
                            inputFormatters: [
                              FilteringTextInputFormatter.allow(RegExp(r'^\d+\.?\d{0,2}')),
                            ],
                                    decoration: InputDecoration(
                                      labelText: 'Amount',
                                      prefixIcon: const Icon(Icons.currency_rupee),
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                            ),
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return 'Please enter an amount';
                              }
                              final amount = double.tryParse(value);
                              if (amount == null || amount <= 0) {
                                return 'Please enter a valid amount';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: isMobile ? 16 : 20),
                          
                          // Remark Input (Optional)
                          TextFormField(
                            controller: _expenseRemarkController,
                            maxLines: 3,
                            enabled: !dialogIsSubmitting,
                            decoration: InputDecoration(
                              labelText: 'Remark (Optional)',
                              hintText: 'Enter remark',
                              prefixIcon: const Icon(Icons.note_outlined),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                            ),
                          ),
                          SizedBox(height: isMobile ? 16 : 20),
                          
                          // Proof Image Upload
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Text(
                                    'Proof:',
                                    style: AppTheme.labelMedium.copyWith(
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 8,
                                      vertical: 4,
                                    ),
                                    decoration: BoxDecoration(
                                      color: _isProofRequiredForSelectedType()
                                          ? AppTheme.errorColor.withOpacity(0.1)
                                          : AppTheme.secondaryColor.withOpacity(0.1),
                                      borderRadius: BorderRadius.circular(6),
                                      border: Border.all(
                                        color: _isProofRequiredForSelectedType()
                                            ? AppTheme.errorColor.withOpacity(0.3)
                                            : AppTheme.secondaryColor.withOpacity(0.3),
                                        width: 1,
                                      ),
                                    ),
                                    child: Text(
                                      _isProofRequiredForSelectedType() ? 'Mandatory' : 'Optional',
                                      style: AppTheme.bodySmall.copyWith(
                                        color: _isProofRequiredForSelectedType()
                                            ? AppTheme.errorColor
                                            : AppTheme.secondaryColor,
                                        fontWeight: FontWeight.w600,
                                        fontSize: 11,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 8),
                              InkWell(
                                onTap: dialogIsSubmitting
                                                  ? null
                                                  : () async {
                                        try {
                                                        final XFile? image =
                                                            await imagePicker.pickImage(
                                            source: ImageSource.gallery,
                                          );
                                          if (image != null) {
                                            setState(() {
                                              _selectedExpenseProofImage = image;
                                            });
                                            setDialogState(() {});
                                          }
                                        } catch (e) {
                                          if (mounted) {
                                            ScaffoldMessenger.of(context)
                                                .showSnackBar(
                                              SnackBar(
                                                              content: Text(
                                                                  'Error picking image: ${e.toString()}'),
                                                backgroundColor: AppTheme.errorColor,
                                              ),
                                            );
                                          }
                                        }
                                      },
                                          child: Container(
                                  height: isMobile ? 100 : 120,
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color: AppTheme.borderColor,
                                      width: 2,
                                      style: BorderStyle.solid,
                                  ),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: _selectedExpenseProofImage != null
                                      ? Stack(
                                          children: [
                                            ClipRRect(
                                              borderRadius:
                                                  BorderRadius.circular(10),
                                              child: kIsWeb
                                                  ? FutureBuilder<Uint8List>(
                                                      future:
                                                          _selectedExpenseProofImage!
                                                              .readAsBytes(),
                                                      builder:
                                                          (context, snapshot) {
                                                        if (snapshot
                                                                .connectionState ==
                                                            ConnectionState
                                                                .waiting) {
                                                          return const Center(
                                                            child:
                                                                CircularProgressIndicator(
                                                                    strokeWidth:
                                                                        2),
                                                          );
                                                        }
                                                        if (snapshot.hasData) {
                                                          return Image.memory(
                                                            snapshot.data!,
                                                            width:
                                                                double.infinity,
                                                            height:
                                                                double.infinity,
                                      fit: BoxFit.cover,
                                                          );
                                                        }
                                                        return const Center(
                                                          child: Icon(
                                                            Icons.error_outline,
                                                            size: 20,
                                                          ),
                                                        );
                                                      },
                                                    )
                                                  : FutureBuilder<Uint8List>(
                                                      future:
                                                          _selectedExpenseProofImage!
                                                              .readAsBytes(),
                                                      builder:
                                                          (context, snapshot) {
                                                        if (snapshot
                                                                .connectionState ==
                                                            ConnectionState
                                                                .waiting) {
                                                          return const Center(
                                                            child:
                                                                CircularProgressIndicator(
                                                                    strokeWidth:
                                                                        2),
                                                          );
                                                        }
                                                        if (snapshot.hasData) {
                                                          return Image.memory(
                                                            snapshot.data!,
                                                            width:
                                                                double.infinity,
                                                            height:
                                                                double.infinity,
                                                            fit: BoxFit.cover,
                                                          );
                                                        }
                                                        return const Center(
                                                          child: Icon(
                                                            Icons.error_outline,
                                                            size: 20,
                                                          ),
                                                        );
                                                      },
                                                    ),
                                    ),
                                            Positioned(
                                              top: 8,
                                              right: 8,
                                              child: IconButton(
                                                icon: const Icon(Icons.close),
                                                color: Colors.white,
                                                style: IconButton.styleFrom(
                                                  backgroundColor:
                                                      Colors.black54,
                                                ),
                                                onPressed: dialogIsSubmitting
                                                    ? null
                                                    : () {
                                                        setState(() {
                                                          _selectedExpenseProofImage = null;
                                                        });
                                                        setDialogState(() {});
                                                      },
                                  ),
                                ),
                              ],
                                        )
                                      : Center(
                                          child: Column(
                                            mainAxisAlignment:
                                                MainAxisAlignment.center,
                                            children: [
                                              Stack(
                                                alignment: Alignment.center,
                                                children: [
                                                  Icon(
                                                    Icons
                                                        .add_photo_alternate_outlined,
                                                    size: 40,
                                                    color: AppTheme.textSecondary,
                                                  ),
                                                  Positioned(
                                                    top: -8,
                                                    right: -8,
                                                    child: Container(
                                                      padding:
                                                          const EdgeInsets.all(
                                                              2),
                                                      decoration: BoxDecoration(
                                                        color: AppTheme
                                                            .textSecondary,
                                                        shape: BoxShape.circle,
                                                      ),
                                                      child: const Icon(
                                                        Icons.add,
                                                        size: 16,
                                                        color: Colors.white,
                                                      ),
                                                    ),
                                                  ),
                                                ],
                                              ),
                                              const SizedBox(height: 8),
                                              Text(
                                                'Tap to add proof image',
                                                style: TextStyle(
                                                  color: AppTheme.textSecondary,
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                ),
                              ),
                            ],
                          ),
                                ],
                              ),
                            ),
                          ),
                        ),
                          
                        // Action Buttons
                        Container(
                          padding: EdgeInsets.all(isMobile ? 12 : 20),
                          decoration: BoxDecoration(
                            border: Border(
                              top: BorderSide(color: AppTheme.borderColor),
                            ),
                          ),
                          child: isMobile
                              ? Column(
                                  mainAxisSize: MainAxisSize.min,
                                  crossAxisAlignment: CrossAxisAlignment.stretch,
                                  children: [
                                    Builder(
                                      builder: (context) {
                                        // Check if button should be disabled
                                        final isProofRequired = _isProofRequiredForSelectedType();
                                        final hasNewProof = _selectedExpenseProofImage != null;
                                        final hasExistingProof = isEditMode && 
                                            existingExpenseData != null && 
                                            existingExpenseData!['proofUrl'] != null &&
                                            existingExpenseData!['proofUrl'].toString().isNotEmpty;
                                        final hasProof = hasNewProof || hasExistingProof;
                                        
                                        final shouldDisable = dialogIsSubmitting || 
                                            (isProofRequired && !hasProof);
                                        
                                        return SizedBox(
                                          width: double.infinity,
                                          child: ElevatedButton(
                                            onPressed: shouldDisable
                                                ? null
                                                : () async {
                                                    // Validate proof requirement FIRST (before form validation)
                                                    final isProofRequired = _isProofRequiredForSelectedType();
                                                    final hasProof = _selectedExpenseProofImage != null || 
                                                        (isEditMode && existingExpenseData?['proofUrl'] != null &&
                                                         existingExpenseData!['proofUrl'].toString().isNotEmpty);
                                                    
                                                    if (isProofRequired && !hasProof) {
                                                      if (mounted) {
                                                        ScaffoldMessenger.of(context).showSnackBar(
                                                          const SnackBar(
                                                            content: Text('Proof image is mandatory for this expense type. Please upload a proof image.'),
                                                            backgroundColor: AppTheme.errorColor,
                                                            duration: Duration(seconds: 3),
                                                          ),
                                                        );
                                                      }
                                                      return; // Stop here - don't proceed with form validation
                                                    }
                                                    
                                                    // Only proceed with form validation if proof requirement is met
                                                    if (_addExpenseFormKey.currentState!.validate()) {
                                                      setDialogState(() {
                                                        dialogIsSubmitting = true;
                                                      });

                                                      try {
                                                        final amountText = _expenseAmountController.text.trim();
                                                        if (amountText.isEmpty) {
                                                          setDialogState(() {
                                                            dialogIsSubmitting = false;
                                                          });
                                                          if (mounted) {
                                                            ScaffoldMessenger.of(context).showSnackBar(
                                                              const SnackBar(
                                                                content: Text('Please enter an amount'),
                                                                backgroundColor: AppTheme.errorColor,
                                                              ),
                                                            );
                                                          }
                                                          return;
                                                        }
                                                        
                                                        final amount = double.tryParse(amountText);
                                                        if (amount == null || amount <= 0 || amount.isNaN || amount.isInfinite) {
                                                          setDialogState(() {
                                                            dialogIsSubmitting = false;
                                                          });
                                                          if (mounted) {
                                                            ScaffoldMessenger.of(context).showSnackBar(
                                                              const SnackBar(
                                                                content: Text('Please enter a valid amount'),
                                                                backgroundColor: AppTheme.errorColor,
                                                              ),
                                                            );
                                                          }
                                                          return;
                                                        }
                                                        
                                                        final description = _expenseDescriptionController.text.trim();
                                                        final remark = _expenseRemarkController.text.trim();
                                                        
                                                        // Upload image if selected and get URL
                                                        String? proofUrl;
                                                        if (_selectedExpenseProofImage != null) {
                                                          // Upload the new image
                                                          setDialogState(() {
                                                            dialogIsSubmitting = true;
                                                          });
                                                          
                                                          final uploadResult = await ExpenseService.uploadProofImage(
                                                            _selectedExpenseProofImage!,
                                                          );
                                                          
                                                          if (uploadResult['success'] == true) {
                                                            proofUrl = uploadResult['imageUrl']?.toString();
                                                          } else {
                                                            setDialogState(() {
                                                              dialogIsSubmitting = false;
                                                            });
                                                            if (mounted) {
                                                              ScaffoldMessenger.of(context).showSnackBar(
                                                                SnackBar(
                                                                  content: Text(uploadResult['message']?.toString() ?? 'Failed to upload proof image'),
                                                                  backgroundColor: AppTheme.errorColor,
                                                                ),
                                                              );
                                                            }
                                                            return;
                                                          }
                                                        } else if (isEditMode && existingExpenseData?['proofUrl'] != null) {
                                                          // Keep existing proof URL in edit mode
                                                          proofUrl = existingExpenseData!['proofUrl'].toString();
                                                        }
                                                        
                                                        // Submit expense
                                                        if (isEditMode) {
                                                          // Validate expense ID before updating
                                                          final expenseId = existingExpenseData!['expenseId']?.toString() ?? existingExpenseData!['id']?.toString() ?? '';
                                                          if (expenseId.isEmpty || expenseId == 'N/A') {
                                                            if (mounted) {
                                                              setDialogState(() {
                                                                dialogIsSubmitting = false;
                                                              });
                                                              ScaffoldMessenger.of(context).showSnackBar(
                                                                SnackBar(
                                                                  content: Text('Invalid expense ID. Cannot update expense without valid ID.'),
                                                                  backgroundColor: AppTheme.errorColor,
                                                                ),
                                                              );
                                                            }
                                                            return;
                                                          }
                                                        }
                                                        
                                                        final result = isEditMode
                                                            ? await ExpenseService.updateExpense(
                                                                existingExpenseData!['expenseId']?.toString() ?? existingExpenseData!['id']?.toString() ?? '',
                                                                category: _selectedExpenseCategory,
                                                                amount: amount,
                                                                mode: _selectedExpenseMode,
                                                                description: description,
                                                                remarks: remark.isNotEmpty ? remark : null,
                                                                proofUrl: proofUrl,
                                                                fromAllWalletReport: _selectedItem == NavItem.accountReports,
                                                              )
                                                            : await ExpenseService.createExpense(
                                                                category: _selectedExpenseCategory,
                                                                amount: amount,
                                                                mode: _selectedExpenseMode,
                                                                description: description,
                                                                remarks: remark.isNotEmpty ? remark : null,
                                                                proofUrl: proofUrl,
                                                              );
                                                        
                                                        if (mounted) {
                                                          setDialogState(() {
                                                            dialogIsSubmitting = false;
                                                          });
                                                          
                                                          if (result['success'] == true) {
                                                            Navigator.pop(context);
                                                            ScaffoldMessenger.of(context).showSnackBar(
                                                              SnackBar(
                                                                content: Text(result['message']?.toString() ?? 
                                                                    (isEditMode ? 'Expense updated successfully' : 'Expense added successfully')),
                                                                backgroundColor: AppTheme.secondaryColor,
                                                              ),
                                                            );
                                                            
                                                            // Refresh dashboard data
                                                            _loadDashboardData();
                                                            _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
                                                          } else {
                                                            ScaffoldMessenger.of(context).showSnackBar(
                                                              SnackBar(
                                                                content: Text(result['message']?.toString() ?? 'Failed to ${isEditMode ? 'update' : 'add'} expense'),
                                                                backgroundColor: AppTheme.errorColor,
                                                              ),
                                                            );
                                                          }
                                                        }
                                                      } catch (e) {
                                                        if (mounted) {
                                                          setDialogState(() {
                                                            dialogIsSubmitting = false;
                                                          });
                                                          ScaffoldMessenger.of(context).showSnackBar(
                                                            SnackBar(
                                                              content: Text('Error: ${e.toString()}'),
                                                              backgroundColor: AppTheme.errorColor,
                                                            ),
                                                          );
                                                        }
                                                      }
                                                    }
                                                  },
                                            style: ElevatedButton.styleFrom(
                                              padding: EdgeInsets.symmetric(vertical: isMobile ? 14 : 16),
                                              backgroundColor: AppTheme.warningColor,
                                              foregroundColor: Colors.white,
                                              disabledBackgroundColor: AppTheme.borderColor,
                                            ),
                                            child: Text(
                                              'Submit',
                                              style: TextStyle(
                                                fontSize: isMobile ? 14 : 16,
                                                fontWeight: FontWeight.w600,
                                              ),
                                            ),
                                          ),
                                        );
                                      },
                                    ),
                                    SizedBox(height: isMobile ? 8 : 0),
                                    SizedBox(
                                      width: double.infinity,
                                      child: TextButton(
                                        onPressed: dialogIsSubmitting
                                            ? null
                                            : () {
                                                setState(() {
                                                  _expenseDialogStep = 1;
                                                });
                                                setDialogState(() {});
                                              },
                                        child: Text(
                                          'Previous',
                                          style: TextStyle(
                                            color: AppTheme.primaryColor,
                                            fontSize: isMobile ? 14 : null,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ],
                                )
                              : Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Flexible(
                                child: TextButton(
                                  onPressed: dialogIsSubmitting
                                      ? null
                                      : () {
                      setState(() {
                                                  _expenseDialogStep = 1;
                                                });
                                                setDialogState(() {});
                    },
                                  child: Text(
                                    'Previous',
                                    style: TextStyle(
                                      color: AppTheme.primaryColor,
                                      fontSize: isMobile ? 14 : null,
                                    ),
                                  ),
                                ),
                              ),
                              SizedBox(width: isMobile ? 8 : 12),
                              Builder(
                                builder: (context) {
                                  // Check if button should be disabled
                                  final isProofRequired = _isProofRequiredForSelectedType();
                                  final hasNewProof = _selectedExpenseProofImage != null;
                                  final hasExistingProof = isEditMode && 
                                      existingExpenseData != null && 
                                      existingExpenseData!['proofUrl'] != null &&
                                      existingExpenseData!['proofUrl'].toString().isNotEmpty;
                                  final hasProof = hasNewProof || hasExistingProof;
                                  
                                  final shouldDisable = dialogIsSubmitting || 
                                      (isProofRequired && !hasProof);
                                  
                                  return Flexible(
                                    child: ElevatedButton(
                                    onPressed: shouldDisable
                                        ? null
                                        : () async {
                                    // Validate proof requirement FIRST (before form validation)
                                    final isProofRequired = _isProofRequiredForSelectedType();
                                    final hasProof = _selectedExpenseProofImage != null || 
                                        (isEditMode && existingExpenseData?['proofUrl'] != null &&
                                         existingExpenseData!['proofUrl'].toString().isNotEmpty);
                                    
                                    if (isProofRequired && !hasProof) {
                                      if (mounted) {
                                        ScaffoldMessenger.of(context).showSnackBar(
                                          const SnackBar(
                                            content: Text('Proof image is mandatory for this expense type. Please upload a proof image.'),
                                            backgroundColor: AppTheme.errorColor,
                                            duration: Duration(seconds: 3),
                                          ),
                                        );
                                      }
                                      return; // Stop here - don't proceed with form validation
                                    }
                                    
                                    // Only proceed with form validation if proof requirement is met
                                    if (_addExpenseFormKey.currentState!.validate()) {
                                      
                                      setDialogState(() {
                                        dialogIsSubmitting = true;
                                      });

                                      try {
                                            final amountText = _expenseAmountController.text.trim();
                                            if (amountText.isEmpty) {
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                              });
                                              if (mounted) {
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  const SnackBar(
                                                    content: Text('Please enter an amount'),
                                                    backgroundColor: AppTheme.errorColor,
                                                  ),
                                                );
                                              }
                                              return;
                                            }
                                            
                                            final amount = double.tryParse(amountText);
                                            if (amount == null || amount <= 0 || amount.isNaN || amount.isInfinite) {
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                              });
                                              if (mounted) {
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  const SnackBar(
                                                    content: Text('Please enter a valid amount'),
                                                    backgroundColor: AppTheme.errorColor,
                                                  ),
                                                );
                                              }
                                              return;
                                            }
                                            
                                            final description =
                                                _expenseDescriptionController.text.trim();
                                        
                                        // Upload image if selected and get URL
                                        String? proofUrl;
                                        if (_selectedExpenseProofImage != null) {
                                          // Upload the new image
                                          setDialogState(() {
                                            dialogIsSubmitting = true;
                                          });
                                          
                                          final uploadResult = await ExpenseService.uploadProofImage(_selectedExpenseProofImage!);
                                          
                                          if (!mounted) return;
                                          
                                          if (uploadResult['success'] == true) {
                                            proofUrl = uploadResult['imageUrl']?.toString();
                                            print('‚úÖ Image uploaded successfully: $proofUrl');
                                          } else {
                                            setDialogState(() {
                                              dialogIsSubmitting = false;
                                            });
                                            if (mounted) {
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text(uploadResult['message'] ?? 'Failed to upload image'),
                                                  backgroundColor: AppTheme.errorColor,
                                                ),
                                              );
                                            }
                                            return;
                                          }
                                          
                                        } else if (isEditMode && existingExpenseData != null) {
                                          // In edit mode and no new image selected - use existing proofUrl
                                          proofUrl = existingExpenseData['proofUrl']?.toString();
                                        }
                                        
                                        // Set submitting state again before creating expense
                                        setDialogState(() {
                                          dialogIsSubmitting = true;
                                        });

                                            // Use the selected category directly - backend will auto-create if needed
                                            // Don't map it to default categories, let user's choice be used
                                            final validCategory = _selectedExpenseCategory.trim();
                                            
                                            // Validate category is not empty
                                            if (validCategory.isEmpty) {
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                              });
                                              if (mounted) {
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  const SnackBar(
                                                    content: Text('Please select a valid expense category'),
                                                    backgroundColor: AppTheme.errorColor,
                                                  ),
                                                );
                                              }
                                              return;
                                            }

                                        // Get payment mode - use selected mode or default to Cash
                                        final paymentMode = _selectedExpenseMode.isNotEmpty 
                                            ? _selectedExpenseMode 
                                            : (existingExpenseData?['mode']?.toString() ?? 'Cash');
                                        
                                        // Validate payment mode is not empty
                                        if (paymentMode.trim().isEmpty) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });
                                          if (mounted) {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              const SnackBar(
                                                content: Text('Please select a payment mode'),
                                                backgroundColor: AppTheme.errorColor,
                                              ),
                                            );
                                          }
                                          return;
                                        }

                                        Map<String, dynamic> result;
                                        
                                        if (isEditMode && existingExpenseData != null) {
                                          // Update existing expense
                                          final expenseId = existingExpenseData['expenseId']?.toString() ?? '';
                                          result = await ExpenseService.updateExpense(
                                            expenseId,
                                            category: validCategory,
                                            amount: amount,
                                            mode: paymentMode,
                                            description: description.isEmpty ? null : description,
                                            proofUrl: proofUrl,
                                          );
                                        } else {
                                          // Create new expense
                                          result = await ExpenseService.createExpense(
                                              userId: null,
                                              category: validCategory,
                                          amount: amount,
                                              mode: paymentMode,
                                              description:
                                                  description.isEmpty ? null : description,
                                          proofUrl: proofUrl,
                                        );
                                        }

                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });

                                          if (result['success'] == true) {
                                            // If editing from flagged item, also resubmit to change status to Pending
                                            if (isEditMode && existingExpenseData != null && existingExpenseData['fromFlaggedItem'] == true) {
                                              final flaggedItemId = existingExpenseData['flaggedItemId']?.toString() ?? existingExpenseData['expenseId']?.toString() ?? '';
                                              final flaggedItemCategory = existingExpenseData['flaggedItemCategory']?.toString() ?? '';
                                              if (flaggedItemId.isNotEmpty) {
                                                // Wait a moment for update to complete, then resubmit to change status to Pending
                                                await Future.delayed(Duration(milliseconds: 200));
                                                
                                                // Resubmit to change status to Pending
                                                print('üö© [FLAGGED ITEMS] Resubmitting expense: $flaggedItemId');
                                                final resubmitResult = await ExpenseService.resubmitExpense(
                                                  flaggedItemId,
                                                  'Updated and resubmitted for approval',
                                                );
                                                
                                                print('üö© [FLAGGED ITEMS] Resubmit result: success=${resubmitResult['success']}, message=${resubmitResult['message']}');
                                                
                                                if (resubmitResult['success'] == true) {
                                                  // Track this item as resubmitted (safeguard)
                                                  _resubmittedItemIds.add(flaggedItemId);
                                                  print('üö© [FLAGGED ITEMS] Added $flaggedItemId to resubmitted tracking set');
                                                  
                                                  // Remove from local flagged items immediately (it's now Pending, not Flagged)
                                                  _removeFlaggedItem(flaggedItemId, category: flaggedItemCategory);
                                                  
                                                  // Clear timeline items completely to force fresh reload
                                                  if (mounted) {
                                                    setState(() {
                                                      _timelineItems = [];
                                                    });
                                                  }
                                                  
                                                  // Wait longer for backend to process and save the status change
                                                  await Future.delayed(Duration(milliseconds: 1500));
                                                  
                                                  // Reload flagged items to ensure sync
                                                  await _loadTimelineEntries();
                                                  
                                                  // Clear the resubmitted tracking after a delay (cleanup)
                                                  Future.delayed(Duration(seconds: 5), () {
                                                    _resubmittedItemIds.remove(flaggedItemId);
                                                    print('üö© [FLAGGED ITEMS] Removed $flaggedItemId from resubmitted tracking set');
                                                  });
                                                  
                                                  // Stay on the same page (don't navigate to Smart Approvals)
                                                  print('üö© [FLAGGED ITEMS] Staying on current page for expense (not navigating to Smart Approvals)');
                                                } else {
                                                  // If resubmit failed, show error
                                                  if (mounted) {
                                                    ScaffoldMessenger.of(context).showSnackBar(
                                                      SnackBar(
                                                        content: Text(resubmitResult['message']?.toString() ?? 'Failed to resubmit expense'),
                                                        backgroundColor: AppTheme.errorColor,
                                                      ),
                                                    );
                                                  }
                                                }
                                              }
                                            }
                                            
                                            Navigator.of(dialogContext).pop();

                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                    content: Text(result['message'] ??
                                                        (isEditMode ? 'Expense updated and resubmitted successfully.' : 'Expense created successfully')),
                                                backgroundColor: AppTheme.secondaryColor,
                                                duration: const Duration(seconds: 2),
                                              ),
                                            );

                                            // Refresh dashboard data to update approvals list
                                            _loadDashboardData();
                                            _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);

                                            // Clear form
                                            _expenseAmountController.clear();
                                            _expenseDescriptionController.clear();
                                            _expenseRemarkController.clear();
                  setState(() {
                                                  _expenseDialogStep = 1;
                                                  _selectedExpenseTypeForDialog = null;
                                              _selectedExpenseCategory = 'Office';
                                              _selectedExpenseMode = 'Cash';
                                              _selectedExpensePaymentAccountId = null;
                                              _selectedExpenseProofImage = null;
                                              if (preservedAccountId == null) {
                                                _selectedExpenseAccountId = null;
                                              }
                                            });

                                            // Refresh financial data immediately to show new expense
                                            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                            
                                            // Refresh Smart Approvals if it's currently visible
                                            if (_selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
                                              _pendingApprovalsRefreshKey.currentState!.refresh();
                                            }
                                            
                                            // Also trigger filter update to ensure expense appears
                                            Future.delayed(const Duration(milliseconds: 500), () {
                                              if (mounted) {
                                                _applyFilters();
                                              }
                                            });
                                          } else {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                    content: Text(result['message'] ??
                                                        'Operation failed'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      } catch (e) {
                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                                  content: Text(
                                                      'Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    }
                                  },
                                  style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.secondaryColor,
                                    foregroundColor: Colors.white,
                                  padding: EdgeInsets.symmetric(
                                    horizontal: isMobile ? 16 : 32,
                                    vertical: isMobile ? 12 : 14,
                                  ),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  ),
                                  child: dialogIsSubmitting
                                      ? SizedBox(
                                          width: isMobile ? 16 : 20,
                                        height: isMobile ? 16 : 20,
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          valueColor:
                                              AlwaysStoppedAnimation<Color>(Colors.white),
                                          ),
                                        )
                                      : Row(
                                          mainAxisSize: MainAxisSize.min,
                                          children: [
                                            Text(
                                              isEditMode ? 'Update & Resubmit' : 'Submit',
                                              style: TextStyle(
                                                fontSize: isMobile ? 14 : 16,
                                                fontWeight: FontWeight.w600,
                                              ),
                                            ),
                                            if (isProofRequired && !hasProof)
                                              const SizedBox(width: 8),
                                            if (isProofRequired && !hasProof)
                                              Icon(
                                                Icons.info_outline,
                                                size: 18,
                                                color: Colors.white.withOpacity(0.8),
                                              ),
                                          ],
                                        ),
                                  ),
                                    );
                                },
                              ),
                            ],
                          ),
                        ),
                        ],
    );
  }

  // New Add Collection Dialog - Using AddCollectionDialog widget
  Future<void> _showNewAddCollectionDialog() async {
    try {
      if (!mounted) return;
      
      await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return AddCollectionDialog(
            onSuccess: () {
              // Refresh data after successful collection creation
              _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
            },
          );
        },
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // New Add Transaction Dialog - Redesigned to match Transfer Amount form
  Future<void> _showNewAddTransactionDialog({Map<String, dynamic>? existingTransactionData, bool isEditMode = false}) async {
    // Safe debug logging (avoid Flutter web errors)
    try {
      debugPrint('\nüîÑ ===== OPENING TRANSACTION DIALOG =====');
      debugPrint('üîÑ [TRANSACTION DIALOG] Dialog opening');
      debugPrint('   isEditMode: $isEditMode');
      debugPrint('   existingTransactionData: ${existingTransactionData != null}');
      if (existingTransactionData != null) {
        try {
          final keysCount = existingTransactionData.keys.length;
          debugPrint('   existingTransactionData has $keysCount keys');
        } catch (e) {
          // Ignore key access errors
        }
        debugPrint('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
        debugPrint('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
        debugPrint('   transactionId: ${existingTransactionData['transactionId']}');
      } else {
        debugPrint('   ‚ö†Ô∏è existingTransactionData is NULL - this is normal for new transactions');
      }
      debugPrint('==========================================\n');
    } catch (e) {
      // Ignore debug print errors
    }
    
    // Declare controller and disposal flag outside try block for catch block access
    TextEditingController? receiverSearchController;
    bool controllerDisposed = false;
    
    try {
      // Load users in background if needed
      if (_userOptions.isEmpty && !_isLoadingUsers) {
        _loadAllUsers();
      }
      
      // Always reload payment modes when dialog opens to ensure we have the latest data
      // Filter by Transaction display type for transaction dialog
      print('üîç [Transaction Dialog] Loading payment modes with displayType: Transaction');
      if (!_isLoadingPaymentModes) {
        await _loadPaymentModes(displayType: 'Transaction');
        print('üîç [Transaction Dialog] Payment modes loaded. Count: ${_paymentModes.length}');
        // Force a rebuild of the dialog after payment modes are loaded
        // The ValueListenableBuilder should handle this, but we ensure it's triggered
      } else {
        print('üîç [Transaction Dialog] Payment modes already loading, waiting...');
        // Wait for current load to complete
        while (_isLoadingPaymentModes) {
          await Future.delayed(const Duration(milliseconds: 100));
        }
        print('üîç [Transaction Dialog] Payment modes load completed. Count: ${_paymentModes.length}');
      }
      
      // Get current user ID to use as sender
      String? currentUserId;
      try {
        currentUserId = await AuthService.getUserId();
      } catch (e) {
        debugPrint('Error getting current user ID: $e');
      }
      
      // Reset or pre-fill form state based on edit mode
      bool dialogIsSubmitting = false;
      receiverSearchController = TextEditingController();
      String receiverSearchQuery = '';
      bool showReceiverDropdown = false;
      
      // Ensure controller is initialized
      if (receiverSearchController == null) {
        receiverSearchController = TextEditingController();
      }
      
      // Set initial search text if receiver is already selected
      if (_selectedTransactionReceiverId != null) {
        final selectedUser = _userOptions.firstWhere(
          (user) => user['id']?.toString() == _selectedTransactionReceiverId,
          orElse: () => <String, String>{},
        );
        if (selectedUser.isNotEmpty && receiverSearchController != null && !controllerDisposed) {
          receiverSearchController.text = selectedUser['label'] ?? '';
        }
      }
      
      if (isEditMode && existingTransactionData != null) {
        // Pre-fill data for edit mode
        final amount = existingTransactionData['amount'] ?? 0.0;
        final mode = existingTransactionData['mode']?.toString() ?? 'Cash';
        final purpose = existingTransactionData['purpose']?.toString() ?? '';
        
        _transactionAmountController.text = amount.toString();
        _transactionPurposeController.text = purpose;
        
        setState(() {
          _selectedTransactionMode = mode;
          _selectedTransactionReceiverId = null; // Transactions don't have receiver in edit mode
        });
      } else {
        // Reset for add mode
        _transactionAmountController.clear();
        _transactionPurposeController.clear();
        
        // Set default payment mode to first available or 'Cash'
        String defaultMode = 'Cash';
        if (_paymentModes.isNotEmpty) {
          final firstMode = _paymentModes.first;
          defaultMode = firstMode['modeName']?.toString() ?? 'Cash';
        }
        
        // Validate that selected mode exists in payment modes list
        final modeNames = _paymentModes.map((m) => m['modeName']?.toString() ?? '').toList();
        if (!modeNames.contains(_selectedTransactionMode) && _paymentModes.isNotEmpty) {
          final firstMode = _paymentModes.first;
          defaultMode = firstMode['modeName']?.toString() ?? 'Cash';
        }
        
        setState(() {
          if (!modeNames.contains(_selectedTransactionMode) && _paymentModes.isNotEmpty) {
            _selectedTransactionMode = defaultMode;
          }
          _selectedTransactionReceiverId = null;
        });
      }
      _addTransactionFormKey.currentState?.reset();

      final isMobile = Responsive.isMobile(context);
      final isTablet = Responsive.isTablet(context);

      if (!mounted) return;
      
      final screenHeight = MediaQuery.of(context).size.height;
      final screenWidth = MediaQuery.of(context).size.width;
      
      await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return StatefulBuilder(
            builder: (context, setDialogState) {
              return Dialog(
                backgroundColor: Colors.transparent,
                insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Container(
                  width: isMobile ? double.infinity : 500,
                  constraints: BoxConstraints(
                    maxHeight: screenHeight * 0.85,
                    minHeight: 400,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Form(
                    key: _addTransactionFormKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Header with User Name
                              Container(
                          padding: EdgeInsets.all(isMobile ? 16 : 20),
                                decoration: BoxDecoration(
                            color: AppTheme.accentBlue,
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(16),
                              topRight: Radius.circular(16),
                            ),
                                    ),
                          child: isMobile
                              ? Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Row(
                                      children: [
                                        const Icon(
                                          Icons.swap_horizontal_circle,
                                          color: Colors.white,
                                          size: 28,
                                        ),
                                        const SizedBox(width: 12),
                                        Expanded(
                                          child: Text(
                                            isEditMode ? 'Edit Transaction' : 'Add Transaction',
                                            style: AppTheme.headingMedium.copyWith(
                                              color: Colors.white,
                                              fontWeight: FontWeight.bold,
                                              fontSize: 18,
                                            ),
                                          ),
                                        ),
                                        // Close button - always visible
                                        IconButton(
                                          onPressed: () {
                                            Navigator.pop(dialogContext);
                                          },
                                          icon: const Icon(
                                            Icons.close_rounded,
                                            color: Colors.white,
                                            size: 24,
                                          ),
                                          tooltip: 'Close',
                                          padding: EdgeInsets.zero,
                                          constraints: const BoxConstraints(),
                                        ),
                                      ],
                                    ),
                                    // User name below on mobile
                                    if (_userName != null) ...[
                                      const SizedBox(height: 8),
                                      Row(
                                        children: [
                                          const Icon(
                                            Icons.person,
                                            color: Colors.white,
                                            size: 18,
                                          ),
                                          const SizedBox(width: 6),
                                          Container(
                                            padding: const EdgeInsets.symmetric(
                                              horizontal: 12,
                                              vertical: 6,
                                            ),
                                            decoration: BoxDecoration(
                                              color: Colors.white.withOpacity(0.2),
                                              borderRadius: BorderRadius.circular(8),
                                            ),
                                            child: Text(
                                              _userName!,
                                              style: const TextStyle(
                                                color: Colors.white,
                                                fontWeight: FontWeight.w600,
                                                fontSize: 14,
                                              ),
                                            ),
                                          ),
                                        ],
                                      ),
                                    ],
                                  ],
                                )
                              : Row(
                                  children: [
                                    const Icon(
                                      Icons.swap_horizontal_circle,
                                      color: Colors.white,
                                      size: 28,
                                    ),
                                    const SizedBox(width: 12),
                                    Expanded(
                                      child: Text(
                                        isEditMode ? 'Edit Transaction' : 'Add Transaction',
                                        style: AppTheme.headingMedium.copyWith(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ),
                                    // User name on the right (non-editable)
                                    if (_userName != null)
                                      Row(
                                        children: [
                                          const Icon(
                                            Icons.person,
                                            color: Colors.white,
                                            size: 18,
                                          ),
                                          const SizedBox(width: 6),
                                          Container(
                                            padding: const EdgeInsets.symmetric(
                                              horizontal: 12,
                                              vertical: 6,
                                            ),
                                            decoration: BoxDecoration(
                                              color: Colors.white.withOpacity(0.2),
                                              borderRadius: BorderRadius.circular(8),
                                            ),
                                            child: Text(
                                              _userName!,
                                              style: const TextStyle(
                                                color: Colors.white,
                                                fontWeight: FontWeight.w600,
                                                fontSize: 14,
                                              ),
                                            ),
                                          ),
                                          const SizedBox(width: 12),
                                        ],
                                      ),
                                    // Close button - always visible
                                    IconButton(
                                      onPressed: () {
                                        Navigator.pop(dialogContext);
                                      },
                                      icon: const Icon(
                                        Icons.close_rounded,
                                        color: Colors.white,
                                        size: 24,
                                      ),
                                      tooltip: 'Close',
                                      padding: EdgeInsets.zero,
                                      constraints: const BoxConstraints(),
                                    ),
                                  ],
                                ),
                        ),

                        // Form Content
                        ConstrainedBox(
                          constraints: BoxConstraints(
                            maxHeight: screenHeight * 0.5,
                          ),
                          child: GestureDetector(
                            onTap: () {
                              // Close dropdown when tapping outside
                              setDialogState(() {
                                showReceiverDropdown = false;
                              });
                            },
                            child: SingleChildScrollView(
                              child: Padding(
                                padding: EdgeInsets.all(isMobile ? 16 : 24),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.stretch,
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                  // Receiver Selection - Searchable Dropdown
                          _userOptions.isEmpty
                              ? Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: AppTheme.surfaceColor,
                                    borderRadius: BorderRadius.circular(12),
                                    border: Border.all(color: AppTheme.borderColor),
                                  ),
                                  child: const Text(
                                    'No users available',
                                    style: TextStyle(color: AppTheme.textSecondary),
                                  ),
                                )
                              : Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    TextFormField(
                                      controller: receiverSearchController,
                                            decoration: InputDecoration(
                                              labelText: 'Transfer To',
                                        hintText: 'Search and select a user...',
                                              prefixIcon: const Icon(Icons.person_outline),
                                        suffixIcon: (receiverSearchController != null && !controllerDisposed && receiverSearchController.text.isNotEmpty)
                                            ? IconButton(
                                                icon: const Icon(Icons.clear, size: 20),
                                                onPressed: () {
                                                  if (receiverSearchController != null && !controllerDisposed) {
                                                    receiverSearchController.clear();
                                                    setDialogState(() {
                                                      receiverSearchQuery = '';
                                                      _selectedTransactionReceiverId = null;
                                                      showReceiverDropdown = false;
                                                    });
                                                  }
                                                },
                                              )
                                            : const Icon(Icons.search, size: 20),
                                              border: OutlineInputBorder(
                                                borderRadius: BorderRadius.circular(12),
                                              ),
                                              contentPadding: EdgeInsets.symmetric(
                                                horizontal: 16,
                                                vertical: isMobile ? 16 : 14,
                                              ),
                                  ),
                                      onTap: () {
                                        setDialogState(() {
                                          showReceiverDropdown = true;
                                        });
                                      },
                                  onChanged: (value) {
                                    setDialogState(() {
                                          receiverSearchQuery = value.toLowerCase();
                                          showReceiverDropdown = true;
                                          // Clear selection if search doesn't match selected user
                                          if (_selectedTransactionReceiverId != null) {
                                            final selectedUser = _userOptions.firstWhere(
                                              (user) => user['id']?.toString() == _selectedTransactionReceiverId,
                                              orElse: () => <String, String>{},
                                            );
                                            if (selectedUser.isNotEmpty) {
                                              final selectedLabel = (selectedUser['label'] ?? '').toLowerCase();
                                              if (!selectedLabel.contains(receiverSearchQuery)) {
                                                _selectedTransactionReceiverId = null;
                                              }
                                            }
                                          }
                                    });
                                  },
                                  validator: (value) {
                                        if (_selectedTransactionReceiverId == null || _selectedTransactionReceiverId!.isEmpty) {
                                                return 'Please select a receiver';
                                              }
                                        if (currentUserId != null && _selectedTransactionReceiverId == currentUserId) {
                                                return 'Cannot transfer to yourself';
                              }
                              return null;
                            },
                                      style: TextStyle(
                                        fontSize: isMobile ? 16 : 15,
                                      ),
                                    ),
                                    // Dropdown list
                                    if (showReceiverDropdown && _userOptions.isNotEmpty)
                                      Container(
                                        margin: const EdgeInsets.only(top: 4),
                                        constraints: const BoxConstraints(maxHeight: 200),
                                        decoration: BoxDecoration(
                                          color: Colors.white,
                                          borderRadius: BorderRadius.circular(12),
                                          border: Border.all(color: AppTheme.borderColor),
                                          boxShadow: [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.1),
                                              blurRadius: 8,
                                              offset: const Offset(0, 4),
                                            ),
                                          ],
                                        ),
                                        child: Builder(
                                          builder: (context) {
                                            // Filter users based on search query and exclude current user
                                            final filteredUsers = _userOptions.where((user) {
                                              final userId = user['id']?.toString() ?? '';
                                              final userName = (user['label'] ?? '').toLowerCase();
                                              final matchesSearch = receiverSearchQuery.isEmpty ||
                                                  userName.contains(receiverSearchQuery);
                                              final isNotCurrentUser = currentUserId == null || userId != currentUserId;
                                              return matchesSearch && isNotCurrentUser;
                                            }).toList();

                                            if (filteredUsers.isEmpty) {
                                              return Padding(
                                                padding: const EdgeInsets.all(16),
                                                child: Text(
                                                  'No users found',
                                                  style: TextStyle(
                                                    color: AppTheme.textSecondary,
                                                    fontSize: 14,
                                                  ),
                                                ),
                                              );
                                            }

                                            return ListView.builder(
                                              key: const PageStorageKey('user_selection_list'),
                                              shrinkWrap: true,
                                              itemCount: filteredUsers.length,
                                              itemBuilder: (context, index) {
                                                final user = filteredUsers[index];
                                                final userId = user['id']?.toString() ?? '';
                                                final userName = user['label']?.toString() ?? 'Unknown User';
                                                final isSelected = _selectedTransactionReceiverId == userId;

                                                return InkWell(
                                                  key: ValueKey('user_$userId'),
                                                  onTap: () {
                                                    if (receiverSearchController != null && !controllerDisposed) {
                                                      receiverSearchController.text = userName;
                                                    }
                                                    setDialogState(() {
                                                      _selectedTransactionReceiverId = userId;
                                                      showReceiverDropdown = false;
                                                      receiverSearchQuery = '';
                                                    });
                                                  },
                                                  child: Container(
                                                    padding: const EdgeInsets.symmetric(
                                                      horizontal: 16,
                                                      vertical: 12,
                                                    ),
                                                    decoration: BoxDecoration(
                                                      color: isSelected
                                                          ? AppTheme.primaryColor.withOpacity(0.1)
                                                          : Colors.transparent,
                                                      border: Border(
                                                        bottom: BorderSide(
                                                          color: AppTheme.borderColor.withOpacity(0.5),
                                                          width: index < filteredUsers.length - 1 ? 1 : 0,
                                                        ),
                                                      ),
                                                    ),
                                                    child: Row(
                                                      children: [
                                                        Icon(
                                                          Icons.person_outline,
                                                          size: 20,
                                                          color: isSelected
                                                              ? AppTheme.primaryColor
                                                              : AppTheme.textSecondary,
                                                        ),
                                                        const SizedBox(width: 12),
                                                        Expanded(
                                                          child: Text(
                                                            userName,
                                                            style: TextStyle(
                                                              fontSize: 14,
                                                              fontWeight: isSelected
                                                                  ? FontWeight.w600
                                                                  : FontWeight.normal,
                                                              color: isSelected
                                                                  ? AppTheme.primaryColor
                                                                  : AppTheme.textPrimary,
                                                            ),
                                                          ),
                                                        ),
                                                        if (isSelected)
                                                          Icon(
                                                            Icons.check_circle,
                                                            size: 20,
                                                            color: AppTheme.primaryColor,
                                                          ),
                                                      ],
                                                    ),
                                                  ),
                                                );
                                              },
                                            );
                                          },
                                        ),
                                      ),
                                    ],
                          ),
                          SizedBox(height: isMobile ? 16 : 20),
                          
                          // Amount Input
                          TextFormField(
                                  controller: _transactionAmountController,
                                  keyboardType: TextInputType.number,
                            inputFormatters: [
                                    FilteringTextInputFormatter.allow(
                                      RegExp(r'^\d+\.?\d{0,2}'),
                                    ),
                            ],
                                  decoration: InputDecoration(
                                    labelText: 'Amount',
                                    prefixIcon: const Icon(Icons.currency_rupee),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                            ),
                            validator: (value) {
                                    if (value == null || value.trim().isEmpty) {
                                      return 'Please enter amount';
                              }
                              final amount = double.tryParse(value);
                              if (amount == null || amount <= 0) {
                                return 'Please enter a valid amount';
                              }
                              return null;
                            },
                            style: TextStyle(
                              fontSize: isMobile ? 16 : 15,
                            ),
                          ),
                          SizedBox(height: isMobile ? 16 : 20),
                          
                          // Payment Mode
                          ValueListenableBuilder<bool>(
                            valueListenable: _paymentModesLoadedNotifier,
                            builder: (context, _, __) {
                              // Use payment modes from database - these contain modeName like "Sales UPI", "Purchase UPI", etc.
                              debugPrint('üîç [Transaction Dialog] Building payment mode dropdown. Payment modes count: ${_paymentModes.length}');
                              debugPrint('üîç [Transaction Dialog] Is loading: $_isLoadingPaymentModes');
                              
                              final List<Map<String, dynamic>> availableModes = _paymentModes.isNotEmpty
                                  ? List<Map<String, dynamic>>.from(_paymentModes)
                                  : [];
                              
                              // Filter out any modes with empty modeName
                              final validModes = availableModes.where((m) {
                                final modeName = m['modeName']?.toString() ?? '';
                                final isValid = modeName.trim().isNotEmpty;
                                if (!isValid) {
                                  debugPrint('Skipping payment mode with empty modeName: $m');
                                }
                                return isValid;
                              }).toList();
                              
                              debugPrint('Valid payment modes count: ${validModes.length}');
                              
                              // If no valid modes, add a default Cash option
                              final List<Map<String, dynamic>> finalModes = validModes.isNotEmpty
                                  ? validModes
                                  : [
                                      {'modeName': 'Cash', 'isDefault': true}
                                    ];
                              
                              // Get mode names for validation
                              final modeNames = finalModes.map((m) => m['modeName']?.toString() ?? '').where((name) => name.isNotEmpty).toList();
                              
                              debugPrint('Final mode names: $modeNames');
                              
                              // Set current mode - use selected if valid, otherwise use first available
                              // Don't update state during build - just compute the value to display
                              String? currentMode = _selectedTransactionMode;
                              if (currentMode == null || currentMode.isEmpty || !modeNames.contains(currentMode)) {
                                currentMode = modeNames.isNotEmpty ? modeNames.first : 'Cash';
                              }
                              
                              // Get display icon for current mode
                              final currentModeIcon = _getPaymentModeIcon(currentMode);
                              
                              // Calculate button height for proper menu offset
                              final double buttonHeight = isMobile ? 56.0 : 56.0;
                              final Offset menuOffset = Offset(0, buttonHeight + 4);
                              
                              return Material(
                                elevation: 8,
                                color: Colors.transparent,
                                shadowColor: Colors.transparent,
                                child: PopupMenuButton<String>(
                                  offset: menuOffset, // Position menu at bottom of button
                                  elevation: 8,
                                  shadowColor: Colors.black.withOpacity(0.08),
                                  surfaceTintColor: Colors.transparent,
                                  color: Colors.white,
                                  constraints: BoxConstraints(
                                    minWidth: isMobile ? double.infinity : 300,
                                    maxWidth: isMobile ? double.infinity : 400,
                                    maxHeight: 300,
                                  ),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  enabled: !_isLoadingPaymentModes,
                                  onSelected: (String? value) {
                                    if (value != null && value.isNotEmpty) {
                                      setDialogState(() {
                                        _selectedTransactionMode = value;
                                      });
                                    }
                                  },
                                  itemBuilder: (context) {
                                    return finalModes.map<PopupMenuEntry<String>>((mode) {
                                      final modeName = mode['modeName']?.toString() ?? '';
                                      if (modeName.isEmpty) return const PopupMenuDivider();
                                      final modeIcon = _getPaymentModeIcon(modeName);
                                      final isSelected = modeName == currentMode;
                                      
                                      return PopupMenuItem<String>(
                                        value: modeName,
                                        padding: const EdgeInsets.symmetric(
                                          horizontal: 12,
                                          vertical: 8,
                                        ),
                                        child: Row(
                                          children: [
                                            if (isSelected)
                                              Icon(
                                                Icons.check,
                                                size: 18,
                                                color: AppTheme.primaryColor,
                                              )
                                            else
                                              const SizedBox(width: 18),
                                            if (isSelected) const SizedBox(width: 8),
                                            Icon(
                                              modeIcon,
                                              size: 20,
                                              color: AppTheme.primaryColor,
                                            ),
                                            const SizedBox(width: 12),
                                            Expanded(
                                              child: Text(
                                                modeName,
                                                overflow: TextOverflow.ellipsis,
                                                maxLines: 1,
                                                style: TextStyle(
                                                  color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                                                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                                                ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      );
                                    }).whereType<PopupMenuEntry<String>>().toList();
                                  },
                                  // Child: Button that looks exactly like DropdownButtonFormField
                                  child: InputDecorator(
                                    decoration: InputDecoration(
                                      labelText: 'Payment Mode',
                                      prefixIcon: Icon(currentModeIcon),
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      contentPadding: EdgeInsets.symmetric(
                                        horizontal: 16,
                                        vertical: isMobile ? 16 : 14,
                                      ),
                                  suffixIcon: _isLoadingPaymentModes
                                      ? const Padding(
                                          padding: EdgeInsets.all(12.0),
                                          child: SizedBox(
                                            width: 16,
                                            height: 16,
                                            child: CircularProgressIndicator(strokeWidth: 2),
                                          ),
                                        )
                                          : const Icon(Icons.arrow_drop_down),
                                ),
                                    isFocused: false,
                                    isEmpty: false,
                                    child: Text(
                                      currentMode,
                                style: TextStyle(
                                  fontSize: isMobile ? 16 : 15,
                                ),
                                    ),
                                  ),
                                ),
                              );
                                    },
                                  ),
                                SizedBox(height: isMobile ? 16 : 20),
                          
                                // Purpose / Notes (Optional)
                          TextFormField(
                                  controller: _transactionPurposeController,
                            maxLines: 3,
                                  decoration: InputDecoration(
                                    labelText: 'Purpose / Notes (Optional)',
                                    prefixIcon: const Icon(Icons.note_outlined),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                  style: TextStyle(
                                    fontSize: isMobile ? 16 : 15,
                                  ),
                                ),
                              ],
                            ),
                          ),
                            ),
                          ),
                        ),

                        // Action Buttons
                        Container(
                          padding: EdgeInsets.all(isMobile ? 16 : 20),
                          decoration: BoxDecoration(
                            border: Border(
                              top: BorderSide(color: AppTheme.borderColor),
                            ),
                          ),
                          child: isMobile
                              ? Column(
                                  children: [
                                    SizedBox(
                                      width: double.infinity,
                                      child: ElevatedButton(
                                        onPressed: dialogIsSubmitting ? null : () async {
                                print('\nüîÑ ===== SUBMIT BUTTON PRESSED (TRANSACTION DIALOG) =====');
                                print('üîÑ [SUBMIT BUTTON] Button clicked in transaction dialog');
                                print('   isEditMode: $isEditMode');
                                print('   existingTransactionData available: ${existingTransactionData != null}');
                                if (existingTransactionData != null) {
                                  print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
                                  print('   transactionId: ${existingTransactionData['transactionId']}');
                                  print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
                                } else {
                                  print('   ‚ö†Ô∏è existingTransactionData is NULL in submit handler!');
                                }
                                print('==========================================\n');
                                
                                if (_addTransactionFormKey.currentState!.validate()) {
                                  if (currentUserId == null) {
        ScaffoldMessenger.of(context).showSnackBar(
                                      const SnackBar(
                                        content: Text('Unable to get current user. Please login again.'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }

                                  // Skip receiver validation in edit mode
                                  if (!isEditMode) {
                                    if (_selectedTransactionReceiverId == null) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        const SnackBar(
                                          content: Text('Please select a receiver'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    if (currentUserId == _selectedTransactionReceiverId) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        const SnackBar(
                                          content: Text('Cannot transfer to yourself'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }
                                  }

                                      setDialogState(() {
                                        dialogIsSubmitting = true;
      });

      try {
                                    final amount = double.parse(_transactionAmountController.text);
                                    final purpose = _transactionPurposeController.text.trim();

                                    // Get the actual mode (Cash/UPI/Bank) from the selected payment mode
                                    String transactionMode = 'Cash'; // Default fallback
                                    if (_selectedTransactionMode.isNotEmpty) {
                                      try {
                                        // Find the selected payment mode
                                        final selectedPaymentMode = _paymentModes.firstWhere(
                                          (mode) => mode['modeName']?.toString() == _selectedTransactionMode,
                                          orElse: () => <String, dynamic>{},
                                        );
                                        
                                        if (selectedPaymentMode.isNotEmpty) {
                                          // Parse description to get the mode (Cash/UPI/Bank)
                                          final description = selectedPaymentMode['description']?.toString() ?? '';
                                          if (description.isNotEmpty) {
                                            final parsed = PaymentModeService.parseDescription(description);
                                            final modeFromPaymentMode = parsed['mode']?.toString();
                                            
                                            if (modeFromPaymentMode != null && 
                                                ['Cash', 'UPI', 'Bank'].contains(modeFromPaymentMode)) {
                                              transactionMode = modeFromPaymentMode;
                                            }
                                          }
                                        }
                                        
                                        // Fallback: try to infer from modeName if mode not found in description
                                        if (transactionMode == 'Cash' && _selectedTransactionMode != 'Cash') {
                                          final modeNameUpper = _selectedTransactionMode.toUpperCase();
                                          if (modeNameUpper.contains('CASH')) {
                                            transactionMode = 'Cash';
                                          } else if (modeNameUpper.contains('UPI')) {
                                            transactionMode = 'UPI';
                                          } else if (modeNameUpper.contains('BANK')) {
                                            transactionMode = 'Bank';
                                          }
                                        }
                                      } catch (e) {
                                        debugPrint('Error parsing payment mode: $e');
                                        // Use default Cash if parsing fails
                                      }
                                    }

                                    Map<String, dynamic> result;
                                    
                                    print('\nüîÑ ===== TRANSACTION DIALOG - SUBMIT BUTTON CLICKED =====');
                                    print('üîÑ [TRANSACTION DIALOG] Submit button clicked');
                                    print('üîÑ [TRANSACTION EDIT] Starting transaction update/create:');
                                    print('   isEditMode: $isEditMode');
                                    print('   existingTransactionData: ${existingTransactionData != null}');
                                    if (existingTransactionData != null) {
                                      print('   existingTransactionData keys: ${existingTransactionData.keys.toList()}');
                                      print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
                                      print('   fromFlaggedItem type: ${existingTransactionData['fromFlaggedItem']?.runtimeType}');
                                      print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
                                      print('   transactionId: ${existingTransactionData['transactionId']}');
                                    } else {
                                      print('   ‚ö†Ô∏è existingTransactionData is NULL!');
                                    }
                                    print('==========================================\n');
                                    
                                    if (isEditMode && existingTransactionData != null) {
                                      // Update existing transaction
                                      final transactionId = existingTransactionData['transactionId']?.toString() ?? '';
                                      print('üîÑ [TRANSACTION EDIT] Updating transaction: $transactionId');
                                      // Check if from All Wallet Report
                                      final bool fromAllWalletReport = _selectedItem == NavItem.accountReports;
                                      
                                      result = await TransactionService.editTransaction(
                                        transactionId,
                                        amount: amount,
                                        mode: transactionMode,
                                        purpose: purpose.isEmpty ? null : purpose,
                                        proofUrl: existingTransactionData['proofUrl']?.toString(),
                                        fromAllWalletReport: fromAllWalletReport,
                                      );
                                      print('üîÑ [TRANSACTION EDIT] Edit API response received');
                                    } else {
                                      // Create new transaction
                                      print('üîÑ [TRANSACTION EDIT] Creating new transaction');
                                      result = await TransactionService.createTransaction(
                                        sender: currentUserId!,
                                        receiver: _selectedTransactionReceiverId!,
                                        amount: amount,
                                        mode: transactionMode,
                                        purpose: purpose.isEmpty ? null : purpose,
                                      );
                                      print('üîÑ [TRANSACTION EDIT] Create API response received');
                                    }

                                    print('üîÑ [TRANSACTION EDIT] Result received:');
                                    print('   result: $result');
                                    print('   result[success]: ${result['success']}');
                                    print('   result type: ${result.runtimeType}');
                                    print('   mounted: $mounted');

                                    if (mounted) {
                                      setDialogState(() {
                                        dialogIsSubmitting = false;
                                      });

                                      print('üîÑ [TRANSACTION EDIT] Dialog state updated, checking result:');
                                      print('   result[success]: ${result['success']}');
                                      print('   result[success] == true: ${result['success'] == true}');
                                      print('   result[success] == "true": ${result['success'] == "true"}');
                                      
                                      if (result['success'] == true || result['success'] == 'true') {
                                            // If editing from flagged item, also resubmit to change status to Pending
                                            print('üîÑ [TRANSACTION EDIT] ‚úÖ Update successful, checking resubmit conditions:');
                                            print('   isEditMode: $isEditMode');
                                            print('   existingTransactionData: ${existingTransactionData != null}');
                                            if (existingTransactionData != null) {
                                              print('   existingTransactionData keys: ${existingTransactionData.keys.toList()}');
                                              print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
                                              print('   fromFlaggedItem type: ${existingTransactionData['fromFlaggedItem']?.runtimeType}');
                                              print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
                                              print('   flaggedItemCategory: ${existingTransactionData['flaggedItemCategory']}');
                                              print('   transactionId: ${existingTransactionData['transactionId']}');
                                            }
                                            
                                            // Check if this is from a flagged item - use multiple checks to be safe
                                            final isFromFlaggedItem = existingTransactionData != null && (
                                              existingTransactionData['fromFlaggedItem'] == true ||
                                              existingTransactionData['fromFlaggedItem'] == 'true' ||
                                              existingTransactionData['fromFlaggedItem'] == 1 ||
                                              (existingTransactionData['flaggedItemId'] != null && existingTransactionData['flaggedItemId'].toString().isNotEmpty)
                                            );
                                            
                                            print('üîÑ [TRANSACTION EDIT] isFromFlaggedItem check result: $isFromFlaggedItem');
                                            print('üîÑ [TRANSACTION EDIT] Will resubmit if: isEditMode=$isEditMode AND isFromFlaggedItem=$isFromFlaggedItem');
                                            
                                            if (isEditMode && isFromFlaggedItem) {
                                              // Get transaction ID from multiple sources as fallback
                                              final transactionId = existingTransactionData?['transactionId']?.toString() ?? '';
                                              final flaggedItemId = existingTransactionData?['flaggedItemId']?.toString() ?? transactionId;
                                              final flaggedItemCategory = existingTransactionData?['flaggedItemCategory']?.toString() ?? 'transactions';
                                              
                                              // Use transactionId if flaggedItemId is empty
                                              final finalTransactionId = flaggedItemId.isNotEmpty ? flaggedItemId : transactionId;
                                              
                                              print('üîÑ [TRANSACTION EDIT] ‚úÖ Resubmit conditions met!');
                                              print('   transactionId: $transactionId');
                                              print('   flaggedItemId: $flaggedItemId');
                                              print('   finalTransactionId: $finalTransactionId');
                                              print('   flaggedItemCategory: $flaggedItemCategory');
                                              
                                              if (finalTransactionId.isNotEmpty) {
                                                print('\nüö© ===== FLAGGED ITEM RESUBMIT FLOW START =====');
                                                print('üö© [FLAGGED ITEMS] ‚úÖ Will resubmit transaction: $finalTransactionId');
                                                print('üö© [FLAGGED ITEMS] Category: $flaggedItemCategory');
                                                print('üö© [FLAGGED ITEMS] Current step: Waiting for update to complete...');
                                                
                                                // Wait a moment for update to complete, then resubmit to change status to Pending
                                                // Increased delay to ensure backend has saved the transaction with Flagged status preserved
                                                await Future.delayed(Duration(milliseconds: 500));
                                                
                                                // Resubmit to change status to Pending
                                                print('üö© [FLAGGED ITEMS] Step 2: Calling resubmit API...');
                                                print('üö© [FLAGGED ITEMS] Transaction ID: $finalTransactionId');
                                                print('üö© [FLAGGED ITEMS] Response text: "Updated and resubmitted for approval"');
                                                print('üö© [FLAGGED ITEMS] Expected: Transaction status should change from Flagged to Pending');
                                                
                                                final resubmitResult = await TransactionService.resubmitTransaction(
                                                  finalTransactionId,
                                                  'Updated and resubmitted for approval',
                                                );
                                                
                                                print('\nüö© [FLAGGED ITEMS] Step 3: Resubmit API response received');
                                                print('üö© [FLAGGED ITEMS] Resubmit result:');
                                                print('   success: ${resubmitResult['success']}');
                                                print('   message: ${resubmitResult['message']}');
                                                print('   transaction data: ${resubmitResult['transaction'] != null ? 'Present' : 'Missing'}');
                                                
                                                if (resubmitResult['transaction'] != null) {
                                                  final transaction = resubmitResult['transaction'];
                                                  print('   transaction._id: ${transaction['_id']}');
                                                  print('   transaction.status: ${transaction['status']}');
                                                  print('   transaction.response: ${transaction['response']}');
                                                  
                                                  // Check if status is actually Pending
                                                  final status = transaction['status']?.toString() ?? '';
                                                  if (status.toLowerCase() == 'pending') {
                                                    print('   ‚úÖ Status is Pending - RESUBMIT SUCCESS!');
                                                  } else {
                                                    print('   ‚ö†Ô∏è Status is $status (expected: Pending) - RESUBMIT MAY HAVE FAILED!');
                                                  }
                                                } else {
                                                  print('   ‚ö†Ô∏è Transaction data missing in response!');
                                                }
                                                
                                                if (resubmitResult['success'] == true) {
                                                  print('\nüö© [FLAGGED ITEMS] Step 4: Resubmit successful, updating UI...');
                                                  // Track this item as resubmitted (safeguard)
                                                  _resubmittedItemIds.add(finalTransactionId);
                                                  print('üö© [FLAGGED ITEMS] Step 4a: Added $finalTransactionId to resubmitted tracking set');
                                                  
                                                  // Remove from local flagged items immediately (it's now Pending, not Flagged)
                                                  print('üö© [FLAGGED ITEMS] Step 4b: Removing from flagged items list...');
                                                  _removeFlaggedItem(finalTransactionId, category: flaggedItemCategory);
                                                  
                                                  // Clear timeline items completely to force fresh reload
                                                  if (mounted) {
                                                    print('üö© [FLAGGED ITEMS] Step 4c: Clearing timeline items...');
                                                    setState(() {
                                                      _timelineItems = [];
                                                    });
                                                  }
                                                  
                                                  // Wait longer for backend to process and save the status change
                                                  print('üö© [FLAGGED ITEMS] Step 4d: Waiting for backend to process (1500ms)...');
                                                  await Future.delayed(Duration(milliseconds: 1500));
                                                  
                                                  // Reload flagged items to ensure sync
                                                  print('üö© [FLAGGED ITEMS] Step 4e: Reloading flagged items...');
                                                  await _loadTimelineEntries();
                                                  
                                                  // Clear the resubmitted tracking after a delay (cleanup)
                                                  Future.delayed(Duration(seconds: 5), () {
                                                    _resubmittedItemIds.remove(finalTransactionId);
                                                    print('üö© [FLAGGED ITEMS] Removed $finalTransactionId from resubmitted tracking set');
                                                  });
                                                  
                                                  // Show success message
                                                  if (mounted) {
                                                    ScaffoldMessenger.of(context).showSnackBar(
                                                      SnackBar(
                                                        content: Text('Transaction updated and resubmitted successfully.'),
                                                        backgroundColor: AppTheme.secondaryColor,
                                                        duration: const Duration(seconds: 2),
                                                      ),
                                                    );
                                                  }
                                                  
                                                  // Close the edit dialog first
                                                  Navigator.of(dialogContext).pop();
                                                  
                                                  // Stay on the same page (don't navigate to Smart Approvals)
                                                  print('üö© [FLAGGED ITEMS] Step 5: Staying on current page (not navigating to Smart Approvals)');
                                                  
                                                  // Refresh dashboard data to update approvals list (same as expense)
                                                  print('üö© [FLAGGED ITEMS] Step 6: Refreshing dashboard data...');
                                                  _loadDashboardData();
                                                  _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                                  print('üö© [FLAGGED ITEMS] ‚úÖ Dashboard data refresh initiated');

                                                  // Wait longer for backend to fully update before refreshing Smart Approvals
                                                  print('üö© [FLAGGED ITEMS] Step 7: Waiting for backend to fully update (1000ms)...');
                                                  await Future.delayed(Duration(milliseconds: 1000));
                                                  print('üö© [FLAGGED ITEMS] ‚úÖ Waiting complete, refreshing Smart Approvals...');

                                                  // Refresh Smart Approvals if it's currently visible (same as expense)
                                                  print('üö© [FLAGGED ITEMS] Step 8: Checking Smart Approvals refresh conditions...');
                                                  print('   mounted: $mounted');
                                                  print('   selectedItem: ${_selectedItem}');
                                                  print('   isSmartApprovals: ${_selectedItem == NavItem.smartApprovals}');
                                                  print('   refreshKey available: ${_pendingApprovalsRefreshKey.currentState != null}');
                                                  
                                                  if (mounted && _selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
                                                    print('üö© [FLAGGED ITEMS] ‚úÖ All conditions met - Refreshing Smart Approvals...');
                                                    _pendingApprovalsRefreshKey.currentState!.refresh();
                                                    print('üö© [FLAGGED ITEMS] ‚úÖ Smart Approvals refresh called');
                                                  } else {
                                                    print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Cannot refresh Smart Approvals:');
                                                    print('   mounted: $mounted');
                                                    print('   selectedItem: ${_selectedItem}');
                                                    print('   refreshKey: ${_pendingApprovalsRefreshKey.currentState != null}');
                                                  }
                                                  
                                                  print('\nüö© ===== FLAGGED ITEM RESUBMIT FLOW COMPLETE =====\n');
                                                  
                                                  // Also trigger filter update to ensure transaction appears (same as expense)
                                                  Future.delayed(const Duration(milliseconds: 1000), () {
                                                    if (mounted) {
                                                      print('üîÑ [TRANSACTION EDIT] Applying filters...');
                                                      _applyFilters();
                                                    }
                                                  });
                                                } else {
                                                  // If resubmit failed, show error
                                                  print('\nüö© [FLAGGED ITEMS] ‚ùå RESUBMIT FAILED!');
                                                  print('   Error message: ${resubmitResult['message']}');
                                                  print('   Full result: $resubmitResult');
                                                  print('   Transaction ID: $finalTransactionId');
                                                  print('==========================================\n');
                                                  
                                                  if (mounted) {
                                                    Navigator.of(dialogContext).pop();
                                                    ScaffoldMessenger.of(context).showSnackBar(
                                                      SnackBar(
                                                        content: Text(resubmitResult['message']?.toString() ?? 'Failed to resubmit transaction'),
                                                        backgroundColor: AppTheme.errorColor,
                                                      ),
                                                    );
                                                  }
                                                }
                                              }
                                            } else {
                                              // Not from flagged item, just show normal success message
                                              Navigator.of(dialogContext).pop();
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text(result['message'] ?? (isEditMode ? 'Transaction updated successfully' : 'Transaction created successfully')),
                                                  backgroundColor: AppTheme.secondaryColor,
                                                  duration: const Duration(seconds: 2),
                                                ),
                                              );
                                            }

                                            // Refresh dashboard data to update approvals list (same as expense)
                                            _loadDashboardData();
                                            _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);

                                            // Clear form
                                        _transactionAmountController.clear();
                                        _transactionPurposeController.clear();
                                        
                                        // Reset to default payment mode
                                        String defaultMode = 'Cash';
                                        if (_paymentModes.isNotEmpty) {
                                          final firstMode = _paymentModes.first;
                                          defaultMode = firstMode['modeName']?.toString() ?? 'Cash';
                                        }
                                        
                                        setState(() {
                                          _selectedTransactionMode = defaultMode;
                                          _selectedTransactionReceiverId = null;
                                            });

                                            // Refresh financial data immediately to show new transaction (same as expense)
                                            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                            
                                            // Refresh Smart Approvals if it's currently visible (same as expense)
                                            if (_selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
                                              _pendingApprovalsRefreshKey.currentState!.refresh();
                                            }
                                            
                                            // Also trigger filter update to ensure transaction appears
                                            Future.delayed(const Duration(milliseconds: 500), () {
                                              if (mounted) {
                                                _applyFilters();
                                              }
                                            });
                                          } else {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text(result['message'] ?? 'Operation failed'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      } catch (e, stackTrace) {
                                        print('üîÑ [TRANSACTION EDIT] ‚ùå ERROR caught:');
                                        print('   Error: $e');
                                        print('   Stack trace: $stackTrace');
                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                              content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    }
                                  },
                                  style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.accentBlue,
                                    foregroundColor: Colors.white,
                                  padding: EdgeInsets.symmetric(
                                    horizontal: 32,
                                    vertical: isMobile ? 16 : 14,
                                  ),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  ),
                                  child: dialogIsSubmitting
                                      ? const SizedBox(
                                          width: 20,
                                        height: 20,
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          valueColor:
                                              AlwaysStoppedAnimation<Color>(Colors.white),
                                          ),
                                        )
                                      : Text(
                                        isEditMode ? 'Update & Resubmit' : 'Submit',
                                        style: TextStyle(
                                          fontSize: isMobile ? 16 : 16,
                                          fontWeight: FontWeight.w600,
                                        ),
                                ),
                              ),
                                    ),
                                    const SizedBox(height: 12),
                                    SizedBox(
                                      width: double.infinity,
                                      child: TextButton(
                                        onPressed: dialogIsSubmitting
                                            ? null
                                            : () => Navigator.of(dialogContext).pop(),
                                        style: TextButton.styleFrom(
                                          padding: EdgeInsets.symmetric(
                                            vertical: isMobile ? 16 : 12,
                                          ),
                                        ),
                                        child: Text(
                                          'Cancel',
                                          style: TextStyle(
                                            color: AppTheme.primaryColor,
                                            fontSize: isMobile ? 16 : 15,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ],
                                )
                              : Row(
                                  mainAxisAlignment: MainAxisAlignment.end,
                                  children: [
                                    TextButton(
                                      onPressed: dialogIsSubmitting
                                          ? null
                                          : () => Navigator.of(dialogContext).pop(),
                                      style: TextButton.styleFrom(
                                        padding: EdgeInsets.symmetric(
                                          horizontal: 20,
                                          vertical: 10,
                                        ),
                                      ),
                                      child: Text(
                                        'Cancel',
                                        style: TextStyle(color: AppTheme.primaryColor),
                                      ),
                                    ),
                                    const SizedBox(width: 12),
                                    ElevatedButton(
                                        onPressed: dialogIsSubmitting ? null : () async {
                                print('\nüîÑ ===== SUBMIT BUTTON PRESSED (TRANSACTION DIALOG - NON-MOBILE) =====');
                                print('üîÑ [SUBMIT BUTTON] Button clicked in transaction dialog (non-mobile)');
                                print('   isEditMode: $isEditMode');
                                print('   existingTransactionData available: ${existingTransactionData != null}');
                                if (existingTransactionData != null) {
                                  print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
                                  print('   transactionId: ${existingTransactionData['transactionId']}');
                                  print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
                                } else {
                                  print('   ‚ö†Ô∏è existingTransactionData is NULL in submit handler!');
                                }
                                print('==========================================\n');
                                
                                if (_addTransactionFormKey.currentState!.validate()) {
                                  if (currentUserId == null) {
        ScaffoldMessenger.of(context).showSnackBar(
                                      const SnackBar(
                                        content: Text('Unable to get current user. Please login again.'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }

                                  // Skip receiver validation in edit mode
                                  if (!isEditMode) {
                                    if (_selectedTransactionReceiverId == null) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        const SnackBar(
                                          content: Text('Please select a receiver'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }

                                    if (currentUserId == _selectedTransactionReceiverId) {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        const SnackBar(
                                          content: Text('Cannot transfer to yourself'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                      return;
                                    }
                                  }

                                      setDialogState(() {
                                        dialogIsSubmitting = true;
      });

      try {
                                    final amount = double.parse(_transactionAmountController.text);
                                    final purpose = _transactionPurposeController.text.trim();

                                    // Get the actual mode (Cash/UPI/Bank) from the selected payment mode
                                    String transactionMode = 'Cash'; // Default fallback
                                    if (_selectedTransactionMode.isNotEmpty) {
                                      try {
                                        // Find the selected payment mode
                                        final selectedPaymentMode = _paymentModes.firstWhere(
                                          (mode) => mode['modeName']?.toString() == _selectedTransactionMode,
                                          orElse: () => <String, dynamic>{},
                                        );
                                        
                                        if (selectedPaymentMode.isNotEmpty) {
                                          // Parse description to get the mode (Cash/UPI/Bank)
                                          final description = selectedPaymentMode['description']?.toString() ?? '';
                                          if (description.isNotEmpty) {
                                            final parsed = PaymentModeService.parseDescription(description);
                                            final modeFromPaymentMode = parsed['mode']?.toString();
                                            
                                            if (modeFromPaymentMode != null && 
                                                ['Cash', 'UPI', 'Bank'].contains(modeFromPaymentMode)) {
                                              transactionMode = modeFromPaymentMode;
                                            }
                                          }
                                        }
                                        
                                        // Fallback: try to infer from modeName if mode not found in description
                                        if (transactionMode == 'Cash' && _selectedTransactionMode != 'Cash') {
                                          final modeNameUpper = _selectedTransactionMode.toUpperCase();
                                          if (modeNameUpper.contains('CASH')) {
                                            transactionMode = 'Cash';
                                          } else if (modeNameUpper.contains('UPI')) {
                                            transactionMode = 'UPI';
                                          } else if (modeNameUpper.contains('BANK')) {
                                            transactionMode = 'Bank';
                                          }
                                        }
                                      } catch (e) {
                                        debugPrint('Error parsing payment mode: $e');
                                        // Use default Cash if parsing fails
                                      }
                                    }

                                    Map<String, dynamic> result;
                                    if (isEditMode && existingTransactionData != null) {
                                      // Update existing transaction
                                      final transactionId = existingTransactionData['transactionId']?.toString() ?? '';
                                      // Check if from All Wallet Report
                                      final bool fromAllWalletReport = _selectedItem == NavItem.accountReports;
                                      
                                      result = await TransactionService.editTransaction(
                                        transactionId,
                                        amount: amount,
                                        mode: transactionMode,
                                        purpose: purpose.isEmpty ? null : purpose,
                                        proofUrl: existingTransactionData['proofUrl']?.toString(),
                                        fromAllWalletReport: fromAllWalletReport,
                                      );
                                    } else {
                                      // Create new transaction
                                      result = await TransactionService.createTransaction(
                                        sender: currentUserId!,
                                        receiver: _selectedTransactionReceiverId!,
                                        amount: amount,
                                        mode: transactionMode,
                                        purpose: purpose.isEmpty ? null : purpose,
                                      );
                                    }

                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });

                                          print('üîÑ [TRANSACTION EDIT] Result received (non-mobile):');
                                          print('   result[success]: ${result['success']}');
                                          print('   result[success] == true: ${result['success'] == true}');
                                          print('   result[success] == "true": ${result['success'] == "true"}');
                                          
                                          if (result['success'] == true || result['success'] == 'true') {
                                            // If editing from flagged item, also resubmit to change status to Pending
                                            print('üîÑ [TRANSACTION EDIT] ‚úÖ Update successful, checking resubmit conditions (non-mobile):');
                                            print('   isEditMode: $isEditMode');
                                            print('   existingTransactionData: ${existingTransactionData != null}');
                                            if (existingTransactionData != null) {
                                              print('   existingTransactionData keys: ${existingTransactionData.keys.toList()}');
                                              print('   fromFlaggedItem: ${existingTransactionData['fromFlaggedItem']}');
                                              print('   fromFlaggedItem type: ${existingTransactionData['fromFlaggedItem']?.runtimeType}');
                                              print('   flaggedItemId: ${existingTransactionData['flaggedItemId']}');
                                              print('   flaggedItemCategory: ${existingTransactionData['flaggedItemCategory']}');
                                              print('   transactionId: ${existingTransactionData['transactionId']}');
                                            }
                                            
                                            // Check if this is from a flagged item - use multiple checks to be safe
                                            final isFromFlaggedItem = existingTransactionData != null && (
                                              existingTransactionData['fromFlaggedItem'] == true ||
                                              existingTransactionData['fromFlaggedItem'] == 'true' ||
                                              existingTransactionData['fromFlaggedItem'] == 1 ||
                                              (existingTransactionData['flaggedItemId'] != null && existingTransactionData['flaggedItemId'].toString().isNotEmpty)
                                            );
                                            
                                            print('üîÑ [TRANSACTION EDIT] isFromFlaggedItem check result (non-mobile): $isFromFlaggedItem');
                                            print('üîÑ [TRANSACTION EDIT] Will resubmit if: isEditMode=$isEditMode AND isFromFlaggedItem=$isFromFlaggedItem');
                                            
                                            if (isEditMode && isFromFlaggedItem) {
                                              // Get transaction ID from multiple sources as fallback
                                              final transactionId = existingTransactionData?['transactionId']?.toString() ?? '';
                                              final flaggedItemId = existingTransactionData?['flaggedItemId']?.toString() ?? transactionId;
                                              final flaggedItemCategory = existingTransactionData?['flaggedItemCategory']?.toString() ?? 'transactions';
                                              
                                              // Use transactionId if flaggedItemId is empty
                                              final finalTransactionId = flaggedItemId.isNotEmpty ? flaggedItemId : transactionId;
                                              
                                              print('\nüö© ===== FLAGGED ITEM RESUBMIT FLOW START (NON-MOBILE) =====');
                                              print('üö© [FLAGGED ITEMS] ‚úÖ Will resubmit transaction: $finalTransactionId');
                                              print('üö© [FLAGGED ITEMS] Category: $flaggedItemCategory');
                                              print('üö© [FLAGGED ITEMS] Current step: Waiting for update to complete...');
                                              await Future.delayed(Duration(milliseconds: 500));
                                              
                                              print('üö© [FLAGGED ITEMS] Step 2: Calling resubmit API...');
                                              final resubmitResult = await TransactionService.resubmitTransaction(
                                                finalTransactionId,
                                                'Updated and resubmitted for approval',
                                              );
                                              
                                              print('üö© [FLAGGED ITEMS] Step 3: Resubmit API response received.');
                                              print('üö© [FLAGGED ITEMS] Resubmit result: success=${resubmitResult['success']}, message=${resubmitResult['message']}');
                                              
                                              if (resubmitResult['success'] == true) {
                                                print('üö© [FLAGGED ITEMS] Step 4: Resubmit successful, updating UI...');
                                                _resubmittedItemIds.add(finalTransactionId);
                                                _removeFlaggedItem(finalTransactionId, category: flaggedItemCategory);
                                                if (mounted) {
                                                  setState(() {
                                                    _timelineItems = [];
                                                  });
                                                }
                                                await Future.delayed(Duration(milliseconds: 1500));
                                                await _loadTimelineEntries();
                                                Future.delayed(Duration(seconds: 5), () {
                                                  _resubmittedItemIds.remove(finalTransactionId);
                                                });
                                                
                                                Navigator.of(dialogContext).pop();
                                                
                                                if (mounted) {
                                                  ScaffoldMessenger.of(context).showSnackBar(
                                                    SnackBar(
                                                      content: Text(resubmitResult['message']?.toString() ?? 'Transaction updated and resubmitted successfully.'),
                                                      backgroundColor: AppTheme.secondaryColor,
                                                      duration: const Duration(seconds: 3),
                                                    ),
                                                  );
                                                }
                                                
                                                // Stay on the same page (don't navigate to Smart Approvals)
                                                print('üö© [FLAGGED ITEMS] Step 5: Staying on current page (not navigating to Smart Approvals)');
                                                
                                                print('üö© [FLAGGED ITEMS] Step 6: Refreshing dashboard data...');
                                                _loadDashboardData();
                                                _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                                print('üö© [FLAGGED ITEMS] ‚úÖ Dashboard data refresh initiated');

                                                await Future.delayed(Duration(milliseconds: 1000));
                                                print('üö© [FLAGGED ITEMS] Step 7: Waiting complete, refreshing Smart Approvals...');

                                                if (mounted && _selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
                                                  print('üö© [FLAGGED ITEMS] ‚úÖ Refreshing Smart Approvals after resubmit');
                                                  _pendingApprovalsRefreshKey.currentState!.refresh();
                                                } else {
                                                  print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Cannot refresh Smart Approvals: mounted=$mounted, selectedItem=${_selectedItem}, refreshKey=${_pendingApprovalsRefreshKey.currentState != null}');
                                                }
                                                
                                                print('\nüö© ===== FLAGGED ITEM RESUBMIT FLOW COMPLETE (NON-MOBILE) =====\n');
                                                
                                                Future.delayed(const Duration(milliseconds: 1000), () {
                                                  if (mounted) {
                                                    print('üîÑ [TRANSACTION EDIT] Applying filters...');
                                                    _applyFilters();
                                                  }
                                                });
                                                
                                              } else {
                                                // If resubmit failed, show error
                                                print('\nüö© [FLAGGED ITEMS] ‚ùå RESUBMIT FAILED (NON-MOBILE)!');
                                                print('   Error message: ${resubmitResult['message']}');
                                                print('   Full result: $resubmitResult');
                                                print('   Transaction ID: $finalTransactionId');
                                                print('==========================================\n');
                                                
                                                Navigator.of(dialogContext).pop();
                                                if (mounted) {
                                                  ScaffoldMessenger.of(context).showSnackBar(
                                                    SnackBar(
                                                      content: Text(resubmitResult['message']?.toString() ?? 'Failed to resubmit transaction'),
                                                      backgroundColor: AppTheme.errorColor,
                                                    ),
                                                  );
                                                }
                                              }
                                            } else {
                                              // Not from flagged item, just show normal success message
                                              Navigator.of(dialogContext).pop();

                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text(result['message'] ?? (isEditMode ? 'Transaction updated successfully' : 'Transaction created successfully')),
                                                  backgroundColor: AppTheme.secondaryColor,
                                                  duration: const Duration(seconds: 2),
                                                ),
                                              );
                                            }

                                            // Refresh dashboard data to update approvals list (same as expense)
                                            _loadDashboardData();
                                            _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);

                                            // Clear form
                                        _transactionAmountController.clear();
                                        _transactionPurposeController.clear();
                                        
                                        // Reset to default payment mode
                                        String defaultMode = 'Cash';
                                        if (_paymentModes.isNotEmpty) {
                                          final firstMode = _paymentModes.first;
                                          defaultMode = firstMode['modeName']?.toString() ?? 'Cash';
                                        }
                                        
                                        setState(() {
                                          _selectedTransactionMode = defaultMode;
                                        });

                                            // Refresh financial data immediately to show new transaction (same as expense)
                                            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                            
                                            // Refresh Smart Approvals if it's currently visible (same as expense)
                                            if (_selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
                                              _pendingApprovalsRefreshKey.currentState!.refresh();
                                            }
                                            
                                            // Also trigger filter update to ensure transaction appears
                                            Future.delayed(const Duration(milliseconds: 500), () {
                                              if (mounted) {
                                                _applyFilters();
                                              }
                                            });
                                          } else {
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                    content: Text(result['message'] ??
                                                        'Operation failed'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      } catch (e) {
                                        if (mounted) {
                                          setDialogState(() {
                                            dialogIsSubmitting = false;
                                          });

                                          ScaffoldMessenger.of(context).showSnackBar(
                                            SnackBar(
                                                  content: Text(
                                                      'Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                              backgroundColor: AppTheme.errorColor,
                                              duration: const Duration(seconds: 3),
                                            ),
                                          );
                                        }
                                      }
                                    }
                                  },
                                  style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.accentBlue,
                                    foregroundColor: Colors.white,
                                  padding: const EdgeInsets.symmetric(
                                    horizontal: 32,
                                    vertical: 14,
                                  ),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  ),
                                  child: dialogIsSubmitting
                                      ? const SizedBox(
                                          width: 20,
                                        height: 20,
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          valueColor:
                                              AlwaysStoppedAnimation<Color>(Colors.white),
                                          ),
                                        )
                                      : Text(
                                        isEditMode ? 'Update & Resubmit' : 'Submit',
                                        style: const TextStyle(
                                          fontSize: 16,
                                          fontWeight: FontWeight.w600,
                                        ),
                                ),
                              ),
                                  ],
                                ),
                          ),
                        ],
                    ),
                  ),
                ),
              );
            },
          );
        },
      ).then((_) {
        // Dispose controller when dialog is dismissed - delay to ensure widget tree is cleaned up
        if (!controllerDisposed && receiverSearchController != null) {
          // Use SchedulerBinding to ensure disposal happens after frame is complete
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!controllerDisposed && receiverSearchController != null) {
              receiverSearchController.dispose();
              controllerDisposed = true;
            }
          });
        }
      });
    } catch (e) {
      // Dispose controller on error as well
      if (!controllerDisposed && receiverSearchController != null) {
        receiverSearchController.dispose();
        controllerDisposed = true;
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  // Dashboard Header Widget Builders
  Widget _buildWelcomeSection(bool isMobile, bool isTablet) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 20 : 24),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(
            'Welcome, ${_dashboardUserName ?? 'User'}!',
            style: AppTheme.headingLarge.copyWith(
              fontSize: isMobile ? 24 : 28,
            ),
          ),
          Spacer(),
          Text(
            _greeting,
            style: AppTheme.headingMedium.copyWith(
              fontSize: isMobile ? 18 : 20,
              color: AppTheme.primaryColor,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWelcomeRowWithSlogan(bool isMobile, bool isTablet) {
    // Quote card aligned to left
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isMobile ? 16 : 24,
        vertical: isMobile ? 0 : 4,
      ),
      child: _buildDailySloganSection(isMobile, isTablet),
    );
  }

  Widget _buildDailySloganSectionContent(bool isMobile, bool isTablet) {
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isMobile ? 20 : 28,
        vertical: isMobile ? 20 : 24,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: AppTheme.borderColor.withOpacity(0.5),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 12,
            offset: const Offset(0, 4),
            spreadRadius: 0,
          ),
        ],
      ),
      child: _isLoadingQuote
          ? Center(
              child: Padding(
                padding: const EdgeInsets.all(20.0),
                child: CircularProgressIndicator(
                  strokeWidth: 2.5,
                  valueColor: AlwaysStoppedAnimation<Color>(AppTheme.primaryColor),
                ),
              ),
            )
          : Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(
                      Icons.format_quote,
                      color: AppTheme.primaryColor,
                      size: isMobile ? 24 : (isTablet ? 28 : 32),
                    ),
                    SizedBox(width: 12),
                    Flexible(
                      child: Text(
                        _dailyQuote.isNotEmpty ? _dailyQuote : 'Loading quote...',
                        textAlign: TextAlign.center,
                        style: AppTheme.bodyLarge.copyWith(
                          fontSize: isMobile ? 15 : (isTablet ? 17 : 18),
                          fontStyle: FontStyle.italic,
                          color: AppTheme.textPrimary.withOpacity(0.8),
                          height: 1.5,
                          letterSpacing: 0.2,
                        ),
                      ),
                    ),
                  ],
                ),
                if (_quoteAuthor.isNotEmpty) ...[
                  SizedBox(height: 12),
                  Align(
                    alignment: Alignment.centerRight,
                    child: Text(
                      '- $_quoteAuthor',
                      style: AppTheme.bodyMedium.copyWith(
                        fontSize: isMobile ? 13 : (isTablet ? 14 : 15),
                        color: AppTheme.textMuted,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ],
            ),
    );
  }

  Widget _buildDailySloganSection(bool isMobile, bool isTablet) {
    return Container(
      width: double.infinity, // Full width
      padding: EdgeInsets.symmetric(
        horizontal: isMobile ? 16 : 24,
        vertical: isMobile ? 8 : 12,
      ),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFFF6B9D).withOpacity(0.12), // Soft Pink
            Color(0xFFC77DFF).withOpacity(0.18), // Soft Purple
            Color(0xFF4A90E2).withOpacity(0.15), // Soft Blue
            Color(0xFF50C878).withOpacity(0.10), // Soft Green
            Color(0xFFFFB347).withOpacity(0.12), // Soft Orange
          ],
          stops: [0.0, 0.3, 0.5, 0.7, 1.0],
        ),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Color(0xFFC77DFF).withOpacity(0.2), // Purple shadow
            blurRadius: 12,
            offset: const Offset(0, 4),
            spreadRadius: 0,
          ),
        ],
      ),
      child: _isLoadingQuote
          ? Center(
              child: Padding(
                padding: const EdgeInsets.all(20.0),
                child: CircularProgressIndicator(
                  strokeWidth: 3,
                  valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF9D4EDD)), // Purple spinner
                ),
              ),
            )
          : Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(
                      Icons.format_quote,
                      color: Color(0xFF9D4EDD), // Purple icon
                      size: isMobile ? 24 : (isTablet ? 28 : 30),
                    ),
                    SizedBox(width: 10),
                    Flexible(
                      child: Text(
                        _dailyQuote.isNotEmpty ? _dailyQuote : 'Loading quote...',
                        textAlign: TextAlign.left,
                        style: AppTheme.bodyLarge.copyWith(
                          fontSize: isMobile ? 14 : (isTablet ? 16 : 18),
                          fontStyle: FontStyle.italic,
                          color: AppTheme.textPrimary, // Dark text for mild gradient
                          height: 1.5,
                          letterSpacing: 0.2,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                if (_quoteAuthor.isNotEmpty) ...[
                  SizedBox(height: 12),
                  Align(
                    alignment: Alignment.centerRight,
                    child: Text(
                      '- $_quoteAuthor',
                      style: AppTheme.bodyMedium.copyWith(
                        fontSize: isMobile ? 12 : (isTablet ? 13 : 14),
                        color: AppTheme.textSecondary, // Secondary text color for mild gradient
                        fontWeight: FontWeight.w400,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ),
                ],
              ],
            ),
    );
  }

  Widget _buildFinancialSummaryCards(bool isMobile, bool isTablet) {
    // Log values when UI is being built
    debugPrint('üí∞ [UI BUILD] _buildFinancialSummaryCards called:');
    debugPrint('   _cashIn=$_cashIn, _cashOut=$_cashOut, _balance=$_balance');
    debugPrint('   _userCashIn=$_userCashIn, _userCashOut=$_userCashOut, _userBalance=$_userBalance');
    debugPrint('   _isExpenseReportMode=$_isExpenseReportMode, _selectedItem=$_selectedItem');
    
    // Financial Summary card matching Quote card size
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: isMobile ? 16 : 24,
        vertical: isMobile ? 0 : 4,
      ),
      child: Container(
        width: double.infinity, // Full width
        padding: EdgeInsets.symmetric(
          horizontal: isMobile ? 16 : 24,
          vertical: isMobile ? 8 : 12,
        ),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12), // Match quote card
          border: Border.all(color: AppTheme.borderColor),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 6,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            // Cash In Row
            _buildCompactFinancialRow(
              icon: Icons.arrow_downward,
              label: 'Cash In',
              amount: _userCashIn,
              color: AppTheme.secondaryColor,
              isMobile: isMobile,
              isTablet: isTablet,
              amountColor: AppTheme.textSecondary, // Grey amount
            ),
            SizedBox(height: isMobile ? 8 : 10),
            
            // Cash Out Row
            _buildCompactFinancialRow(
              icon: Icons.arrow_upward,
              label: 'Cash Out',
              amount: _userCashOut,
              color: AppTheme.errorColor,
              isMobile: isMobile,
              isTablet: isTablet,
              amountColor: AppTheme.textSecondary, // Grey amount
            ),
            SizedBox(height: isMobile ? 8 : 10),
            
            // Balance Row (with dynamic color)
            _buildCompactFinancialRow(
              icon: Icons.account_balance_wallet,
              label: 'Balance',
              amount: _userBalance,
              color: _getBalanceColor(_userBalance),
              isMobile: isMobile,
              isTablet: isTablet,
              amountColor: _getBalanceColor(_userBalance), // Dynamic color for balance
            ),
          ],
        ),
      ),
    );
  }

  Color _getBalanceColor(double balance) {
    if (balance > 0) {
      return AppTheme.secondaryColor; // Green for positive
    } else if (balance == 0) {
      return AppTheme.textPrimary; // Black for zero
    } else {
      return AppTheme.warningColor; // Mild orange for negative
    }
  }

  Widget _buildCompactFinancialRow({
    required IconData icon,
    required String label,
    required double amount,
    required Color color,
    required bool isMobile,
    required bool isTablet,
    Color? amountColor,
  }) {
    return Row(
      children: [
        Icon(
          icon,
          color: color,
          size: isMobile ? 18 : (isTablet ? 19 : 20),
        ),
        SizedBox(width: isMobile ? 6 : 8),
        Text(
          label,
          style: AppTheme.bodyMedium.copyWith(
            fontSize: isMobile ? 12 : (isTablet ? 13 : 14),
            color: AppTheme.textSecondary,
          ),
        ),
        Spacer(),
        Text(
          '‚Çπ ${_formatCurrency(amount)}',
          style: AppTheme.headingSmall.copyWith(
            fontSize: isMobile ? 16 : (isTablet ? 17 : 18),
            fontWeight: FontWeight.bold,
            color: amountColor ?? AppTheme.textSecondary,
          ),
        ),
      ],
    );
  }

  Widget _buildStatusCountCards(bool isMobile, bool isTablet) {
    // Calculate total counts
    final expensesUnapproved = (_statusCounts['expenses']?['unapproved'] as num?)?.toInt() ?? 0;
    final transactionsUnapproved = (_statusCounts['transactions']?['unapproved'] as num?)?.toInt() ?? 0;
    final totalUnapproved = expensesUnapproved + transactionsUnapproved;

    final expensesApproved = (_statusCounts['expenses']?['approved'] as num?)?.toInt() ?? 0;
    final transactionsApproved = (_statusCounts['transactions']?['approved'] as num?)?.toInt() ?? 0;
    final totalApproved = expensesApproved + transactionsApproved;

    final collectionsAccounted = (_statusCounts['collections']?['accounted'] as num?)?.toInt() ?? 0;
    final collectionsUnaccounted = (_statusCounts['collections']?['unaccounted'] as num?)?.toInt() ?? 0;

    final expensesFlagged = (_statusCounts['expenses']?['flagged'] as num?)?.toInt() ?? 0;
    final transactionsFlagged = (_statusCounts['transactions']?['flagged'] as num?)?.toInt() ?? 0;
    final collectionsFlagged = (_statusCounts['collections']?['flagged'] as num?)?.toInt() ?? 0;
    final totalFlagged = expensesFlagged + transactionsFlagged + collectionsFlagged;

    return Row(
      children: [
        Expanded(
          child: _buildStatusCountCard(
            'Unapproved',
            totalUnapproved.toString(),
            Icons.undo,
            AppTheme.warningColor,
            isMobile,
            isTablet,
          ),
        ),
        SizedBox(width: isMobile ? 12 : 16),
        Expanded(
          child: _buildStatusCountCard(
            'Approve',
            totalApproved.toString(),
            Icons.check_circle,
            AppTheme.secondaryColor,
            isMobile,
            isTablet,
          ),
        ),
        SizedBox(width: isMobile ? 12 : 16),
        Expanded(
          child: _buildStatusCountCard(
            'Accounted',
            collectionsAccounted.toString(),
            Icons.verified,
            AppTheme.accentBlue,
            isMobile,
            isTablet,
          ),
        ),
        SizedBox(width: isMobile ? 12 : 16),
        Expanded(
          child: _buildStatusCountCard(
            'Unaccounted',
            collectionsUnaccounted.toString(),
            Icons.account_circle,
            AppTheme.primaryColor,
            isMobile,
            isTablet,
          ),
        ),
        SizedBox(width: isMobile ? 12 : 16),
        Expanded(
          child: _buildStatusCountCard(
            'Flagged',
            totalFlagged.toString(),
            Icons.flag,
            AppTheme.warningColor,
            isMobile,
            isTablet,
          ),
        ),
      ],
    );
  }

  Widget _buildStatusCountCard(
    String title,
    String count,
    IconData icon,
    Color color,
    bool isMobile,
    bool isTablet,
  ) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 18 : 20)),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: AppTheme.borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: AppTheme.bodyMedium.copyWith(
                  color: AppTheme.textSecondary,
                  fontSize: isMobile ? 13 : 14,
                ),
              ),
              Icon(icon, color: color, size: isMobile ? 20 : 24),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            count,
            style: AppTheme.headingMedium.copyWith(
              fontSize: isMobile ? 20 : (isTablet ? 22 : 24),
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFinancialCard(
    String title,
    String amount,
    IconData icon,
    Color color,
    bool isMobile,
    bool isTablet,
  ) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 16 : 20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: AppTheme.borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: color, size: isMobile ? 24 : 28),
              ),
              SizedBox(width: 12),
              Expanded(
                child: Text(
                  title,
                  style: AppTheme.bodyMedium.copyWith(
                    color: AppTheme.textSecondary,
                    fontSize: isMobile ? 13 : 14,
                  ),
                ),
              ),
            ],
          ),
          SizedBox(height: 12),
          Text(
            amount,
            style: AppTheme.headingMedium.copyWith(
              fontSize: isMobile ? 20 : 24,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusCards(bool isMobile, bool isTablet) {
    // Helper function to safely extract count and amount (handles both int and Map formats)
    Map<String, dynamic> _extractStatusData(dynamic statusValue) {
      if (statusValue == null) {
        return {'count': 0, 'amount': 0};
      } else if (statusValue is Map) {
        return {
          'count': (statusValue['count'] as num?)?.toInt() ?? 0,
          'amount': (statusValue['amount'] as num?)?.toDouble() ?? 0.0,
        };
      } else if (statusValue is num) {
        // Old format: just a number (count only)
        return {'count': statusValue.toInt(), 'amount': 0.0};
      } else {
        return {'count': 0, 'amount': 0};
      }
    }
    
    // Get breakdown data from _statusCounts (from dashboard summary endpoint)
    debugPrint('[DASHBOARD] üìä Current _statusCounts: $_statusCounts');
    final expensesData = _statusCounts['expenses'] as Map<String, dynamic>? ?? {};
    final transactionsData = _statusCounts['transactions'] as Map<String, dynamic>? ?? {};
    final collectionsData = _statusCounts['collections'] as Map<String, dynamic>? ?? {};
    
    debugPrint('[DASHBOARD] üìä expensesData: $expensesData');
    debugPrint('[DASHBOARD] üìä transactionsData: $transactionsData');
    debugPrint('[DASHBOARD] üìä collectionsData: $collectionsData');
    
    // Extract count and amount from _statusCounts structure
    // Handles both formats: {count: X, amount: Y} or just X (old format)
    final expensesApproved = _extractStatusData(expensesData['approved']);
    final expensesUnapproved = _extractStatusData(expensesData['unapproved']);
    final expensesFlagged = _extractStatusData(expensesData['flagged']);
    
    debugPrint('[DASHBOARD] üìä expensesApproved: $expensesApproved');
    debugPrint('[DASHBOARD] üìä expensesUnapproved: $expensesUnapproved');
    debugPrint('[DASHBOARD] üìä expensesFlagged: $expensesFlagged');
    
    final transactionsApproved = _extractStatusData(transactionsData['approved']);
    final transactionsUnapproved = _extractStatusData(transactionsData['unapproved']);
    final transactionsFlagged = _extractStatusData(transactionsData['flagged']);
    
    final collectionsAccounted = _extractStatusData(collectionsData['accounted']);
    final collectionsUnaccounted = _extractStatusData(collectionsData['unaccounted']);
    final collectionsFlagged = _extractStatusData(collectionsData['flagged']);
    
    // Create breakdown maps from _statusCounts
    final expensesBreakdown = <String, Map<String, dynamic>>{
      'Approved': {
        'count': (expensesApproved['count'] as num?)?.toInt() ?? 0,
        'amount': (expensesApproved['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Unapproved': {
        'count': (expensesUnapproved['count'] as num?)?.toInt() ?? 0,
        'amount': (expensesUnapproved['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Flagged': {
        'count': (expensesFlagged['count'] as num?)?.toInt() ?? 0,
        'amount': (expensesFlagged['amount'] as num?)?.toDouble() ?? 0.0,
      },
    };
    
    final transactionsBreakdown = <String, Map<String, dynamic>>{
      'Approved': {
        'count': (transactionsApproved['count'] as num?)?.toInt() ?? 0,
        'amount': (transactionsApproved['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Unapproved': {
        'count': (transactionsUnapproved['count'] as num?)?.toInt() ?? 0,
        'amount': (transactionsUnapproved['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Flagged': {
        'count': (transactionsFlagged['count'] as num?)?.toInt() ?? 0,
        'amount': (transactionsFlagged['amount'] as num?)?.toDouble() ?? 0.0,
      },
    };
    
    final collectionsBreakdown = <String, Map<String, dynamic>>{
      'Accounted': {
        'count': (collectionsAccounted['count'] as num?)?.toInt() ?? 0,
        'amount': (collectionsAccounted['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Unaccounted': {
        'count': (collectionsUnaccounted['count'] as num?)?.toInt() ?? 0,
        'amount': (collectionsUnaccounted['amount'] as num?)?.toDouble() ?? 0.0,
      },
      'Flagged': {
        'count': (collectionsFlagged['count'] as num?)?.toInt() ?? 0,
        'amount': (collectionsFlagged['amount'] as num?)?.toDouble() ?? 0.0,
      },
    };
    
    debugPrint('[DASHBOARD] üìä Building Status Cards with _statusCounts:');
    debugPrint('[DASHBOARD] üìä Expenses breakdown: $expensesBreakdown');
    debugPrint('[DASHBOARD] üìä Transactions breakdown: $transactionsBreakdown');
    debugPrint('[DASHBOARD] üìä Collections breakdown: $collectionsBreakdown');
    
    // Calculate totals for each category
    // Total = Unapproved + Flagged only (excludes Approved/Accounted)
    final expensesUnapprovedData = expensesBreakdown['Unapproved'] ?? {'count': 0, 'amount': 0.0};
    final expensesFlaggedData = expensesBreakdown['Flagged'] ?? {'count': 0, 'amount': 0.0};
    final expensesTotalCount = (expensesUnapprovedData['count'] as int? ?? 0) + 
                              (expensesFlaggedData['count'] as int? ?? 0);
    final expensesTotalAmount = (expensesUnapprovedData['amount'] as double? ?? 0.0) + 
                               (expensesFlaggedData['amount'] as double? ?? 0.0);
    
    final transactionsUnapprovedData = transactionsBreakdown['Unapproved'] ?? {'count': 0, 'amount': 0.0};
    final transactionsFlaggedData = transactionsBreakdown['Flagged'] ?? {'count': 0, 'amount': 0.0};
    final transactionsTotalCount = (transactionsUnapprovedData['count'] as int? ?? 0) + 
                                   (transactionsFlaggedData['count'] as int? ?? 0);
    final transactionsTotalAmount = (transactionsUnapprovedData['amount'] as double? ?? 0.0) + 
                                     (transactionsFlaggedData['amount'] as double? ?? 0.0);
    
    final collectionsUnaccountedData = collectionsBreakdown['Unaccounted'] ?? {'count': 0, 'amount': 0.0};
    final collectionsFlaggedData = collectionsBreakdown['Flagged'] ?? {'count': 0, 'amount': 0.0};
    final collectionsTotalCount = (collectionsUnaccountedData['count'] as int? ?? 0) + 
                                 (collectionsFlaggedData['count'] as int? ?? 0);
    final collectionsTotalAmount = (collectionsUnaccountedData['amount'] as double? ?? 0.0) + 
                                   (collectionsFlaggedData['amount'] as double? ?? 0.0);
    
    // Calculate grand totals (sum of Unapproved + Flagged across all categories)
    final grandTotalCount = expensesTotalCount + transactionsTotalCount + collectionsTotalCount;
    final grandTotalAmount = expensesTotalAmount + transactionsTotalAmount + collectionsTotalAmount;
    
    // Calculate column totals (Unapproved/Unaccounted, Flagged, Total)
    // Unapproved/Unaccounted totals - use breakdown maps (already extracted above)
    final totalUnapprovedCount = (expensesUnapprovedData['count'] as int? ?? 0) + 
                                (transactionsUnapprovedData['count'] as int? ?? 0) + 
                                (collectionsUnaccountedData['count'] as int? ?? 0);
    
    final totalUnapprovedAmount = (expensesUnapprovedData['amount'] as double? ?? 0.0) + 
                                  (transactionsUnapprovedData['amount'] as double? ?? 0.0) + 
                                  (collectionsUnaccountedData['amount'] as double? ?? 0.0);
    
    // Flagged counts are already extracted above for total calculation
    
    // Calculate flagged totals
    final totalFlaggedCount = (expensesFlaggedData['count'] as int? ?? 0) + 
                             (transactionsFlaggedData['count'] as int? ?? 0) + 
                             (collectionsFlaggedData['count'] as int? ?? 0);
    final totalFlaggedAmount = (expensesFlaggedData['amount'] as double? ?? 0.0) + 
                              (transactionsFlaggedData['amount'] as double? ?? 0.0) + 
                              (collectionsFlaggedData['amount'] as double? ?? 0.0);
    
    return Padding(
      padding: EdgeInsets.symmetric(
        vertical: isMobile ? 16 : 24,
        horizontal: isMobile ? 12 : 24,
      ),
      child: Align(
        alignment: Alignment.center,
        child: SizedBox(
          width: isMobile ? double.infinity : MediaQuery.of(context).size.width * 0.6,
          child: Container(
          key: _statusTableKey,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 8,
                offset: Offset(0, 2),
              ),
            ],
          ),
      child: Column(
        children: [
          // Header Section with Title
          Container(
            padding: EdgeInsets.all(isMobile ? 12 : (isTablet ? 18 : 20)),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor.withOpacity(0.1),
              borderRadius: BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Title Row
                Row(
                  children: [
                    Icon(
                      Icons.table_chart,
                      color: AppTheme.primaryColor,
                      size: isMobile ? 22 : (isTablet ? 22 : 24),
                    ),
                    SizedBox(width: isMobile ? 10 : 12),
                    Text(
                      'Status Count Table',
                      style: AppTheme.headingSmall.copyWith(
                        fontSize: isMobile ? 18 : (isTablet ? 18 : 20),
                        fontWeight: FontWeight.w600,
                        color: AppTheme.textPrimary,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: isMobile ? 10 : 12),
                // Legend Row (Expenses, Collections, Transactions) - Wrap on mobile
                isMobile
                    ? Wrap(
                        spacing: 12,
                        runSpacing: 8,
                        children: [
                          // Expenses
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.receipt,
                                color: Colors.purple,
                                size: 14,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Expenses',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: 10,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          // Collections
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.account_balance,
                                color: AppTheme.secondaryColor,
                                size: 14,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Collections',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: 10,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          // Transactions
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.swap_horiz,
                                color: AppTheme.primaryColor,
                                size: 14,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Transactions',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: 10,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          // Grand Total
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.calculate,
                                color: AppTheme.accentBlue,
                                size: 14,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Grand Total',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: 10,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                        ],
                      )
                    : Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          // Expenses
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.receipt,
                                color: Colors.purple,
                                size: isTablet ? 16 : 18,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Expenses',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: isTablet ? 12 : 13,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          SizedBox(width: 16),
                          // Collections
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.account_balance,
                                color: AppTheme.secondaryColor,
                                size: isTablet ? 16 : 18,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Collections',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: isTablet ? 12 : 13,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          SizedBox(width: 16),
                          // Transactions
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.swap_horiz,
                                color: AppTheme.primaryColor,
                                size: isTablet ? 16 : 18,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Transactions',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: isTablet ? 12 : 13,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                          SizedBox(width: 16),
                          // Grand Total
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.calculate,
                                color: AppTheme.accentBlue,
                                size: isTablet ? 16 : 18,
                              ),
                              SizedBox(width: 4),
                              Text(
                                'Grand Total',
                                style: AppTheme.bodySmall.copyWith(
                                  color: AppTheme.textSecondary,
                                  fontSize: isTablet ? 12 : 13,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                SizedBox(height: isMobile ? 12 : 16),
                Divider(height: 1, color: AppTheme.borderColor),
                SizedBox(height: isMobile ? 12 : 12),
                // Column Header Row
                // Status Count Table Structure:
                // - Column 1: Unapproved/Unaccounted (Blue) - Items not yet approved/accounted
                //   Includes: Pending, Rejected, Unapproved, any non-approved status
                // - Column 2: Flagged (Orange) - Items marked for review/attention
                //   Includes: Only items with "Flagged" status
                // - Column 3: Total (Purple/Green) - Sum of Unapproved + Flagged only
                //   Formula: Total = Unapproved + Flagged (excludes Approved/Accounted)
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: isMobile ? 4 : 4),
                  child: Row(
                    children: [
                      // Type Column (for icon spacing)
                      SizedBox(
                        width: isMobile ? 40 : 48,
                        child: Text(
                          'Type',
                          style: AppTheme.bodySmall.copyWith(
                            fontSize: isMobile ? 10 : (isTablet ? 11 : 12),
                            fontWeight: FontWeight.w600,
                            color: AppTheme.textPrimary,
                          ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                      SizedBox(width: isMobile ? 8 : 16),
                      // Unapproved/Unaccounted Column Header
                      // Shows items that need approval/accounting (Blue color)
                      Expanded(
                        child: Text(
                          isMobile ? 'Unapproved' : 'Unapproved/\nUnaccounted',
                          style: AppTheme.bodySmall.copyWith(
                            fontSize: isMobile ? 10 : (isTablet ? 11 : 12),
                            fontWeight: FontWeight.w600,
                            color: AppTheme.textPrimary,
                          ),
                          textAlign: TextAlign.left,
                          maxLines: isMobile ? 1 : 2,
                        ),
                      ),
                      SizedBox(width: isMobile ? 6 : 12),
                      // Flagged Column Header
                      // Shows items marked for review/attention (Orange color)
                      Expanded(
                        child: Text(
                          'Flagged',
                          style: AppTheme.bodySmall.copyWith(
                            fontSize: isMobile ? 10 : (isTablet ? 11 : 12),
                            fontWeight: FontWeight.w600,
                            color: AppTheme.textPrimary,
                          ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                      SizedBox(width: isMobile ? 6 : 12),
                      // Total Column Header
                      // Shows sum of Unapproved + Flagged only (excludes Approved/Accounted)
                      Expanded(
                        child: Text(
                          'Total',
                          style: AppTheme.bodySmall.copyWith(
                            fontSize: isMobile ? 10 : (isTablet ? 11 : 12),
                            fontWeight: FontWeight.w600,
                            color: AppTheme.textPrimary,
                          ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: isMobile ? 16 : 32),
            child: Divider(height: 1, color: AppTheme.borderColor),
          ),
          // Expenses Row
          _buildStatusRow(
            Icons.receipt,
            'Expenses',
            expensesBreakdown,
            expensesTotalCount,
            expensesTotalAmount,
            isMobile,
            isTablet,
            isCollection: false,
            iconColor: Colors.purple,
          ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: isMobile ? 16 : 32),
            child: Divider(height: 1, color: AppTheme.borderColor),
          ),
          // Transactions Row
          _buildStatusRow(
            Icons.swap_horiz,
            'Transactions',
            transactionsBreakdown,
            transactionsTotalCount,
            transactionsTotalAmount,
            isMobile,
            isTablet,
            isCollection: false,
            iconColor: AppTheme.accentBlue,
          ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: isMobile ? 16 : 32),
            child: Divider(height: 1, color: AppTheme.borderColor),
          ),
          // Collections Row
          _buildStatusRow(
            Icons.account_balance,
            'Collections',
            collectionsBreakdown,
            collectionsTotalCount,
            collectionsTotalAmount,
            isMobile,
            isTablet,
            isCollection: true,
            iconColor: AppTheme.secondaryColor,
          ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: isMobile ? 16 : 32),
            child: Divider(height: 1, color: AppTheme.borderColor),
          ),
          // Grand Total Row
          _buildGrandTotalRow(
            totalUnapprovedCount,
            totalUnapprovedAmount,
            totalFlaggedCount,
            totalFlaggedAmount,
            grandTotalCount,
            grandTotalAmount,
            isMobile,
            isTablet,
          ),
        ],
      ),
        ),
        ),
      ),
    );
  }

  /// Builds a status row for the Status Count Table
  /// Displays 3 columns: Unapproved/Unaccounted, Flagged, and Total
  /// 
  /// Column 1 (Unapproved/Unaccounted): Items not yet approved/accounted
  /// Column 2 (Flagged): Items marked for review (separate from Unapproved)
  /// Column 3 (Total): Sum of Unapproved + Flagged only (excludes Approved/Accounted)
  Widget _buildStatusRow(
    IconData icon,
    String categoryName,
    Map<String, Map<String, dynamic>> breakdown,
    int totalCount,
    double totalAmount,
    bool isMobile,
    bool isTablet, {
    bool isCollection = false,
    Color? iconColor,
  }) {
    // Get counts and amounts for each status
    final approvedData = breakdown[isCollection ? 'Accounted' : 'Approved'] ?? {'count': 0, 'amount': 0.0};
    final unapprovedData = breakdown[isCollection ? 'Unaccounted' : 'Unapproved'] ?? {'count': 0, 'amount': 0.0};
    final flaggedData = breakdown['Flagged'] ?? {'count': 0, 'amount': 0.0};
    
    final approvedCount = (approvedData['count'] as int? ?? 0);
    final approvedAmount = (approvedData['amount'] as double? ?? 0.0);
    final unapprovedCount = (unapprovedData['count'] as int? ?? 0);
    final unapprovedAmount = (unapprovedData['amount'] as double? ?? 0.0);
    final flaggedCount = (flaggedData['count'] as int? ?? 0);
    final flaggedAmount = (flaggedData['amount'] as double? ?? 0.0);
    
    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      child: Row(
        children: [
          // Icon Column
          Container(
            width: isMobile ? 40 : 48,
            height: isMobile ? 40 : 48,
            decoration: BoxDecoration(
              color: AppTheme.borderColor.withOpacity(0.3),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              icon,
              color: iconColor ?? AppTheme.textSecondary,
              size: isMobile ? 22 : 24,
            ),
          ),
          SizedBox(width: isMobile ? 8 : 16),
          // Unapproved/Unaccounted Column
          Expanded(
            child: _buildStatusColumn(
              unapprovedCount,
              unapprovedAmount,
              AppTheme.infoColor,
              isMobile,
              isTablet,
              icon: Icons.undo_outlined,
              iconColor: AppTheme.infoColor,
            ),
          ),
          SizedBox(width: isMobile ? 6 : 12),
          // Flagged Column
          Expanded(
            child: _buildStatusColumn(
              flaggedCount,
              flaggedAmount,
              AppTheme.warningColor,
              isMobile,
              isTablet,
              icon: Icons.flag_outlined,
              iconColor: AppTheme.warningColor,
            ),
          ),
          SizedBox(width: isMobile ? 6 : 12),
          // Total Column
          Expanded(
            child: _buildStatusColumn(
              totalCount,
              totalAmount,
              AppTheme.primaryColor,
              isMobile,
              isTablet,
              icon: Icons.calculate_outlined,
              iconColor: AppTheme.primaryColor,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusColumn(
    int count,
    double amount,
    Color color,
    bool isMobile,
    bool isTablet, {
    IconData? icon,
    Color? iconColor,
  }) {
    return Container(
      padding: EdgeInsets.symmetric(
        vertical: isMobile ? 8 : (isTablet ? 12 : 14),
        horizontal: isMobile ? 4 : 8,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Count Value with optional icon
          Row(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              if (icon != null) ...[
                Icon(
                  icon,
                  size: isMobile ? 14 : (isTablet ? 15 : 16),
                  color: iconColor ?? color,
                ),
                SizedBox(width: isMobile ? 4 : 6),
              ],
              Text(
                count.toString(),
                style: AppTheme.bodyMedium.copyWith(
                  color: AppTheme.textSecondary,
                  fontSize: isMobile ? 12 : (isTablet ? 12 : 13),
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          SizedBox(height: isMobile ? 4 : 8),
          // Amount Value
          Text(
            _formatAmountCompact(amount, isMobile),
            style: AppTheme.bodyMedium.copyWith(
              color: color,
              fontSize: isMobile ? 11 : (isTablet ? 13 : 14),
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.left,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  Widget _buildGrandTotalRow(
    int totalUnapprovedCount,
    double totalUnapprovedAmount,
    int totalFlaggedCount,
    double totalFlaggedAmount,
    int grandTotalCount,
    double grandTotalAmount,
    bool isMobile,
    bool isTablet,
  ) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor.withOpacity(0.5),
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(12),
          bottomRight: Radius.circular(12),
        ),
      ),
      child: Stack(
        children: [
          // Base row structure matching table rows exactly (for column alignment)
          Row(
            children: [
              // Icon Column (matching table rows structure exactly)
              Container(
                width: isMobile ? 40 : 48,
                height: isMobile ? 40 : 48,
                decoration: BoxDecoration(
                  color: AppTheme.borderColor.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  Icons.calculate,
                  color: AppTheme.primaryColor,
                  size: isMobile ? 22 : 24,
                ),
              ),
              SizedBox(width: isMobile ? 8 : 16),
              // Unapproved/Unaccounted Column (aligned with table columns)
              Expanded(
                child: _buildStatusColumn(
                  totalUnapprovedCount,
                  totalUnapprovedAmount,
                  AppTheme.primaryColor,
                  isMobile,
                  isTablet,
                  icon: Icons.undo_outlined,
                  iconColor: AppTheme.primaryColor,
                ),
              ),
              SizedBox(width: isMobile ? 6 : 12),
              // Flagged Column (aligned with table columns)
              Expanded(
                child: _buildStatusColumn(
                  totalFlaggedCount,
                  totalFlaggedAmount,
                  AppTheme.primaryColor,
                  isMobile,
                  isTablet,
                  icon: Icons.flag_outlined,
                  iconColor: AppTheme.primaryColor,
                ),
              ),
              SizedBox(width: isMobile ? 6 : 12),
              // Total Column (aligned with table columns) - Different color to stand out
              Expanded(
                child: _buildStatusColumn(
                  grandTotalCount,
                  grandTotalAmount,
                  AppTheme.secondaryColor,
                  isMobile,
                  isTablet,
                  icon: Icons.calculate_outlined,
                  iconColor: AppTheme.secondaryColor,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInlineStatusItem(
    int count,
    double amount,
    Color color,
    bool isMobile,
    bool isTablet,
  ) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          '$count',
          style: AppTheme.bodyMedium.copyWith(
            color: AppTheme.textSecondary,
            fontSize: isMobile ? 12 : 13,
            fontWeight: FontWeight.w500,
          ),
        ),
        SizedBox(width: 4),
        Text(
          '‚Ä¢',
          style: AppTheme.bodyMedium.copyWith(
            color: AppTheme.textSecondary,
            fontSize: isMobile ? 12 : 13,
          ),
        ),
        SizedBox(width: 4),
        Text(
          _formatAmountCompact(amount, isMobile),
          style: AppTheme.bodyMedium.copyWith(
            color: color,
            fontSize: isMobile ? 12 : 13,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Widget _buildStatusBadge(String label, int count, Color color, bool isMobile) {
    return Container(
      padding: EdgeInsets.symmetric(vertical: 12, horizontal: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        children: [
          Text(
            label,
            style: AppTheme.bodySmall.copyWith(
              color: color,
              fontSize: isMobile ? 11 : 12,
            ),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: 4),
          Text(
            count.toString(),
            style: AppTheme.headingSmall.copyWith(
              fontSize: isMobile ? 18 : 20,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  // Build flagged financial flow section (using real data from timeline)
  Widget _buildExampleCardsSection(bool isMobile, bool isTablet) {
    // Use real flagged items from timeline instead of dummy data
    print('üö© [FLAGGED ITEMS] Building UI - Total timeline items: ${_timelineItems.length}');
    final flaggedItems = _getFlaggedFinancialFlowItems(_timelineItems);
    print('üö© [FLAGGED ITEMS] Building UI - Filtered flagged items: ${flaggedItems.length}');
    final sortedItems = _sortTimelineItems(flaggedItems);
    print('üö© [FLAGGED ITEMS] Building UI - Sorted items: ${sortedItems.length}');
    
    // Get flagged counts from flagged financial flow items (same as Status Count Table)
    final flaggedData = _getFlaggedFinancialFlowCountsAndAmounts();
    final expensesFlagged = flaggedData['expenses'] ?? {'count': 0, 'amount': 0.0};
    final transactionsFlagged = flaggedData['transactions'] ?? {'count': 0, 'amount': 0.0};
    final collectionsFlagged = flaggedData['collections'] ?? {'count': 0, 'amount': 0.0};
    
    final totalFlaggedCount = (expensesFlagged['count'] as int? ?? 0) + 
                              (transactionsFlagged['count'] as int? ?? 0) + 
                              (collectionsFlagged['count'] as int? ?? 0);
    
    final totalFlaggedAmount = (expensesFlagged['amount'] as double? ?? 0.0) + 
                               (transactionsFlagged['amount'] as double? ?? 0.0) + 
                               (collectionsFlagged['amount'] as double? ?? 0.0);
    
    return Container(
      padding: EdgeInsets.all(isMobile ? 16 : 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.flag, color: AppTheme.warningColor, size: isMobile ? 20 : 24),
              SizedBox(width: 12),
              Text(
                'Flagged Financial Flow',
                style: AppTheme.headingSmall.copyWith(
                  fontSize: isMobile ? 18 : 20,
                  fontWeight: FontWeight.w600,
                ),
              ),
              // Add count badge if more than 4 items (2 rows)
              if (sortedItems.length > 4 && !isMobile) ...[
                SizedBox(width: 12),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: AppTheme.warningColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${sortedItems.length} items',
                    style: AppTheme.bodySmall.copyWith(
                      fontSize: isMobile ? 12 : 13,
                      fontWeight: FontWeight.w600,
                      color: AppTheme.warningColor,
                    ),
                  ),
                ),
              ],
            ],
          ),
          SizedBox(height: 12),
          Divider(height: 1),
          SizedBox(height: 12),
          // Calculate max height for desktop/tablet (2 rows = 4 cards)
          LayoutBuilder(
            builder: (context, constraints) {
              // Validate constraints to prevent assertion errors
              final rawMaxWidth = constraints.maxWidth;
              final isValidWidth = rawMaxWidth.isFinite && rawMaxWidth > 0;
              
              // For mobile, use ListView with flexible height (no fixed aspect ratio)
              if (isMobile) {
                if (sortedItems.isEmpty) {
                  return Center(
                    child: Padding(
                      padding: EdgeInsets.all(32),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.check_circle_outline,
                            size: 64,
                            color: AppTheme.secondaryColor.withOpacity(0.5),
                          ),
                          SizedBox(height: 16),
                          Text(
                            'No flagged items to display',
                            style: AppTheme.bodyMedium.copyWith(
                              color: AppTheme.textMuted,
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                }
                return ListView.builder(
                  key: const PageStorageKey('flagged_items_list'),
                  shrinkWrap: true,
                  physics: NeverScrollableScrollPhysics(),
                  itemCount: sortedItems.length,
                  itemBuilder: (context, index) {
                    final itemData = sortedItems[index] as Map<String, dynamic>;
                    final itemId = itemData['id']?.toString() ?? itemData['_id']?.toString() ?? 'flagged_$index';
                    return Padding(
                      key: ValueKey(itemId),
                      padding: EdgeInsets.only(
                        bottom: index < sortedItems.length - 1 ? 16 : 0,
                      ),
                      child: _buildFlaggedFinancialFlowItem(itemData, isMobile, isTablet),
                    );
                  },
                );
              }
              
              // For desktop/tablet, calculate height based on actual available width
              // Ensure constraints are valid to prevent assertion errors
              if (!isValidWidth) {
                // Fallback: use default dimensions if constraints are invalid
                return Container(
                  height: 400.0,
                  decoration: BoxDecoration(),
                  clipBehavior: Clip.hardEdge,
                  child: Scrollbar(
                    child: GridView.builder(
                      shrinkWrap: false,
                      physics: const AlwaysScrollableScrollPhysics(),
                      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                        crossAxisCount: 2,
                        crossAxisSpacing: 16,
                        mainAxisSpacing: 16,
                        childAspectRatio: 2.8,  // Increased to give more height to cards
                      ),
                      itemCount: sortedItems.length,
                      itemBuilder: (context, index) {
                        final itemData = sortedItems[index] as Map<String, dynamic>;
                        return _buildFlaggedFinancialFlowItem(itemData, isMobile, isTablet);
                      },
                    ),
                  ),
                );
              }
              
              // Calculate dimensions with validated constraints
              final availableWidth = (rawMaxWidth - (20 * 2)).clamp(200.0, 2000.0); // Subtract container padding and clamp
              final crossAxisSpacing = 16.0;
              final cardWidth = ((availableWidth - crossAxisSpacing) / 2).clamp(100.0, 1000.0); // 2 columns, clamp to valid range
              final cardHeight = (cardWidth / 2.5).clamp(50.0, 500.0); // aspectRatio = 2.5, clamp to valid range
              final mainAxisSpacing = 16.0;
              
              // 3 rows = 3 cards + 2 spacing between rows (slightly increased height)
              final threeRowsHeight = ((cardHeight * 3) + (mainAxisSpacing * 2)).clamp(200.0, 2000.0);
              final maxHeight = threeRowsHeight;
              
              // Apply height constraint and enable scrolling
              // Use measured Status Table height if available, otherwise use calculated height
              // Add slight increase for better scroll box size
              final statusHeight = (_statusTableHeight != null && 
                      _statusTableHeight!.isFinite && 
                      _statusTableHeight! > 0) 
                      ? _statusTableHeight! 
                      : null;
              final baseHeight = statusHeight ?? maxHeight;
              final targetHeight = (baseHeight.isFinite && baseHeight > 0 
                      ? baseHeight 
                      : maxHeight) + 40.0; // Add 40px for better scroll area
              
              // Ensure targetHeight is valid
              final safeHeight = targetHeight.isFinite && targetHeight > 0 
                  ? targetHeight.clamp(200.0, 2000.0) 
                  : 400.0; // Fallback height
              
              if (sortedItems.isEmpty) {
                return Container(
                  height: safeHeight,
                  child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.check_circle_outline,
                          size: 64,
                          color: AppTheme.secondaryColor.withOpacity(0.5),
                        ),
                        SizedBox(height: 16),
                        Text(
                          'No flagged items to display',
                          style: AppTheme.bodyMedium.copyWith(
                            color: AppTheme.textMuted,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              }
              
              return Container(
                height: safeHeight,
                decoration: BoxDecoration(),
                clipBehavior: Clip.hardEdge,
                child: Scrollbar(
                  child: GridView.builder(
                    shrinkWrap: false,
                    physics: ClampingScrollPhysics(),
                    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 2,
                      crossAxisSpacing: 16,
                      mainAxisSpacing: 16,
                      childAspectRatio: 2.5,
                    ),
                    itemCount: sortedItems.length,
                    itemBuilder: (context, index) {
                      final itemData = sortedItems[index] as Map<String, dynamic>;
                      return _buildFlaggedFinancialFlowItem(itemData, isMobile, isTablet);
                    },
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTimelineSection(bool isMobile, bool isTablet) {
    // Filter to only flagged financial flow items
    final flaggedItems = _getFlaggedFinancialFlowItems(_timelineItems);
    // Sort flagged items by priority and timestamp
    final sortedItems = _sortTimelineItems(flaggedItems);
    
    return Container(
      padding: EdgeInsets.all(isMobile ? 16 : 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.flag, color: AppTheme.warningColor, size: isMobile ? 20 : 24),
              SizedBox(width: 12),
              Text(
                'Flagged Financial Flow Items',
                style: AppTheme.headingSmall.copyWith(
                  fontSize: isMobile ? 18 : 20,
                  fontWeight: FontWeight.w600,
                ),
              ),
              if (sortedItems.isNotEmpty) ...[
                SizedBox(width: 12),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: AppTheme.warningColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${sortedItems.length}',
                    style: AppTheme.bodySmall.copyWith(
                      fontSize: isMobile ? 12 : 13,
                      fontWeight: FontWeight.w600,
                      color: AppTheme.warningColor,
                    ),
                  ),
                ),
              ],
            ],
          ),
          SizedBox(height: 12),
          Divider(height: 1),
          SizedBox(height: 12),
          _isLoadingTimeline
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(32.0),
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(AppTheme.primaryColor),
                    ),
                  ),
                )
              : sortedItems.isEmpty
                  ? Center(
                      child: Padding(
                        padding: EdgeInsets.all(32),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.check_circle_outline,
                              size: 64,
                              color: AppTheme.secondaryColor.withOpacity(0.5),
                            ),
                            SizedBox(height: 16),
                            Text(
                              'No flagged items to display',
                              style: AppTheme.bodyMedium.copyWith(
                                color: AppTheme.textMuted,
                                fontSize: isMobile ? 14 : 16,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                            SizedBox(height: 8),
                            Text(
                              'All financial flow transactions are clear',
                              style: AppTheme.bodySmall.copyWith(
                                color: AppTheme.textMuted.withOpacity(0.7),
                                fontSize: isMobile ? 12 : 13,
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  : isMobile
                      ? ListView.builder(
                          key: const PageStorageKey('flagged_items_mobile_list'),
                          shrinkWrap: true,
                          physics: NeverScrollableScrollPhysics(),
                          itemCount: sortedItems.length,
                          itemBuilder: (context, index) {
                            final itemData = sortedItems[index] as Map<String, dynamic>;
                            final itemId = itemData['id']?.toString() ?? itemData['_id']?.toString() ?? 'flagged_mobile_$index';
                            return Padding(
                              key: ValueKey(itemId),
                              padding: EdgeInsets.only(
                                bottom: index < sortedItems.length - 1 ? 16 : 0,
                              ),
                              child: _buildFlaggedFinancialFlowItem(itemData, isMobile, isTablet),
                            );
                          },
                        )
                      : GridView.builder(
                          shrinkWrap: true,
                          physics: NeverScrollableScrollPhysics(),
                          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: isTablet ? 3 : 4,
                            crossAxisSpacing: 16,
                            mainAxisSpacing: 16,
                            childAspectRatio: 2.8,  // Increased to give more height to cards
                          ),
                          itemCount: sortedItems.length,
                          itemBuilder: (context, index) {
                            final itemData = sortedItems[index] as Map<String, dynamic>;
                            return _buildFlaggedFinancialFlowItem(itemData, isMobile, isTablet);
                          },
                        ),
        ],
      ),
    );
  }

  /// Convert flagged items from API format to timeline format
  List<Map<String, dynamic>> _convertFlaggedItemsToTimelineFormat(List<dynamic> flaggedItems) {
    print('üö© [FLAGGED ITEMS] Converting ${flaggedItems.length} items to timeline format');
    return flaggedItems.map((item) {
      final itemMap = item as Map<String, dynamic>;
      final itemType = itemMap['type']?.toString() ?? '';
      
      // Determine category based on type
      String category = 'financial';
      if (itemType == 'Expenses') {
        category = 'expenses';
      } else if (itemType == 'Collections') {
        category = 'collections';
      } else if (itemType == 'Transactions') {
        category = 'transactions'; // Changed from 'cash_flow' to 'transactions' to match pattern
      }
      
      // Build message from flagReason
      final flagReason = itemMap['flagReason']?.toString() ?? 'Flagged item requires review';
      final flaggedBy = itemMap['flaggedBy'] as Map<String, dynamic>?;
      String message = flagReason;
      if (flaggedBy != null) {
        final flaggedByName = flaggedBy['name']?.toString() ?? 'Unknown';
        final flaggedByRole = flaggedBy['role']?.toString() ?? '';
        message = '$flagReason (Flagged by: $flaggedByName${flaggedByRole.isNotEmpty ? ' - $flaggedByRole' : ''})';
      }
      
      // Create converted item - spread itemMap first, then override with our fields
      // This ensures our category and type values are not overwritten
      final convertedItem = {
        // Include all original fields first
        ...itemMap,
        // Then override with our converted fields (these will take precedence)
        'id': itemMap['id']?.toString() ?? '',
        'type': 'flagged', // Override to ensure it's 'flagged'
        'category': category, // Override to ensure correct category
        'message': message,
        'timestamp': itemMap['createdAt'] ?? itemMap['date'] ?? DateTime.now(),
        'status': 'Flagged',
        'flagReason': flagReason,
        'flaggedBy': itemMap['flaggedBy'],
        'flaggedAt': itemMap['flaggedAt'],
        'response': itemMap['response'],
        'responseDate': itemMap['responseDate'],
        'financialData': {
          'expenseId': itemType == 'Expenses' ? itemMap['id'] : null,
          'collectionId': itemType == 'Collections' ? itemMap['id'] : null,
          'transactionId': itemType == 'Transactions' ? itemMap['id'] : null,
          'amount': itemMap['amount'],
          'mode': itemMap['mode'],
          'paymentMode': itemMap['paymentMode'] ?? itemMap['mode'],
          'paymentModeId': itemMap['paymentModeId'],
          'expenseType': itemType == 'Expenses' ? (itemMap['category'] ?? itemMap['expenseType']) : null,
          'category': itemMap['category'],
          'description': itemMap['description'],
          'purpose': itemMap['purpose'],
          'customerName': itemMap['customerName'],
          'notes': itemMap['notes'],
          'proofUrl': itemMap['proofUrl'],
          'assignedReceiver': itemMap['assignedReceiver'],
          'receiver': itemMap['receiver'],
        },
      };
      
      print('üö© [FLAGGED ITEMS] Converted item - type: "${convertedItem['type']}", category: "${convertedItem['category']}"');
      
      return convertedItem;
    }).toList();
  }

  List<dynamic> _getFlaggedFinancialFlowItems(List<dynamic> items) {
    print('üö© [FLAGGED ITEMS] Filtering ${items.length} items...');
    final filtered = items.where((item) {
      final itemData = item as Map<String, dynamic>;
      final type = itemData['type']?.toString() ?? '';
      final category = itemData['category']?.toString().toLowerCase() ?? '';
      
      print('üö© [FLAGGED ITEMS] Item - type: "$type", category: "$category"');
      
      final isFlagged = itemData['type'] == 'flagged';
      final hasValidCategory = category == 'transactions' || 
             category == 'transaction' ||
             category == 'cash_flow' || // Keep for backward compatibility
             category == 'financial' ||
             category == 'expenses' ||
             category == 'collections' ||
             category == 'expense' ||
             category == 'collection';
      
      final matches = isFlagged && hasValidCategory;
      print('üö© [FLAGGED ITEMS] Item matches: $matches (isFlagged: $isFlagged, hasValidCategory: $hasValidCategory)');
      
      return matches;
    }).toList();
    print('üö© [FLAGGED ITEMS] Filtered result: ${filtered.length} items');
    return filtered;
  }

  /// Update flagged item status in timeline items
  void _updateFlaggedItemStatus(String itemId, String newStatus, {String? category}) {
    setState(() {
      for (int i = 0; i < _timelineItems.length; i++) {
        final item = _timelineItems[i] as Map<String, dynamic>;
        if (item['type'] == 'flagged') {
          final financialData = item['financialData'] as Map<String, dynamic>? ?? {};
          final itemCategory = category ?? item['category']?.toString().toLowerCase() ?? '';
          
          // Check if this is the item we're looking for
          bool isMatch = false;
          if (itemCategory == 'expenses' || itemCategory == 'expense') {
            isMatch = financialData['expenseId']?.toString() == itemId;
          } else if (itemCategory == 'collections' || itemCategory == 'collection') {
            isMatch = financialData['collectionId']?.toString() == itemId;
          } else {
            isMatch = financialData['transactionId']?.toString() == itemId;
          }
          
          if (isMatch) {
            // Update status
            _timelineItems[i] = {
              ...item,
              'status': newStatus,
            };
            print('üö© [FLAGGED ITEMS] Updated item $itemId status to $newStatus');
            break;
          }
        }
      }
    });
  }

  /// Remove flagged item from timeline items (when resubmitted, it should disappear)
  void _removeFlaggedItem(String itemId, {String? category}) {
    print('üö© [FLAGGED ITEMS] Attempting to remove item: $itemId (category: $category)');
    print('üö© [FLAGGED ITEMS] Current timeline items count: ${_timelineItems.length}');
    
    final beforeCount = _timelineItems.length;
    
    // Debug: Print all current flagged items and their IDs
    for (int i = 0; i < _timelineItems.length; i++) {
      final item = _timelineItems[i] as Map<String, dynamic>;
      if (item['type'] == 'flagged') {
        final financialData = item['financialData'] as Map<String, dynamic>? ?? {};
        final itemCategory = item['category']?.toString().toLowerCase() ?? '';
        final expenseId = financialData['expenseId']?.toString() ?? '';
        final collectionId = financialData['collectionId']?.toString() ?? '';
        final transactionId = financialData['transactionId']?.toString() ?? '';
        final currentItemId = expenseId.isNotEmpty ? expenseId : (collectionId.isNotEmpty ? collectionId : transactionId);
        print('üö© [FLAGGED ITEMS] Item $i: category=$itemCategory, expenseId=$expenseId, collectionId=$collectionId, transactionId=$transactionId, currentItemId=$currentItemId');
      }
    }
    
    setState(() {
      _timelineItems = _timelineItems.where((item) {
        final itemData = item as Map<String, dynamic>;
        if (itemData['type'] == 'flagged') {
          final financialData = itemData['financialData'] as Map<String, dynamic>? ?? {};
          final itemCategory = category ?? itemData['category']?.toString().toLowerCase() ?? '';
          
          // Check if this is the item we're looking for
          bool isMatch = false;
          if (itemCategory == 'expenses' || itemCategory == 'expense') {
            final expenseId = financialData['expenseId']?.toString() ?? '';
            isMatch = expenseId == itemId;
            if (isMatch) {
              print('üö© [FLAGGED ITEMS] ‚úÖ Found matching expense: $expenseId == $itemId');
            } else if (expenseId.isNotEmpty) {
              print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Expense ID mismatch: $expenseId != $itemId');
            }
          } else if (itemCategory == 'collections' || itemCategory == 'collection') {
            final collectionId = financialData['collectionId']?.toString() ?? '';
            isMatch = collectionId == itemId;
            if (isMatch) {
              print('üö© [FLAGGED ITEMS] ‚úÖ Found matching collection: $collectionId == $itemId');
            } else if (collectionId.isNotEmpty) {
              print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Collection ID mismatch: $collectionId != $itemId');
            }
          } else {
            final transactionId = financialData['transactionId']?.toString() ?? '';
            isMatch = transactionId == itemId;
            if (isMatch) {
              print('üö© [FLAGGED ITEMS] ‚úÖ Found matching transaction: $transactionId == $itemId');
            } else if (transactionId.isNotEmpty) {
              print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è Transaction ID mismatch: $transactionId != $itemId');
            }
          }
          
          // Remove this item if it matches
          return !isMatch;
        }
        return true; // Keep non-flagged items
      }).toList();
      final afterCount = _timelineItems.length;
      final removedCount = beforeCount - afterCount;
      print('üö© [FLAGGED ITEMS] ‚úÖ Removal result - Before: $beforeCount, After: $afterCount, Removed: $removedCount');
      if (removedCount == 0) {
        print('üö© [FLAGGED ITEMS] ‚ö†Ô∏è WARNING: No items were removed! Item ID might not match.');
      }
    });
  }

  Map<String, Map<String, dynamic>> _getFlaggedFinancialFlowCountsAndAmounts() {
    final flaggedItems = _getFlaggedFinancialFlowItems(_timelineItems);
    
    int expensesCount = 0;
    double expensesAmount = 0.0;
    int transactionsCount = 0;
    double transactionsAmount = 0.0;
    int collectionsCount = 0;
    double collectionsAmount = 0.0;
    
    for (var item in flaggedItems) {
      final itemData = item as Map<String, dynamic>;
      final category = itemData['category']?.toString().toLowerCase() ?? '';
      final financialData = itemData['financialData'] as Map<String, dynamic>?;
      final amount = financialData != null 
          ? ((financialData['amount'] as num?)?.toDouble() ?? 0.0)
          : 0.0;
      
      if (category == 'expenses' || category == 'expense') {
        expensesCount++;
        expensesAmount += amount;
      } else if (category == 'collections' || category == 'collection') {
        collectionsCount++;
        collectionsAmount += amount;
      } else if (category == 'transactions' || category == 'transaction' || category == 'cash_flow' || category == 'financial') {
        transactionsCount++;
        transactionsAmount += amount;
      }
    }
    
    return {
      'expenses': {'count': expensesCount, 'amount': expensesAmount},
      'transactions': {'count': transactionsCount, 'amount': transactionsAmount},
      'collections': {'count': collectionsCount, 'amount': collectionsAmount},
    };
  }

  List<dynamic> _sortTimelineItems(List<dynamic> items) {
    final sorted = List<Map<String, dynamic>>.from(items.map((item) => item as Map<String, dynamic>));
    
    sorted.sort((a, b) {
      // Check if items are flagged financial flow (transactions)
      final aIsFlaggedFinancial = a['type'] == 'flagged' && 
                                  (a['category'] == 'transactions' || a['category'] == 'transaction' || a['category'] == 'cash_flow' || a['category'] == 'financial');
      final bIsFlaggedFinancial = b['type'] == 'flagged' && 
                                  (b['category'] == 'transactions' || b['category'] == 'transaction' || b['category'] == 'cash_flow' || b['category'] == 'financial');
      
      // Flagged financial flow items first
      if (aIsFlaggedFinancial && !bIsFlaggedFinancial) return -1;
      if (!aIsFlaggedFinancial && bIsFlaggedFinancial) return 1;
      
      // Within flagged financial flow, sort by priority
      if (aIsFlaggedFinancial && bIsFlaggedFinancial) {
        final priorityOrder = {'high': 0, 'medium': 1, 'low': 2};
        final aPriority = priorityOrder[a['priority'] ?? 'low'] ?? 2;
        final bPriority = priorityOrder[b['priority'] ?? 'low'] ?? 2;
        if (aPriority != bPriority) return aPriority.compareTo(bPriority);
      }
      
      // Otherwise, sort by timestamp (newest first)
      final aTime = a['timestamp'] is DateTime 
          ? a['timestamp'] as DateTime 
          : DateTime.parse(a['timestamp'].toString());
      final bTime = b['timestamp'] is DateTime 
          ? b['timestamp'] as DateTime 
          : DateTime.parse(b['timestamp'].toString());
      return bTime.compareTo(aTime);
    });
    
    return sorted;
  }

  TimelineItem _convertToTimelineItem(Map<String, dynamic> data) {
    TimelineItemType type;
    switch (data['type'] as String?) {
      case 'warning':
        type = TimelineItemType.warning;
        break;
      case 'flagged':
        type = TimelineItemType.flagged;
        break;
      case 'success':
        type = TimelineItemType.success;
        break;
      case 'error':
        type = TimelineItemType.error;
        break;
      case 'bot':
        type = TimelineItemType.bot;
        break;
      default:
        type = TimelineItemType.info;
    }

    TimelineAttachment? attachment;
    if (data['attachment'] != null) {
      final attData = data['attachment'] as Map<String, dynamic>;
      attachment = TimelineAttachment(
        filename: attData['filename'] as String? ?? '',
        fileSize: attData['fileSize'] as String?,
        fileType: attData['fileType'] as String?,
        onDownload: () {
          // Handle download
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Downloading ${attData['filename']}...'),
              duration: Duration(seconds: 2),
            ),
          );
        },
      );
    }

    return TimelineItem(
      id: data['id'] as String? ?? '',
      type: type,
      message: data['message'] as String? ?? '',
      timestamp: data['timestamp'] is DateTime
          ? data['timestamp'] as DateTime
          : DateTime.parse(data['timestamp'].toString()),
      title: data['title'] as String?,
      statusText: data['statusText'] as String?,
      checklistItems: data['checklistItems'] != null
          ? List<String>.from(data['checklistItems'] as List)
          : null,
      substatusText: data['substatusText'] as String?,
      substatusColor: data['substatusText'] != null ? AppTheme.warningColor : null,
      attachment: attachment,
    );
  }

  Map<String, dynamic> _getCategoryInfo(Map<String, dynamic> data) {
    final category = data['category']?.toString().toLowerCase() ?? '';
    
    // Determine category based on category field
    if (category == 'expenses' || category == 'expense') {
      return {
        'name': 'Expenses',
        'icon': Icons.receipt,
        'color': Color(0xFF9C27B0), // Purple color
      };
    } else if (category == 'collections' || category == 'collection') {
      return {
        'name': 'Collections',
        'icon': Icons.account_balance,
        'color': AppTheme.secondaryColor,
      };
    } else {
      // Default to Transactions for transactions/cash_flow/financial
      return {
        'name': 'Transactions',
        'icon': Icons.swap_horiz,
        'color': AppTheme.primaryColor,
      };
    }
  }

  String _formatTransactionId(String originalId, String category, DateTime? timestamp) {
    // Return original if invalid
    if (originalId == 'N/A' || originalId.isEmpty) {
      return originalId;
    }
    
    // Determine prefix based on category
    String prefix = 'T'; // Default for transactions
    if (category == 'expenses' || category == 'expense') {
      prefix = 'E';
    } else if (category == 'collections' || category == 'collection') {
      prefix = 'C';
    } else if (originalId.toUpperCase().startsWith('EXP')) {
      prefix = 'E';
    } else if (originalId.toUpperCase().startsWith('COL')) {
      prefix = 'C';
    } else if (originalId.toUpperCase().startsWith('TXN')) {
      prefix = 'T';
    }
    
    // Parse the original ID format (e.g., "TXN-2024-001" or "EXP-2024-050")
    final parts = originalId.split('-');
    if (parts.length >= 3) {
      final yearStr = parts[1]; // e.g., "2024"
      final numberStr = parts[2]; // e.g., "001"
      
      // Extract 2-digit year
      final year = yearStr.length >= 2 ? yearStr.substring(yearStr.length - 2) : yearStr;
      
      // Get month from timestamp or use current month
      final date = timestamp ?? DateTime.now();
      final month = date.month.toString().padLeft(2, '0');
      
      // Pad number to 6 digits
      final paddedNumber = numberStr.padLeft(6, '0');
      
      return '$prefix/$year/$month/$paddedNumber';
    }
    
    // If format doesn't match, try to extract number from end
    final numberMatch = RegExp(r'(\d+)$').firstMatch(originalId);
    if (numberMatch != null) {
      final date = timestamp ?? DateTime.now();
      final year = date.year.toString().substring(2);
      final month = date.month.toString().padLeft(2, '0');
      final paddedNumber = numberMatch.group(1)!.padLeft(6, '0');
      return '$prefix/$year/$month/$paddedNumber';
    }
    
    // Fallback: return original if can't parse
    return originalId;
  }

  // Check if text exceeds specified number of lines
  bool _doesTextExceedLines(String text, double maxWidth, int maxLines, bool isMobile) {
    // Validate maxWidth to prevent assertion errors
    if (!maxWidth.isFinite || maxWidth <= 0) {
      return false; // If width is invalid, assume text doesn't exceed
    }
    
    try {
      final textPainter = TextPainter(
        text: TextSpan(
          text: text,
          style: AppTheme.bodyMedium.copyWith(
            fontSize: isMobile ? 12 : 13,
          ),
        ),
        maxLines: maxLines,
        textDirection: ui.TextDirection.ltr,
      );
      textPainter.layout(maxWidth: maxWidth);
      return textPainter.didExceedMaxLines;
    } catch (e) {
      // If layout fails, assume text doesn't exceed to prevent crashes
      return false;
    }
  }

  // Build expandable reason text widget
  Widget _buildExpandableReasonText(
    String reason,
    String cardId,
    bool isMobile,
    bool isTablet,
    double availableWidth,
  ) {
    final isExpanded = _expandedReasonCards.contains(cardId);
    
    // Check if text exceeds 2 lines using TextPainter
    // Only check when collapsed to avoid unnecessary calculations
    bool actuallyExceeds = false;
    if (!isExpanded) {
      // Account for padding and margins (subtract ~20px for safety)
      // Ensure textWidth is valid (finite and positive)
      final textWidth = (availableWidth - 20).clamp(50.0, double.infinity);
      if (textWidth.isFinite && textWidth > 0) {
        actuallyExceeds = _doesTextExceedLines(reason, textWidth, 2, isMobile);
      }
    } else {
      // If already expanded, we know it exceeded, so show "Show less"
      actuallyExceeds = true;
    }
    
    // Ensure availableWidth is valid before using it
    final safeWidth = availableWidth.isFinite && availableWidth > 0 
        ? availableWidth 
        : 300.0; // Fallback width
    
    // Max height for scrollable content when expanded
    final maxScrollHeight = isMobile ? 100.0 : (isTablet ? 120.0 : 150.0);
    
    // Calculate minimum height for 2 lines of text
    // Font size * line height (1.2) * 2 lines + vertical padding (4px total)
    final fontSize = isMobile ? 12.0 : 13.0;
    final lineHeight = 1.2;
    final verticalPadding = 4.0; // 2px top + 2px bottom
    final minHeightForTwoLines = (fontSize * lineHeight * 2) + verticalPadding;
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: safeWidth,
          child: AnimatedSize(
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeInOut,
            child: Container(
              width: safeWidth,
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                border: Border.all(
                  color: Colors.orange.withOpacity(0.4),
                  width: 1.5,
                ),
                borderRadius: BorderRadius.circular(4),
              ),
              child: isExpanded
                  ? ConstrainedBox(
                      constraints: BoxConstraints(
                        maxHeight: maxScrollHeight,
                        minHeight: 0,
                      ),
                      child: Scrollbar(
                        thumbVisibility: true,
                        thickness: 4.0,
                        radius: Radius.circular(2),
                        child: SingleChildScrollView(
                          scrollDirection: Axis.vertical,
                          child: Text(
                            reason,
                            style: AppTheme.bodyMedium.copyWith(
                              fontSize: isMobile ? 12 : 13,
                              color: AppTheme.textSecondary,
                            ),
                          ),
                        ),
                      ),
                    )
                  : ConstrainedBox(
                      constraints: BoxConstraints(
                        minHeight: minHeightForTwoLines,
                      ),
                      child: Text(
                        reason,
                        style: AppTheme.bodyMedium.copyWith(
                          fontSize: isMobile ? 12 : 13,
                          color: AppTheme.textSecondary,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
            ),
          ),
        ),
        if (actuallyExceeds)
          GestureDetector(
            onTap: () {
              setState(() {
                if (isExpanded) {
                  _expandedReasonCards.remove(cardId);
                } else {
                  _expandedReasonCards.add(cardId);
                }
              });
            },
            child: Padding(
              padding: const EdgeInsets.only(top: 2),
              child: Text(
                isExpanded ? 'Show less' : 'Show more',
                style: AppTheme.bodySmall.copyWith(
                  fontSize: isMobile ? 11 : 12,
                  color: AppTheme.primaryColor,
                  decoration: TextDecoration.underline,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildFlaggedFinancialFlowItem(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    final reason = data['message'] ?? 'Flagged item requires review';
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final category = data['category']?.toString().toLowerCase() ?? '';
    
    // Get card ID for tracking expansion state
    final cardId = data['id']?.toString() ?? 
        (data['financialData']?['transactionId']?.toString() ?? 
         data['financialData']?['expenseId']?.toString() ?? 
         data['financialData']?['collectionId']?.toString() ?? 
         'card_${DateTime.now().millisecondsSinceEpoch}');
    
    // Get ID based on category
    final itemId = category == 'expenses' || category == 'expense'
        ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
        : (category == 'collections' || category == 'collection'
            ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
            : (financialData['transactionId'] ?? 'N/A'));
    
    // Get timestamp for formatting
    DateTime? timestamp;
    if (data['timestamp'] != null) {
      if (data['timestamp'] is DateTime) {
        timestamp = data['timestamp'] as DateTime;
      } else {
        try {
          timestamp = DateTime.parse(data['timestamp'].toString());
        } catch (e) {
          timestamp = null;
        }
      }
    }
    
    // Format the transaction ID
    final formattedId = _formatTransactionId(itemId.toString(), category, timestamp);
    
    final categoryInfo = _getCategoryInfo(data);

    return AnimatedContainer(
      duration: const Duration(milliseconds: 260),
      curve: Curves.easeOut,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: AppTheme.textPrimary.withOpacity(0.04),
            blurRadius: 24,
            offset: const Offset(0, 12),
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(20),
          child: Container(
          decoration: BoxDecoration(
            color: AppTheme.surfaceColor,
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: AppTheme.borderColor.withOpacity(0.35),
              width: 0.9,
            ),
          ),
          child: Stack(
            children: [
              // Colored left border bar
              Positioned(
                left: 0,
                top: 0,
                bottom: 0,
                child: Container(
                  width: isMobile ? 4 : 5,
                  decoration: BoxDecoration(
                    color: categoryInfo['color'] as Color,
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(20),
                      bottomLeft: Radius.circular(20),
                    ),
                  ),
                ),
              ),
              // Content with scrolling
              Padding(
                padding: EdgeInsets.fromLTRB(
                  isMobile ? 14 : 14,
                  isMobile ? 12 : 8,
                  isMobile ? 14 : 14,
                  isMobile ? 12 : 8,
                ),
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    // Calculate available width for text (accounting for padding and border)
                    // Ensure constraints are valid to prevent assertion errors
                    final rawWidth = constraints.maxWidth;
                    final availableWidth = rawWidth.isFinite && rawWidth > 0 
                        ? rawWidth 
                        : (isMobile ? 300.0 : (isTablet ? 400.0 : 500.0));
                    final isDesktop = !isMobile && !isTablet;
                    
                    // Calculate available height (accounting for padding)
                    final rawHeight = constraints.maxHeight;
                    final availableHeight = rawHeight.isFinite && rawHeight > 0 
                        ? rawHeight 
                        : null;
                    
                    final content = ConstrainedBox(
                      constraints: BoxConstraints(
                        maxHeight: availableHeight ?? double.infinity,
                      ),
                      child: SingleChildScrollView(
                        physics: const AlwaysScrollableScrollPhysics(),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          mainAxisAlignment: MainAxisAlignment.start,
                          children: [
                        // Flag icon + Category name on same line
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.flag,
                              color: AppTheme.warningColor,
                              size: isMobile ? 14 : 16,
                            ),
                            SizedBox(width: 6),
                            Flexible(
                              child: Text(
                                categoryInfo['name'] as String,
                                style: AppTheme.bodyMedium.copyWith(
                                  fontSize: isMobile ? 13 : 14,
                                  fontWeight: FontWeight.w500,
                                  color: categoryInfo['color'] as Color,
                                ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                        
                        // Add spacing between Flag+Category and Reason
                        SizedBox(height: isMobile ? 8 : 4),
                        
                        // Reason (expandable text)
                        _buildExpandableReasonText(
                          reason,
                          cardId,
                          isMobile,
                          isTablet,
                          availableWidth,
                        ),
                        
                        // Flagged By Info
                        if (data['flaggedBy'] != null) ...[
                          SizedBox(height: isMobile ? 6 : 3),
                          Row(
                            children: [
                              Icon(
                                Icons.person_outline,
                                size: isMobile ? 11 : 12,
                                color: AppTheme.textSecondary,
                              ),
                              SizedBox(width: 4),
                              Flexible(
                                child: Text(
                                  'Flagged by: ${data['flaggedBy']['name'] ?? 'Unknown'}${data['flaggedBy']['role'] != null ? ' (${data['flaggedBy']['role']})' : ''}',
                                  style: AppTheme.bodySmall.copyWith(
                                    fontSize: isMobile ? 9 : 10,
                                    color: AppTheme.textSecondary,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                          if (data['flaggedAt'] != null) ...[
                            SizedBox(height: 2),
                            Text(
                              'Flagged on: ${_formatDate(data['flaggedAt'])}',
                              style: AppTheme.bodySmall.copyWith(
                                fontSize: isMobile ? 8 : 9,
                                color: AppTheme.textMuted,
                              ),
                            ),
                          ],
                        ],
                        
                        // Response Section
                        if (data['response'] != null && data['response'].toString().trim().isNotEmpty) ...[
                          SizedBox(height: isMobile ? 8 : 4),
                          Container(
                            padding: EdgeInsets.all(isMobile ? 8 : 6),
                            decoration: BoxDecoration(
                              color: AppTheme.secondaryColor.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                color: AppTheme.secondaryColor.withOpacity(0.3),
                                width: 1,
                              ),
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    Icon(
                                      Icons.reply,
                                      size: isMobile ? 11 : 12,
                                      color: AppTheme.secondaryColor,
                                    ),
                                    SizedBox(width: 4),
                                    Text(
                                      'Response:',
                                      style: AppTheme.bodySmall.copyWith(
                                        fontWeight: FontWeight.w600,
                                        fontSize: isMobile ? 9 : 10,
                                        color: AppTheme.secondaryColor,
                                      ),
                                    ),
                                  ],
                                ),
                                SizedBox(height: 4),
                                Text(
                                  data['response'].toString(),
                                  style: AppTheme.bodySmall.copyWith(
                                    fontSize: isMobile ? 9 : 10,
                                    color: AppTheme.textPrimary,
                                  ),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                                if (data['responseDate'] != null) ...[
                                  SizedBox(height: 4),
                                  Text(
                                    'Responded on: ${_formatDate(data['responseDate'])}',
                                    style: AppTheme.bodySmall.copyWith(
                                      fontSize: isMobile ? 8 : 9,
                                      color: AppTheme.textMuted,
                                    ),
                                  ),
                                ],
                              ],
                            ),
                          ),
                        ],
                        
                        // Add spacing between Response Section and ID+Button
                        SizedBox(height: isMobile ? 8 : 4),
                        
                        // Transaction ID + View Button on same line
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            Flexible(
                              child: Text(
                                formattedId,
                                style: AppTheme.bodyMedium.copyWith(
                                  fontSize: isMobile ? 10 : 11,
                                  fontWeight: FontWeight.w600,
                                  color: AppTheme.textMuted,
                                ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            SizedBox(width: isMobile ? 8 : 4),  // Add spacing between ID and button
                            OutlinedButton.icon(
                              onPressed: () => _showQuickViewDialog(data, isMobile, isTablet),
                              icon: Icon(Icons.visibility_outlined, size: isMobile ? 12 : 13),
                              label: Text('View', style: TextStyle(fontSize: isMobile ? 12 : 13)),
                              style: OutlinedButton.styleFrom(
                                foregroundColor: AppTheme.primaryColor,
                                backgroundColor: AppTheme.primaryColor.withOpacity(0.08),
                                side: BorderSide(color: AppTheme.primaryColor.withOpacity(0.3)),
                                padding: EdgeInsets.symmetric(
                                  vertical: isMobile ? 4 : 2,
                                  horizontal: isMobile ? 8 : 6,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                minimumSize: Size(0, isMobile ? 28 : 24),  // Increased height for mobile
                                tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                              ),
                            ),
                          ],
                        ),
                        ],
                        ),
                      ),
                    );
                    
                    return content;
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showResponseDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    print('üìù [RESPONSE DIALOG] Opening response dialog:');
    print('   data keys: ${data.keys.toList()}');
    print('   data[id]: ${data['id']}');
    print('   data[category]: ${data['category']}');
    print('   data[type]: ${data['type']}');
    
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    print('   financialData keys: ${financialData.keys.toList()}');
    print('   financialData[transactionId]: ${financialData['transactionId']}');
    print('   financialData[expenseId]: ${financialData['expenseId']}');
    print('   financialData[collectionId]: ${financialData['collectionId']}');
    
    final category = data['category']?.toString().toLowerCase() ?? '';
    print('   category: $category');
    
    // Get ID based on category - also check data['id'] directly
    final itemId = data['id']?.toString() ?? 
        (category == 'expenses' || category == 'expense'
            ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
            : (category == 'collections' || category == 'collection'
                ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
                : (financialData['transactionId'] ?? 'N/A')));
    
    print('   Final itemId: $itemId');
    
    // Determine item type
    final itemType = category == 'expenses' || category == 'expense' 
        ? 'Expense' 
        : (category == 'collections' || category == 'collection' 
            ? 'Collection' 
            : 'Transaction');
    
    final responseController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => StatefulBuilder(
        builder: (context, setDialogState) => Dialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          child: Container(
            width: isMobile ? double.infinity : 500,
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(context).size.height * 0.8,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Header
                Padding(
                  padding: EdgeInsets.all(isMobile ? 16 : 20),
                  child: Row(
                    children: [
                      Icon(Icons.reply, color: AppTheme.primaryColor, size: 20),
                      SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Add Response',
                              style: AppTheme.headingSmall.copyWith(
                                fontSize: isMobile ? 16 : 18,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            SizedBox(height: 4),
                            Text(
                              '$itemType #$itemId',
                              style: AppTheme.bodySmall.copyWith(
                                fontSize: isMobile ? 11 : 12,
                                color: AppTheme.textSecondary,
                              ),
                            ),
                          ],
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        icon: Icon(Icons.close, size: 20),
                        padding: EdgeInsets.all(4),
                        constraints: BoxConstraints(),
                      ),
                    ],
                  ),
                ),
                
                Divider(height: 1),
                
                // Content
                Flexible(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.all(isMobile ? 16 : 24),
                    child: Form(
                      key: formKey,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          // Flag Reason Display
                          if (data['message'] != null || data['flagReason'] != null) ...[
                            Container(
                              padding: EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: AppTheme.warningColor.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: AppTheme.warningColor.withOpacity(0.3),
                                ),
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      Icon(Icons.flag, color: AppTheme.warningColor, size: 16),
                                      SizedBox(width: 8),
                                      Text(
                                        'Flag Reason:',
                                        style: AppTheme.bodySmall.copyWith(
                                          fontWeight: FontWeight.w600,
                                          color: AppTheme.warningColor,
                                        ),
                                      ),
                                    ],
                                  ),
                                  SizedBox(height: 8),
                                  Text(
                                    data['message'] ?? data['flagReason'] ?? 'No reason provided',
                                    style: AppTheme.bodyMedium,
                                  ),
                                ],
                              ),
                            ),
                            SizedBox(height: 20),
                          ],
                          
                          // Response Input
                          Text(
                            'Your Response *',
                            style: AppTheme.bodyMedium.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          SizedBox(height: 8),
                          TextFormField(
                            controller: responseController,
                            maxLines: 5,
                            decoration: InputDecoration(
                              hintText: 'Enter your response to the flag...',
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.borderColor),
                              ),
                              enabledBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.borderColor),
                              ),
                              focusedBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.primaryColor, width: 2),
                              ),
                              contentPadding: EdgeInsets.all(12),
                              filled: true,
                              fillColor: Colors.white,
                            ),
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Please enter a response';
                              }
                              if (value.trim().length < 10) {
                                return 'Please provide more details (minimum 10 characters)';
                              }
                              return null;
                            },
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                
                // Footer
                Divider(height: 1),
                Padding(
                  padding: EdgeInsets.all(isMobile ? 16 : 20),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        child: Text('Cancel'),
                      ),
                      SizedBox(width: 12),
                      ElevatedButton(
                        onPressed: () async {
                          print('üìù [RESPONSE DIALOG] Submit Response button clicked');
                          print('   itemId: $itemId');
                          print('   itemType: $itemType');
                          if (formKey.currentState!.validate()) {
                            final response = responseController.text.trim();
                            print('üìù [RESPONSE DIALOG] Form validated, response length: ${response.length}');
                            Navigator.of(dialogContext).pop();
                            print('üìù [RESPONSE DIALOG] Calling _submitResponse...');
                            await _submitResponse(data, response, itemType, itemId.toString());
                          } else {
                            print('üìù [RESPONSE DIALOG] Form validation failed');
                          }
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.primaryColor,
                          foregroundColor: Colors.white,
                        ),
                        child: Text('Submit Response'),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _submitResponse(Map<String, dynamic> data, String response, String itemType, String itemId) async {
    try {
      final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
      final category = data['category']?.toString().toLowerCase() ?? '';
      final type = data['type']?.toString() ?? '';
      
      // Get item ID - try from data directly first (dashboard format), then from financialData
      final itemIdFromData = data['id']?.toString() ?? 
          financialData['expenseId']?.toString() ?? 
          financialData['collectionId']?.toString() ?? 
          financialData['transactionId']?.toString() ?? 
          itemId;
      
      Map<String, dynamic> result;
      
      // Determine type from category or type field
      // Transactions category is now 'transactions' (changed from 'cash_flow')
      print('üîÑ [RESUBMIT] Determining item type:');
      print('   Category: $category');
      print('   Type: $type');
      print('   ItemId: $itemIdFromData');
      print('   financialData.transactionId: ${financialData['transactionId']}');
      
      if (category == 'expenses' || category == 'expense' || type == 'Expenses') {
        print('üîÑ [RESUBMIT] ‚úÖ Calling ExpenseService.resubmitExpense');
        result = await ExpenseService.resubmitExpense(itemIdFromData, response);
      } else if (category == 'collections' || category == 'collection' || type == 'Collections') {
        print('üîÑ [RESUBMIT] ‚úÖ Calling CollectionService.resubmitCollection');
        result = await CollectionService.resubmitCollection(itemIdFromData, response);
      } else if (category == 'transactions' || category == 'transaction' || category == 'cash_flow' || type == 'Transactions') {
        print('üîÑ [RESUBMIT] ‚úÖ Calling TransactionService.resubmitTransaction (category: $category)');
        result = await TransactionService.resubmitTransaction(itemIdFromData, response);
      } else {
        // Fallback: default to transaction
        print('üîÑ [RESUBMIT] ‚ö†Ô∏è Fallback: Calling TransactionService.resubmitTransaction (category: $category)');
        result = await TransactionService.resubmitTransaction(itemIdFromData, response);
      }
      
      print('üîÑ [RESUBMIT] Result: success=${result['success']}, message=${result['message']}');
      
      if (mounted) {
        if (result['success'] == true) {
          // Remove from local flagged items immediately (it's now Pending, not Flagged)
          if (itemIdFromData.isNotEmpty) {
            // Track this item as resubmitted (safeguard)
            _resubmittedItemIds.add(itemIdFromData);
            
            _removeFlaggedItem(itemIdFromData, category: category);
            
            // Wait longer for backend to process and save the status change (same delay as expense)
            await Future.delayed(Duration(milliseconds: 1500));
            
            // Reload flagged items to ensure sync
            await _loadTimelineEntries();
            
            // Clear the resubmitted tracking after a delay (cleanup)
            Future.delayed(Duration(seconds: 5), () {
              _resubmittedItemIds.remove(itemIdFromData);
            });
            
            // Stay on the same page (don't navigate to Smart Approvals)
            print('üö© [FLAGGED ITEMS] Staying on current page for collection (not navigating to Smart Approvals)');
            
            // Refresh dashboard data to update approvals list (same as expense)
            _loadDashboardData();
            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
            
            // Wait a bit more for backend to fully update before refreshing Smart Approvals
            await Future.delayed(Duration(milliseconds: 500));
            
            // Refresh Smart Approvals if it's currently visible (same as expense)
            if (_selectedItem == NavItem.smartApprovals && _pendingApprovalsRefreshKey.currentState != null) {
              print('üîÑ [RESUBMIT] Refreshing Smart Approvals after resubmit');
              _pendingApprovalsRefreshKey.currentState!.refresh();
            }
            
            // Also trigger filter update to ensure transaction appears (same as expense)
            Future.delayed(const Duration(milliseconds: 500), () {
              if (mounted) {
                _applyFilters();
              }
            });
          }
          
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? 'Response submitted successfully'),
              backgroundColor: AppTheme.secondaryColor,
            ),
          );
          // Refresh flagged items
          _loadTimelineEntries();
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? 'Failed to submit response'),
              backgroundColor: AppTheme.errorColor,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  Future<void> _resubmitItem(Map<String, dynamic> data) async {
    // Resubmit is the same as submitting response - it changes status to Pending
    // The response should already be there, so we just need to confirm
    final response = data['response']?.toString() ?? '';
    
    if (response.isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Please add a response first before resubmitting'),
            backgroundColor: AppTheme.warningColor,
          ),
        );
      }
      return;
    }
    
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Resubmit Item'),
        content: Text('Are you sure you want to resubmit this item? It will be moved back to Pending status.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppTheme.primaryColor,
              foregroundColor: Colors.white,
            ),
            child: Text('Resubmit'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await _submitResponse(data, response, '', '');
    }
  }

  void _showEditResubmitDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final category = data['category']?.toString().toLowerCase() ?? '';
    
    // Get ID based on category
    final itemId = category == 'expenses' || category == 'expense'
        ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
        : (category == 'collections' || category == 'collection'
            ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
            : (financialData['transactionId'] ?? 'N/A'));
    
    final originalAmount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
    final expectedAmount = (financialData['expectedAmount'] as num?)?.toDouble() ?? originalAmount;
    final difference = (financialData['difference'] as num?)?.toDouble() ?? 0.0;
    final paymentMode = financialData['paymentMode'] ?? 'N/A';
    final account = financialData['account'] ?? 'N/A';
    final timestamp = data['timestamp'] is DateTime
        ? data['timestamp'] as DateTime
        : DateTime.parse(data['timestamp'].toString());
    
    // Determine item type
    final itemType = category == 'expenses' || category == 'expense' 
        ? 'Expense' 
        : (category == 'collections' || category == 'collection' 
            ? 'Collection' 
            : 'Transaction');
    
    // Get category info for icon display
    final categoryInfo = _getCategoryInfo(data);
    
    final reasonController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => StatefulBuilder(
        builder: (context, setDialogState) => Dialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          child: Container(
            width: isMobile ? double.infinity : 600,
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(context).size.height * 0.9,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Simple Header
                Padding(
                  padding: EdgeInsets.all(isMobile ? 16 : 20),
                  child: Row(
                    children: [
                      Icon(Icons.edit_outlined, color: AppTheme.accentBlue, size: 20),
                      SizedBox(width: 12),
                      Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Edit & Resubmit $itemType',
                                style: AppTheme.headingSmall.copyWith(
                                  fontSize: isMobile ? 16 : 18,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                              SizedBox(height: 4),
                              Row(
                                children: [
                                  Icon(
                                    categoryInfo['icon'] as IconData,
                                    color: categoryInfo['color'] as Color,
                                    size: 14,
                                  ),
                                  SizedBox(width: 4),
                                  Text(
                                    '#$itemId',
                                    style: AppTheme.bodySmall.copyWith(
                                      fontSize: isMobile ? 11 : 12,
                                      color: AppTheme.textSecondary,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        icon: Icon(Icons.close, size: 20),
                        padding: EdgeInsets.all(4),
                        constraints: BoxConstraints(),
                      ),
                    ],
                  ),
                ),
                
                Divider(height: 1),
                
                // Content - Simple Form
                Flexible(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.all(isMobile ? 16 : 24),
                    child: Form(
                      key: formKey,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          // Issue Message - What is Flagged
                          Container(
                            padding: EdgeInsets.all(isMobile ? 12 : 14),
                            decoration: BoxDecoration(
                              color: AppTheme.warningColor.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                color: AppTheme.warningColor.withOpacity(0.3),
                              ),
                            ),
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Icon(Icons.flag, color: AppTheme.warningColor, size: 20),
                                SizedBox(width: 10),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        'Flagged Issue:',
                                        style: AppTheme.bodySmall.copyWith(
                                          fontSize: isMobile ? 11 : 12,
                                          fontWeight: FontWeight.w600,
                                          color: AppTheme.warningColor,
                                        ),
                                      ),
                                      SizedBox(height: 4),
                                      Text(
                                        data['message'] ?? 'Flagged item requires review',
                                        style: AppTheme.bodyMedium.copyWith(
                                          fontSize: isMobile ? 13 : 14,
                                          color: AppTheme.textPrimary,
                                          fontWeight: FontWeight.w500,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                          SizedBox(height: 20),
                          
                          // Reason Input
                          Text(
                            'Reason for Resubmission *',
                            style: AppTheme.bodyMedium.copyWith(
                              fontSize: isMobile ? 13 : 14,
                              fontWeight: FontWeight.w600,
                              color: AppTheme.textPrimary,
                            ),
                          ),
                          SizedBox(height: 8),
                          TextFormField(
                            controller: reasonController,
                            maxLines: 4,
                            decoration: InputDecoration(
                              hintText: 'Enter reason for resubmission...',
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.borderColor),
                              ),
                              enabledBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.borderColor),
                              ),
                              focusedBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.primaryColor, width: 2),
                              ),
                              errorBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8),
                                borderSide: BorderSide(color: AppTheme.errorColor),
                              ),
                              contentPadding: EdgeInsets.all(12),
                              filled: true,
                              fillColor: Colors.white,
                            ),
                            style: AppTheme.bodyMedium.copyWith(
                              fontSize: isMobile ? 14 : 15,
                            ),
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Please enter a reason for resubmission';
                              }
                              if (value.trim().length < 10) {
                                return 'Please provide more details (minimum 10 characters)';
                              }
                              return null;
                            },
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                
                // Simple Footer
                Divider(height: 1),
                Padding(
                  padding: EdgeInsets.all(isMobile ? 16 : 20),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        style: TextButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                        ),
                        child: Text('Cancel'),
                      ),
                      SizedBox(width: 12),
                      ElevatedButton.icon(
                        onPressed: () {
                          if (formKey.currentState!.validate()) {
                            final reasonText = reasonController.text.trim();
                            if (reasonText.isEmpty) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Please enter a reason for resubmission'),
                                  backgroundColor: AppTheme.errorColor,
                                ),
                              );
                              return;
                            }
                            
                            Navigator.of(dialogContext).pop();
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text('Resubmission submitted successfully'),
                                backgroundColor: AppTheme.secondaryColor,
                                duration: Duration(seconds: 2),
                              ),
                            );
                            // TODO: Implement actual resubmission API call with reason
                            // ResubmissionService.resubmit(itemId, reasonText, itemType);
                          }
                        },
                        icon: Icon(Icons.send, size: 18),
                        label: Text('Resubmit'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.secondaryColor,
                          foregroundColor: Colors.white,
                          padding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSimpleDetailRow(String label, String value, bool isMobile) {
    return Padding(
      padding: EdgeInsets.only(bottom: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: isMobile ? 100 : 120,
            child: Text(
              '$label:',
              style: AppTheme.bodyMedium.copyWith(
                fontSize: isMobile ? 13 : 14,
                color: AppTheme.textSecondary,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: AppTheme.bodyMedium.copyWith(
                fontSize: isMobile ? 13 : 14,
                fontWeight: FontWeight.w500,
                color: AppTheme.textPrimary,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSimpleFormField({
    required String label,
    required Widget child,
    required bool isMobile,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: AppTheme.bodyMedium.copyWith(
            fontSize: isMobile ? 13 : 14,
            color: AppTheme.textSecondary,
            fontWeight: FontWeight.w500,
          ),
        ),
        SizedBox(height: 8),
        child,
      ],
    );
  }

  Widget _buildFinancialDetail(String label, String value, Color color, bool isMobile) {
    return Column(
      children: [
        Text(
          label,
          style: AppTheme.bodySmall.copyWith(
            fontSize: isMobile ? 11 : 12,
            color: AppTheme.textSecondary,
          ),
        ),
        SizedBox(height: 4),
        Text(
          value,
          style: AppTheme.headingSmall.copyWith(
            fontSize: isMobile ? 16 : 18,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ],
    );
  }

  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    
    if (difference.inMinutes < 1) return 'Just now';
    if (difference.inMinutes < 60) return '${difference.inMinutes}m ago';
    if (difference.inHours < 24) return '${difference.inHours}h ago';
    if (difference.inDays < 7) return '${difference.inDays}d ago';
    
    return DateFormat('MMM d, y').format(timestamp);
  }

  String _formatCurrency(double amount) {
    if (amount == 0) return '0.00';
    final formatter = NumberFormat('#,##,###.00');
    return formatter.format(amount);
  }

  Future<void> _showQuickViewDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) async {
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final category = data['category']?.toString().toLowerCase() ?? '';
    
    // Check permissions for editing
    // Admin/SuperAdmin always have access (matches backend middleware)
    final userRole = await AuthService.getUserRole();
    final isAdmin = userRole == 'Admin';
    final isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
    bool canEdit = false;
    if (isAdmin || isSuperAdmin) {
      canEdit = true;
    } else if (category == 'expenses' || category == 'expense') {
      // Check for expenses.manage or wallet.all.expenses.edit permission (must match backend exactly)
      canEdit = await UIPermissionChecker.hasPermission('expenses.manage') ||
                await UIPermissionChecker.hasPermission('wallet.all.expenses.edit');
    } else if (category == 'collections' || category == 'collection') {
      canEdit = await UIPermissionChecker.hasPermission('wallet.all.collection.edit');
    } else {
      canEdit = await UIPermissionChecker.hasPermission('wallet.all.transaction.edit');
    }
    
    // Get ID based on category
    final itemId = category == 'expenses' || category == 'expense'
        ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
        : (category == 'collections' || category == 'collection'
            ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
            : (financialData['transactionId'] ?? 'N/A'));
    
    final amount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
    final paymentMode = financialData['paymentMode']?.toString() ?? financialData['mode']?.toString() ?? 'N/A';
    
    // Determine item type and get category info
    final itemType = category == 'expenses' || category == 'expense' 
        ? 'Expense' 
        : (category == 'collections' || category == 'collection' 
            ? 'Collection' 
            : 'Transaction');
    
    final categoryInfo = _getCategoryInfo(data);
    
    // Extract data based on type
    String field1Label = '';
    String field1Value = '';
    String field2Label = 'Amount';
    String field2Value = amount > 0 ? _formatAmount(amount) : 'N/A';
    String field3Label = 'Payment Mode';
    String field3Value = paymentMode != 'N/A' ? paymentMode : 'N/A';
    String field4Label = '';
    String field4Value = '';
    String sectionTitle = '';
    
    if (itemType == 'Transaction') {
      sectionTitle = 'Transaction Details';
      field1Label = 'Transfer To';
      final receiver = financialData['receiver'];
      field1Value = _extractNameFromData(receiver);
      field4Label = 'Purpose';
      field4Value = financialData['purpose']?.toString() ?? 'N/A';
    } else if (itemType == 'Expense') {
      sectionTitle = 'Expense Details';
      field1Label = 'Expense Type';
      field1Value = financialData['expenseType']?.toString() ?? financialData['category']?.toString() ?? 'N/A';
      field4Label = 'Description';
      field4Value = financialData['description']?.toString() ?? 'N/A';
    } else if (itemType == 'Collection') {
      sectionTitle = 'Collection Details';
      field1Label = 'Transfer To';
      final assignedReceiver = financialData['assignedReceiver'];
      field1Value = _extractNameFromData(assignedReceiver);
      field4Label = 'Customer Name';
      field4Value = financialData['customerName']?.toString() ?? 'N/A';
    }

    showDialog(
      context: context,
      builder: (dialogContext) => Dialog(
        insetPadding: EdgeInsets.symmetric(
          horizontal: isMobile ? 16 : 24,
          vertical: isMobile ? 16 : 24,
        ),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
          width: isMobile ? double.infinity : 380,
          height: MediaQuery.of(context).size.height * 0.9,
            padding: EdgeInsets.all(isMobile ? 16 : 24),
              child: Column(
            mainAxisSize: MainAxisSize.max,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header with Title and ID Badge
                  Row(
                    children: [
                      Icon(Icons.visibility, color: AppTheme.accentBlue, size: 24),
                      SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'View Details',
                              style: AppTheme.headingSmall.copyWith(
                                fontSize: isMobile ? 18 : 20,
                                fontWeight: FontWeight.w600,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                            SizedBox(height: 4),
                            Row(
                              children: [
                                Icon(
                                  categoryInfo['icon'] as IconData,
                                  color: categoryInfo['color'] as Color,
                                  size: 14,
                                ),
                                SizedBox(width: 4),
                                Flexible(
                                  child: Text(
                                    '$itemType #$itemId',
                                    style: AppTheme.bodySmall.copyWith(
                                      fontSize: isMobile ? 11 : 12,
                                      color: AppTheme.textSecondary,
                                      fontWeight: FontWeight.w500,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        icon: Icon(Icons.close),
                        padding: EdgeInsets.all(4),
                        constraints: BoxConstraints(),
                      ),
                    ],
                  ),
                SizedBox(height: 20),
                
              // Scrollable content area
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                // Flagged Issue Alert (Orange)
                Container(
                  padding: EdgeInsets.all(isMobile ? 14 : 16),
                  decoration: BoxDecoration(
                    color: AppTheme.warningColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(
                      color: AppTheme.warningColor.withOpacity(0.4),
                      width: 1.5,
                    ),
                  ),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        padding: EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: AppTheme.warningColor.withOpacity(0.2),
                          shape: BoxShape.circle,
                        ),
                        child: Icon(
                          Icons.flag,
                          color: AppTheme.warningColor,
                          size: 20,
                        ),
                      ),
                      SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Flagged Issue:',
                              style: AppTheme.bodySmall.copyWith(
                                fontSize: isMobile ? 11 : 12,
                                fontWeight: FontWeight.w600,
                                color: AppTheme.warningColor,
                                letterSpacing: 0.5,
                              ),
                            ),
                            SizedBox(height: 6),
                            Text(
                              data['message'] ?? 'Flagged item requires review',
                              style: AppTheme.bodyMedium.copyWith(
                                fontSize: isMobile ? 14 : 15,
                                fontWeight: FontWeight.w500,
                                color: AppTheme.textPrimary,
                              ),
                              overflow: TextOverflow.visible,
                              softWrap: true,
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                SizedBox(height: 20),
                
                // Details Section (Type-specific, Non-editable)
                Container(
                  padding: EdgeInsets.all(isMobile ? 14 : 16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(color: AppTheme.borderColor),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Icon(Icons.info_outline, color: AppTheme.primaryColor, size: 18),
                          SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              sectionTitle,
                              style: AppTheme.bodyMedium.copyWith(
                                fontSize: isMobile ? 14 : 15,
                                fontWeight: FontWeight.w600,
                                color: AppTheme.textPrimary,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                      SizedBox(height: 16),
                      
                      // Field 1 (Transfer To / Expense Type)
                      _buildDetailRow(field1Label, field1Value, isMobile),
                      SizedBox(height: 12),
                      Divider(height: 1, color: AppTheme.borderColor),
                      SizedBox(height: 12),
                      
                      // Field 2 (Amount)
                      _buildDetailRow(field2Label, field2Value, isMobile),
                      SizedBox(height: 12),
                      Divider(height: 1, color: AppTheme.borderColor),
                      SizedBox(height: 12),
                      
                      // Field 3 (Payment Mode)
                      if (field3Value != 'N/A')
                        _buildDetailRow(field3Label, field3Value, isMobile),
                      if (field3Value != 'N/A') ...[
                        SizedBox(height: 12),
                        Divider(height: 1, color: AppTheme.borderColor),
                        SizedBox(height: 12),
                      ],
                      
                      // Field 4 (Purpose / Description / Customer Name)
                      _buildDetailRow(field4Label, field4Value, isMobile),
                    ],
                        ),
                      ),
                    ],
                  ),
                  ),
                ),
                
                SizedBox(height: 24),
                
                // Edit Button (only show if user has permission)
                if (canEdit)
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      FilledButton.icon(
                        onPressed: () async {
                          // Close the dialog first
                          Navigator.of(dialogContext).pop();
                          // Wait for dialog to fully close and animation to complete
                          // This prevents mouse tracker assertion errors
                          await Future.delayed(const Duration(milliseconds: 100));
                          if (!mounted) return;
                          final category = data['category']?.toString().toLowerCase() ?? '';
                          if (category == 'expenses' || category == 'expense') {
                            _showEditExpenseFromFlagged(data, isMobile, isTablet);
                          } else if (category == 'collections' || category == 'collection') {
                            _showEditCollectionFromFlagged(data, isMobile, isTablet);
                          } else {
                            _showEditTransactionFromFlagged(data, isMobile, isTablet);
                          }
                        },
                        icon: Icon(Icons.edit_outlined, size: isMobile ? 16 : 18),
                        label: Text('Edit', style: TextStyle(fontSize: isMobile ? 14 : 15)),
                        style: FilledButton.styleFrom(
                          backgroundColor: AppTheme.primaryColor,
                          foregroundColor: Colors.white,
                          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ],
                  ),
              ],
          ),
        ),
      ),
    );
  }

  void _showEditDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final category = data['category']?.toString().toLowerCase() ?? '';
    
    // Get ID based on category
    final itemId = category == 'expenses' || category == 'expense'
        ? (financialData['expenseId'] ?? financialData['transactionId'] ?? 'N/A')
        : (category == 'collections' || category == 'collection'
            ? (financialData['collectionId'] ?? financialData['transactionId'] ?? 'N/A')
            : (financialData['transactionId'] ?? 'N/A'));
    
    final amount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
    final expectedAmount = (financialData['expectedAmount'] as num?)?.toDouble() ?? 0.0;
    final paymentMode = financialData['paymentMode'] ?? 'Cash';
    final account = financialData['account'] ?? '';
    final timestamp = data['timestamp'] is DateTime
        ? data['timestamp'] as DateTime
        : DateTime.parse(data['timestamp'].toString());
    
    // Determine item type and get category info
    final itemType = category == 'expenses' || category == 'expense' 
        ? 'Expense' 
        : (category == 'collections' || category == 'collection' 
            ? 'Collection' 
            : 'Transaction');
    
    final categoryInfo = _getCategoryInfo(data);
    
    // Initialize form controllers with existing data
    final reasonController = TextEditingController(text: data['message'] ?? '');
    final amountController = TextEditingController(text: amount > 0 ? amount.toStringAsFixed(2) : '');
    final expectedAmountController = TextEditingController(text: expectedAmount > 0 ? expectedAmount.toStringAsFixed(2) : '');
    final paymentModeController = TextEditingController(text: paymentMode);
    final accountController = TextEditingController(text: account);
    final descriptionController = TextEditingController(text: financialData['description'] ?? '');
    
    final formKey = GlobalKey<FormState>();
    String? selectedPaymentMode = paymentMode != 'N/A' ? paymentMode : 'Cash';
    bool isLoading = false;

    showDialog(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (context, setDialogState) => Dialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: isMobile ? double.infinity : 500,
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(context).size.height * 0.9,
            ),
            padding: EdgeInsets.all(isMobile ? 16 : 24),
            child: Form(
              key: formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.max,
                children: [
                  // Header
                  Row(
                    children: [
                      Icon(Icons.edit_outlined, color: AppTheme.primaryColor, size: 24),
                      SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Edit $itemType',
                              style: AppTheme.headingSmall.copyWith(
                                fontSize: isMobile ? 18 : 20,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            SizedBox(height: 4),
                            Row(
                              children: [
                                Icon(
                                  categoryInfo['icon'] as IconData,
                                  color: categoryInfo['color'] as Color,
                                  size: 14,
                                ),
                                SizedBox(width: 4),
                                Text(
                                  '$itemType #$itemId',
                                  style: AppTheme.bodySmall.copyWith(
                                    fontSize: isMobile ? 11 : 12,
                                    color: AppTheme.textSecondary,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        icon: Icon(Icons.close),
                        padding: EdgeInsets.all(4),
                        constraints: BoxConstraints(),
                      ),
                    ],
                  ),
                  SizedBox(height: 20),
                  
                  Expanded(
                    child: ConstrainedBox(
                      constraints: BoxConstraints(
                        maxHeight: MediaQuery.of(context).size.height * 0.5,
                      ),
                      child: SingleChildScrollView(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                          // Flagged Issue Alert (Read-only)
                          Container(
                            padding: EdgeInsets.all(isMobile ? 14 : 16),
                            decoration: BoxDecoration(
                              color: AppTheme.warningColor.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(10),
                              border: Border.all(
                                color: AppTheme.warningColor.withOpacity(0.4),
                                width: 1.5,
                              ),
                            ),
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Container(
                                  padding: EdgeInsets.all(6),
                                  decoration: BoxDecoration(
                                    color: AppTheme.warningColor.withOpacity(0.2),
                                    shape: BoxShape.circle,
                                  ),
                                  child: Icon(
                                    Icons.flag,
                                    color: AppTheme.warningColor,
                                    size: 20,
                                  ),
                                ),
                                SizedBox(width: 12),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        'Flagged Issue:',
                                        style: AppTheme.bodySmall.copyWith(
                                          fontSize: isMobile ? 11 : 12,
                                          fontWeight: FontWeight.w600,
                                          color: AppTheme.warningColor,
                                          letterSpacing: 0.5,
                                        ),
                                      ),
                                      SizedBox(height: 6),
                                      Text(
                                        data['message'] ?? 'Flagged item requires review',
                                        style: AppTheme.bodyMedium.copyWith(
                                          fontSize: isMobile ? 14 : 15,
                                          fontWeight: FontWeight.w500,
                                          color: AppTheme.textPrimary,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                          SizedBox(height: 20),
                          
                          // Reason/Message Field (Editable)
                          TextFormField(
                            controller: reasonController,
                            decoration: InputDecoration(
                              labelText: 'Reason / Message',
                              hintText: 'Enter reason or message...',
                              prefixIcon: Icon(Icons.message_outlined),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              filled: true,
                              fillColor: AppTheme.backgroundColor,
                            ),
                            maxLines: 3,
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Please enter a reason or message';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: 16),
                          
                          // Amount Fields
                          if (amount > 0 || expectedAmount > 0) ...[
                            Row(
                              children: [
                                Expanded(
                                  child: TextFormField(
                                    controller: amountController,
                                    decoration: InputDecoration(
                                      labelText: 'Amount',
                                      prefixIcon: Icon(Icons.currency_rupee),
                                      prefixText: '‚Çπ ',
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      filled: true,
                                      fillColor: AppTheme.backgroundColor,
                                    ),
                                    keyboardType: TextInputType.numberWithOptions(decimal: true),
                                    validator: (value) {
                                      if (value == null || value.trim().isEmpty) {
                                        return 'Required';
                                      }
                                      final amount = double.tryParse(value);
                                      if (amount == null || amount <= 0) {
                                        return 'Invalid amount';
                                      }
                                      return null;
                                    },
                                  ),
                                ),
                                if (expectedAmount > 0) ...[
                                  SizedBox(width: 12),
                                  Expanded(
                                    child: TextFormField(
                                      controller: expectedAmountController,
                                      decoration: InputDecoration(
                                        labelText: 'Expected Amount',
                                        prefixIcon: Icon(Icons.currency_rupee),
                                        prefixText: '‚Çπ ',
                                        border: OutlineInputBorder(
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                                        filled: true,
                                        fillColor: AppTheme.backgroundColor,
                                      ),
                                      keyboardType: TextInputType.numberWithOptions(decimal: true),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                            SizedBox(height: 16),
                          ],
                          
                          // Payment Mode Dropdown
                          DropdownButtonFormField<String>(
                            value: selectedPaymentMode != null && ['Cash', 'UPI', 'Bank Transfer', 'Cheque', 'Card', 'Other'].contains(selectedPaymentMode)
                                ? selectedPaymentMode
                                : null,
                            decoration: InputDecoration(
                              labelText: 'Payment Mode',
                              prefixIcon: Icon(Icons.payment),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              filled: true,
                              fillColor: AppTheme.backgroundColor,
                            ),
                            items: ['Cash', 'UPI', 'Bank Transfer', 'Cheque', 'Card', 'Other'].map((mode) {
                              return DropdownMenuItem(
                                value: mode,
                                child: Text(mode),
                              );
                            }).toList(),
                            onChanged: (value) {
                              setDialogState(() {
                                selectedPaymentMode = value;
                                paymentModeController.text = value ?? 'Cash';
                              });
                            },
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return 'Please select payment mode';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: 16),
                          
                          // Account Field
                          if (account.isNotEmpty) ...[
                            TextFormField(
                              controller: accountController,
                              decoration: InputDecoration(
                                labelText: 'Account',
                                prefixIcon: Icon(Icons.account_balance),
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                filled: true,
                                fillColor: AppTheme.backgroundColor,
                              ),
                            ),
                            SizedBox(height: 16),
                          ],
                          
                          // Description/Notes Field
                          TextFormField(
                            controller: descriptionController,
                            decoration: InputDecoration(
                              labelText: 'Description / Notes',
                              hintText: 'Enter additional notes or description...',
                              prefixIcon: Icon(Icons.note_outlined),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              filled: true,
                              fillColor: AppTheme.backgroundColor,
                            ),
                            maxLines: 3,
                          ),
                          SizedBox(height: 16),
                          
                          // Read-only Date Display
                          Container(
                            padding: EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: AppTheme.backgroundColor,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: AppTheme.borderColor),
                            ),
                            child: Row(
                              children: [
                                Icon(Icons.calendar_today, size: 18, color: AppTheme.textSecondary),
                                SizedBox(width: 12),
                                Text(
                                  'Date: ${DateFormat('MMM d, y, h:mm a').format(timestamp)}',
                                  style: AppTheme.bodyMedium.copyWith(
                                    fontSize: isMobile ? 12 : 13,
                                    color: AppTheme.textSecondary,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  ),
                  
                  SizedBox(height: 20),
                  
                  // Action Buttons
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: isLoading ? null : () => Navigator.of(dialogContext).pop(),
                        style: TextButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                        ),
                        child: Text('Cancel'),
                      ),
                      SizedBox(width: 12),
                      ElevatedButton.icon(
                        onPressed: isLoading ? null : () async {
                          if (formKey.currentState!.validate()) {
                            setDialogState(() {
                              isLoading = true;
                            });
                            
                            // Collect edited data
                            final editedData = {
                              'message': reasonController.text.trim(),
                              'amount': amountController.text.isNotEmpty 
                                  ? double.tryParse(amountController.text) ?? amount 
                                  : amount,
                              'expectedAmount': expectedAmountController.text.isNotEmpty 
                                  ? double.tryParse(expectedAmountController.text) ?? expectedAmount 
                                  : expectedAmount,
                              'paymentMode': selectedPaymentMode ?? paymentMode,
                              'account': accountController.text.trim(),
                              'description': descriptionController.text.trim(),
                              'originalData': data,
                            };
                            
                            // Simulate save operation
                            await Future.delayed(Duration(milliseconds: 500));
                            
                            if (mounted) {
                              setDialogState(() {
                                isLoading = false;
                              });
                              
                              Navigator.of(dialogContext).pop();
                              
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('$itemType updated successfully'),
                                  backgroundColor: AppTheme.secondaryColor,
                                  duration: Duration(seconds: 2),
                                ),
                              );
                              
                              // TODO: Integrate with backend API to save changes
                              // You can add API call here to actually save the edited data
                            }
                          }
                        },
                        icon: isLoading 
                            ? SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                ),
                              )
                            : Icon(Icons.save_outlined, size: 18),
                        label: Text(isLoading ? 'Saving...' : 'Save'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.primaryColor,
                          foregroundColor: Colors.white,
                          padding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDetailRow(String label, String value, bool isMobile, {Color? valueColor}) {
    return Padding(
      padding: EdgeInsets.only(bottom: 10),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: isMobile ? 85 : 100,
            child: Text(
              '$label:',
              style: AppTheme.bodySmall.copyWith(
                fontSize: isMobile ? 12 : 13,
                color: AppTheme.textSecondary,
                fontWeight: FontWeight.w500,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          SizedBox(width: isMobile ? 6 : 8),
          Expanded(
            child: Text(
              value,
              style: AppTheme.bodyMedium.copyWith(
                fontSize: isMobile ? 13 : 14,
                fontWeight: FontWeight.w600,
                color: valueColor ?? AppTheme.textPrimary,
              ),
              overflow: TextOverflow.visible,
              softWrap: true,
            ),
          ),
        ],
      ),
    );
  }

  // Helper function to extract name from data (handles both object and string)
  String _extractNameFromData(dynamic data) {
    if (data == null) return 'N/A';
    if (data is String && data.trim().isNotEmpty) return data.trim();
    if (data is Map<String, dynamic>) {
      return data['name']?.toString() ?? 'N/A';
    }
    return 'N/A';
  }

  void _showReviewDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final transactionId = financialData['transactionId'] ?? 'N/A';
    final amount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
    final expectedAmount = (financialData['expectedAmount'] as num?)?.toDouble() ?? 0.0;
    final difference = (financialData['difference'] as num?)?.toDouble() ?? 0.0;
    final paymentMode = financialData['paymentMode'] ?? 'N/A';
    final account = financialData['account'] ?? 'N/A';
    final issueType = financialData['issueType'] ?? 'Unknown';
    final timestamp = data['timestamp'] is DateTime
        ? data['timestamp'] as DateTime
        : DateTime.parse(data['timestamp'].toString());
    final checklistItems = data['checklistItems'] as List<dynamic>? ?? [];
    final attachments = data['attachments'] as List<dynamic>? ?? [];

    showDialog(
      context: context,
      builder: (dialogContext) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          width: isMobile ? double.infinity : 600,
          padding: EdgeInsets.all(isMobile ? 16 : 24),
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.visibility, color: AppTheme.accentBlue, size: 24),
                    SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        'Review Flagged Financial Flow Entry',
                        style: AppTheme.headingSmall.copyWith(
                          fontSize: isMobile ? 18 : 20,
                        ),
                      ),
                    ),
                    IconButton(
                      onPressed: () => Navigator.of(dialogContext).pop(),
                      icon: Icon(Icons.close),
                    ),
                  ],
                ),
                SizedBox(height: 24),
                
                // Transaction Information
                _buildReviewSection(
                  'Transaction Information',
                  [
                    'Transaction ID: $transactionId',
                    'Type: ${financialData['transactionType'] ?? 'Cash Flow'}',
                    'Date: ${DateFormat('MMMM d, y, h:mm a').format(timestamp)}',
                    'Payment Mode: $paymentMode',
                    'Account: $account',
                  ],
                  isMobile,
                ),
                SizedBox(height: 16),
                
                // Financial Discrepancy
                _buildReviewSection(
                  'Financial Discrepancy',
                  [
                    'Actual Amount: ‚Çπ${_formatCurrency(amount)}',
                    'Expected Amount: ‚Çπ${_formatCurrency(expectedAmount)}',
                    'Difference: ‚Çπ${_formatCurrency(difference.abs())} (${((difference.abs() / expectedAmount) * 100).toStringAsFixed(1)}% variance)',
                    'Status: ‚ö†Ô∏è Mismatch Detected',
                  ],
                  isMobile,
                ),
                SizedBox(height: 16),
                
                // Issue Details
                _buildReviewSection(
                  'Issue Details',
                  [
                    'Issue Type: $issueType',
                    data['message'] ?? 'Financial flow issue detected',
                  ],
                  isMobile,
                ),
                SizedBox(height: 16),
                
                // Checklist
                if (checklistItems.isNotEmpty)
                  _buildReviewChecklist(checklistItems, isMobile),
                if (checklistItems.isNotEmpty) SizedBox(height: 16),
                
                // Attachments
                if (attachments.isNotEmpty)
                  _buildReviewAttachments(attachments, isMobile),
                if (attachments.isNotEmpty) SizedBox(height: 24),
                
                // Action Buttons
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(dialogContext).pop(),
                      child: Text('Close'),
                    ),
                    SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        Navigator.of(dialogContext).pop();
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Marked as reviewed'),
                            backgroundColor: AppTheme.secondaryColor,
                          ),
                        );
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppTheme.accentBlue,
                        foregroundColor: Colors.white,
                      ),
                      child: Text('Mark as Reviewed'),
                    ),
                    SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        Navigator.of(dialogContext).pop();
                        _showEditResubmitDialog(data, isMobile, isTablet);
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppTheme.secondaryColor,
                        foregroundColor: Colors.white,
                      ),
                      child: Text('Resubmit'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildReviewSection(String title, List<String> items, bool isMobile) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      decoration: BoxDecoration(
        color: AppTheme.backgroundColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: AppTheme.borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: AppTheme.bodyMedium.copyWith(
              fontSize: isMobile ? 14 : 15,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 12),
          ...items.map((item) => Padding(
                padding: EdgeInsets.only(bottom: 8),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('‚Ä¢ ', style: TextStyle(color: AppTheme.textSecondary)),
                    Expanded(
                      child: Text(
                        item,
                        style: AppTheme.bodyMedium.copyWith(
                          fontSize: isMobile ? 13 : 14,
                        ),
                      ),
                    ),
                  ],
                ),
              )),
        ],
      ),
    );
  }

  Widget _buildReviewChecklist(List<dynamic> items, bool isMobile) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      decoration: BoxDecoration(
        color: AppTheme.backgroundColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: AppTheme.borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Resolution Checklist',
            style: AppTheme.bodyMedium.copyWith(
              fontSize: isMobile ? 14 : 15,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 12),
          ...items.map((item) => Padding(
                padding: EdgeInsets.only(bottom: 8),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Icon(Icons.check_box_outline_blank, size: 18, color: AppTheme.textSecondary),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        item.toString(),
                        style: AppTheme.bodyMedium.copyWith(
                          fontSize: isMobile ? 13 : 14,
                        ),
                      ),
                    ),
                  ],
                ),
              )),
        ],
      ),
    );
  }

  Widget _buildReviewAttachments(List<dynamic> attachments, bool isMobile) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      decoration: BoxDecoration(
        color: AppTheme.backgroundColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: AppTheme.borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Related Files',
            style: AppTheme.bodyMedium.copyWith(
              fontSize: isMobile ? 14 : 15,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 12),
          ...attachments.map((att) {
            final attData = att as Map<String, dynamic>;
            return Padding(
              padding: EdgeInsets.only(bottom: 8),
              child: Row(
                children: [
                  Icon(Icons.attach_file, size: 18, color: AppTheme.textSecondary),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      '${attData['filename']} (${attData['fileSize'] ?? ''})',
                      style: AppTheme.bodyMedium.copyWith(
                        fontSize: isMobile ? 13 : 14,
                      ),
                    ),
                  ),
                  TextButton(
                    onPressed: () {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Downloading ${attData['filename']}...'),
                          duration: Duration(seconds: 2),
                        ),
                      );
                    },
                    child: Text('Download', style: TextStyle(fontSize: 12)),
                  ),
                ],
              ),
            );
          }),
        ],
      ),
    );
  }

  void _showResubmitDialog(Map<String, dynamic> data, bool isMobile, bool isTablet) {
    final financialData = data['financialData'] as Map<String, dynamic>? ?? {};
    final transactionId = financialData['transactionId'] ?? 'N/A';
    final originalAmount = (financialData['amount'] as num?)?.toDouble() ?? 0.0;
    final expectedAmount = (financialData['expectedAmount'] as num?)?.toDouble() ?? 0.0;
    
    final correctedAmountController = TextEditingController(text: expectedAmount.toStringAsFixed(2));
    final notesController = TextEditingController();
    String? selectedReason;
    final reasons = [
      'Amount correction',
      'Payment mode correction',
      'Account reconciliation',
      'Data entry error',
      'Other',
    ];

    showDialog(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (context, setDialogState) => Dialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: isMobile ? double.infinity : 600,
            padding: EdgeInsets.all(isMobile ? 16 : 24),
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.send, color: AppTheme.secondaryColor, size: 24),
                      SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          'Resubmit Financial Flow Entry',
                          style: AppTheme.headingSmall.copyWith(
                            fontSize: isMobile ? 18 : 20,
                          ),
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        icon: Icon(Icons.close),
                      ),
                    ],
                  ),
                  SizedBox(height: 8),
                  Text(
                    'Transaction: $transactionId',
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.textSecondary,
                    ),
                  ),
                  SizedBox(height: 24),
                  
                  // Correction Details
                  Container(
                    padding: EdgeInsets.all(isMobile ? 12 : 16),
                    decoration: BoxDecoration(
                      color: AppTheme.backgroundColor,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: AppTheme.borderColor),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Correction Details',
                          style: AppTheme.bodyMedium.copyWith(
                            fontSize: isMobile ? 14 : 15,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        SizedBox(height: 16),
                        Row(
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Original Amount',
                                    style: AppTheme.bodySmall.copyWith(
                                      color: AppTheme.textSecondary,
                                    ),
                                  ),
                                  SizedBox(height: 4),
                                  Text(
                                    '‚Çπ${_formatCurrency(originalAmount)}',
                                    style: AppTheme.headingSmall.copyWith(
                                      fontSize: isMobile ? 16 : 18,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Corrected Amount',
                                    style: AppTheme.bodySmall.copyWith(
                                      color: AppTheme.textSecondary,
                                    ),
                                  ),
                                  SizedBox(height: 4),
                                  TextFormField(
                                    controller: correctedAmountController,
                                    keyboardType: TextInputType.numberWithOptions(decimal: true),
                                    decoration: InputDecoration(
                                      prefixText: '‚Çπ ',
                                      border: OutlineInputBorder(),
                                      contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: 16),
                  
                  // Correction Reason
                  Text(
                    'Correction Reason (Required)',
                    style: AppTheme.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  SizedBox(height: 8),
                  DropdownButtonFormField<String>(
                    value: selectedReason != null && reasons.contains(selectedReason)
                        ? selectedReason
                        : null,
                    decoration: InputDecoration(
                      border: OutlineInputBorder(),
                      hintText: 'Select reason',
                    ),
                    items: reasons.map((reason) => DropdownMenuItem(
                      value: reason,
                      child: Text(reason),
                    )).toList(),
                    onChanged: (value) => setDialogState(() => selectedReason = value),
                  ),
                  SizedBox(height: 16),
                  
                  // Additional Notes
                  Text(
                    'Additional Notes',
                    style: AppTheme.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  SizedBox(height: 8),
                  TextFormField(
                    controller: notesController,
                    maxLines: 3,
                    decoration: InputDecoration(
                      border: OutlineInputBorder(),
                      hintText: 'Enter additional details about the correction...',
                    ),
                  ),
                  SizedBox(height: 24),
                  
                  // Action Buttons
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        child: Text('Cancel'),
                      ),
                      SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: selectedReason == null
                            ? null
                            : () {
                                final correctedAmount = double.tryParse(correctedAmountController.text);
                                if (correctedAmount == null) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text('Please enter a valid amount'),
                                      backgroundColor: AppTheme.errorColor,
                                    ),
                                  );
                                  return;
                                }
                                
                                Navigator.of(dialogContext).pop();
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Resubmission submitted for review'),
                                    backgroundColor: AppTheme.secondaryColor,
                                  ),
                                );
                                // TODO: Implement actual resubmission API call
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppTheme.secondaryColor,
                          foregroundColor: Colors.white,
                        ),
                        child: Text('Submit for Review'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _handleDismissFlaggedItem(String itemId) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text('Dismiss Flagged Item'),
        content: Text('Are you sure you want to dismiss this flagged item? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(),
            child: Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(dialogContext).pop();
              setState(() {
                _timelineItems.removeWhere((item) => (item as Map<String, dynamic>)['id'] == itemId);
              });
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Flagged item dismissed'),
                  backgroundColor: AppTheme.textMuted,
                ),
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppTheme.errorColor,
              foregroundColor: Colors.white,
            ),
            child: Text('Dismiss'),
          ),
        ],
      ),
    );
  }

  Widget _buildMainDashboard() {
    final isMobile = Responsive.isMobile(context);
    final isTablet = Responsive.isTablet(context);

    return SingleChildScrollView(
      padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 20 : 24)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Dashboard Header Features - Quote and Financial Summary side by side
          isMobile
              ? Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _buildWelcomeRowWithSlogan(isMobile, isTablet),
                    SizedBox(height: 16),
                    _buildFinancialSummaryCards(isMobile, isTablet),
                  ],
                )
              : IntrinsicHeight(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Expanded(
                        flex: 1,
                        child: _buildWelcomeRowWithSlogan(isMobile, isTablet),
                      ),
                      SizedBox(width: 4),
                      Expanded(
                        flex: 1,
                        child: _buildFinancialSummaryCards(isMobile, isTablet),
                      ),
                    ],
                  ),
                ),
          SizedBox(height: isMobile ? 20 : 24),
          
          // Status Count Table and Flagged Financial Flow - 2 columns on desktop
          Builder(
            builder: (context) {
              // Measure Status Table height after first frame (desktop only)
              if (!isMobile && !isTablet) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  if (_statusTableKey.currentContext != null) {
                    final RenderBox? renderBox = 
                      _statusTableKey.currentContext!.findRenderObject() as RenderBox?;
                    if (renderBox != null) {
                      final height = renderBox.size.height;
                      if (_statusTableHeight != height) {
                        setState(() {
                          _statusTableHeight = height;
                        });
                      }
                    }
                  }
                });
              }
              
              return isMobile || isTablet
                  ? Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        _buildStatusCards(isMobile, isTablet),
                        SizedBox(height: isMobile ? 20 : 24),
                        _buildExampleCardsSection(isMobile, isTablet),
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: _buildStatusCards(isMobile, isTablet),
                        ),
                        SizedBox(width: 20),
                        Expanded(
                          child: _buildExampleCardsSection(isMobile, isTablet),
                        ),
                      ],
                    );
            },
          ),
          SizedBox(height: isMobile ? 20 : 28),
          
          // Existing dashboard content can go here if needed
        ],
      ),
    );
  }

  Widget _buildDashboardContent({bool isSelfWallet = false, String? customTitle, bool isAllAccounts = false, bool isExpenseReportOnly = false}) {
    final isMobile = Responsive.isMobile(context);
    final isTablet = Responsive.isTablet(context);
    
    // Log Account Reports initialization
    if (isAllAccounts && (customTitle == null || customTitle == 'Account Reports')) {
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      debugPrint('üìä [ACCOUNT REPORTS] Screen initialized');
      debugPrint('   customTitle: $customTitle');
      debugPrint('   isAllAccounts: $isAllAccounts');
      debugPrint('   _selectedAccountFilterId: $_selectedAccountFilterId');
      debugPrint('   _allAccountsList.length: ${_allAccountsList.length}');
      debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    }
    
    // Account Reports: Show all statuses by default (not just 'Approved')
    // This allows users to see all data including Pending, Flagged, and Rejected items
    // Users can still filter by status if needed
    final filterProvider = _filterProvider;
    if (isAllAccounts && (customTitle == null || customTitle == 'Account Reports')) {
      // Don't set default status - let users see all data by default
      // If status is already set, keep it; otherwise show all statuses
      debugPrint('üìä [ACCOUNT REPORTS] Default status: All (showing all statuses)');
    }
    
    // Set default type to 'Expenses' and status to 'Approved' for Expense Report only
    if (isExpenseReportOnly) {
      debugPrint('üîç [DEBUG] _buildDashboardContent - isExpenseReportOnly: true, _isExpenseReportMode: $_isExpenseReportMode');
      // Set expense report mode flag immediately (not in post-frame callback)
      if (!_isExpenseReportMode) {
        debugPrint('‚úÖ [DEBUG] Setting _isExpenseReportMode to TRUE');
        setState(() {
          _isExpenseReportMode = true;
        });
        // Reload data with expense report mode enabled
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            debugPrint('üîÑ [DEBUG] Reloading financial data with expense report mode');
            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
          }
        });
      } else {
        debugPrint('‚ÑπÔ∏è  [DEBUG] _isExpenseReportMode already TRUE');
      }
      
      final filterProvider = _filterProvider;
      if (filterProvider.selectedType != 'Expenses') {
        WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
            // Temporarily remove listener to prevent infinite loop
            filterProvider.removeListener(_onFilterChanged);
            filterProvider.setType('Expenses');
            // Re-add listener after modification
            filterProvider.addListener(_onFilterChanged);
            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
            _applyFilters();
          }
        });
      }
      // Set default status to 'Approved' for Expense Report only
      // Track it in _selectedStatusSet so we know it was set by expense report
      if (filterProvider.selectedStatus == null && _selectedStatusSet.isEmpty) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            // Temporarily remove listener to prevent infinite loop
            filterProvider.removeListener(_onFilterChanged);
            filterProvider.setStatus('Approved');
            // Re-add listener after modification
            filterProvider.addListener(_onFilterChanged);
            setState(() {
              _selectedStatusSet.add('Approved'); // Track that this was set by expense report
            });
            _applyFilters();
          }
        });
      } else if (filterProvider.selectedStatus == 'Approved' && !_selectedStatusSet.contains('Approved')) {
        // If status is already 'Approved' but not tracked, track it now
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {
              _selectedStatusSet.add('Approved');
            });
          }
        });
      }
    } else {
      // Reset expense report mode flag when not in expense report
      if (_isExpenseReportMode) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {
              _isExpenseReportMode = false;
            });
          }
        });
      }
    }
    
    // Load accounts if All Accounts view
    if (isAllAccounts && _allAccountsList.isEmpty && !_isLoadingAccounts) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
        _loadAccountsList();
        }
      });
    }
    
    // For Account Reports: Ensure data is loaded on first open
    if (isAllAccounts && (customTitle == null || customTitle == 'Account Reports')) {
      final bool isAccountReports = _selectedItem == NavItem.accountReports;
      // Trigger load if:
      // 1. We're on Account Reports screen
      // 2. Data is empty OR not yet loaded
      // 3. Not currently loading
      // 4. Not already initializing
      // 5. Post-frame callback not already scheduled
      if (isAccountReports && 
          !_isLoadingFinancialData && 
          !_isInitializingAccountReports &&
          !_accountReportsCallbackScheduled) {
        // Check if we need to load data
        // Don't trigger if account filter was just changed (it will trigger its own load)
        final bool needsDataLoad = _allData.isEmpty || !_accountReportsDataLoaded;
        final bool accountFilterJustChanged = _selectedAccountFilterId != null && _accountReportsDataLoaded == false;
        
        if (needsDataLoad && !accountFilterJustChanged) {
          // Mark callback as scheduled to prevent multiple callbacks
          _accountReportsCallbackScheduled = true;
          
        WidgetsBinding.instance.addPostFrameCallback((_) {
            // Reset callback flag when callback executes
            _accountReportsCallbackScheduled = false;
            
          if (mounted && 
              !_isLoadingFinancialData && 
                !_isInitializingAccountReports &&
                _selectedAccountFilterId == null) { // Only trigger for "All Accounts" view
              debugPrint('üìä [ACCOUNT REPORTS] Triggering initial data load...');
              debugPrint('   _allData.isEmpty: ${_allData.isEmpty}');
              debugPrint('   _accountReportsDataLoaded: $_accountReportsDataLoaded');
            // Set initialization flag to prevent multiple concurrent loads
            _isInitializingAccountReports = true;
            _loadFinancialData(forceRefresh: true, isSelfWallet: false);
          }
        });
        }
      }
    }
    
    return SingleChildScrollView(
      padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 20 : 24)),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Top Bar
          _buildFinancialTopBar(
            isMobile: isMobile,
            isTablet: isTablet,
            isSelfWallet: isSelfWallet,
            customTitle: customTitle,
            isAllAccounts: isAllAccounts,
            isExpenseReportOnly: isExpenseReportOnly,
          ),
          SizedBox(height: isMobile ? 20 : 28),

          // Financial Cards
          _buildFinancialCards(isMobile, isTablet, isAllAccounts: isAllAccounts),
          // Account Filter (only for All Account Reports)
          if (isAllAccounts && (customTitle == null || customTitle == 'Account Reports')) ...[
            SizedBox(height: isMobile ? 16 : 20),
            Builder(
              builder: (context) {
                // Ensure accounts are loaded when Account Reports is opened
                if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
                  WidgetsBinding.instance.addPostFrameCallback((_) {
                    if (mounted) {
                      _loadAccountsList();
                    }
                  });
                }
                return _buildAccountFilterDropdown(isMobile, isTablet);
              },
            ),
          ],
          SizedBox(height: isMobile ? 20 : 28),

          // Date Range Picker
          _buildDateRangePicker(isMobile, isTablet, isSelfWallet: isSelfWallet, customTitle: customTitle, isAllAccounts: isAllAccounts, isExpenseReportOnly: isExpenseReportOnly),
          SizedBox(height: isMobile ? 20 : 28),

          // Filter Breakdown Section (hidden in All Accounts report)
          if (!isAllAccounts) ...[
          _buildFilterBreakdown(
            isMobile,
            isTablet,
            isSelfWallet: isSelfWallet,
            isAllAccounts: isAllAccounts,
            isExpenseReportOnly: isExpenseReportOnly,
          ),
          SizedBox(height: isMobile ? 20 : 28),
          ],

          // Table Filters
          _buildTableFilters(
            isMobile,
            isTablet,
            isSelfWallet: isSelfWallet,
            isAllAccounts: isAllAccounts,
            isExpenseReportOnly: isExpenseReportOnly,
          ),
          SizedBox(height: isMobile ? 12 : 20),

          // Showing Indicator & Actions
          _buildShowingIndicator(
            isMobile,
            isTablet,
            enableExport: !(isSelfWallet && customTitle == null) && customTitle != 'Wallet Report',
          ),
          SizedBox(height: isMobile ? 12 : 20),

          // Data Table
          _buildFinancialDataTable(isMobile, isTablet, isAllAccounts: isAllAccounts),
        ],
      ),
    );
  }

  Widget _buildFinancialTopBar({
    required bool isMobile,
    required bool isTablet,
    bool isSelfWallet = false,
    String? customTitle,
    bool isAllAccounts = false,
    bool isExpenseReportOnly = false,
  }) {
    final horizontalPadding = isMobile ? 10.0 : (isTablet ? 18.0 : 22.0);
    final verticalPadding = isMobile ? 12.0 : (isTablet ? 16.0 : 18.0);
    final spacing = isMobile ? 10.0 : (isTablet ? 16.0 : 20.0);

    final GoRouter? router = GoRouter.maybeOf(context);
    final NavigatorState navigator = Navigator.of(context);
    final bool canPop = router?.canPop() ?? navigator.canPop();
    final bool showBackButton = false; // Back button removed for Self Wallet
    // Get selected account name if account filter is active
    String? selectedAccountName;
    if (isAllAccounts && _selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty) {
      try {
        final selectedAccount = _allAccountsList.firstWhere(
          (account) {
            final accountId = (account['id'] ?? account['_id'])?.toString();
            return accountId == _selectedAccountFilterId;
          },
          orElse: () => <String, dynamic>{},
        );
        if (selectedAccount.isNotEmpty) {
          selectedAccountName = (selectedAccount['name'] ?? selectedAccount['modeName'] ?? '').toString();
        }
      } catch (e) {
        // Ignore error, just don't show account name
      }
    }
    
    final titleText = isAllAccounts
        ? (selectedAccountName != null && selectedAccountName.isNotEmpty
            ? 'Account Reports - $selectedAccountName'
            : (customTitle ?? 'Account Reports'))
        : (customTitle == 'Wallet Report' 
        ? 'All Wallet Report' 
            : (customTitle ?? (isSelfWallet ? 'Self Wallet' : 'Super Admin Dashboard')));

    final title = Text(
      titleText,
      style: AppTheme.headingLarge.copyWith(
        fontSize: isMobile ? 24 : (isTablet ? 26 : 28),
        fontWeight: FontWeight.bold,
      ),
    );

    final buttonRow = _buildDashboardActionButtons(
      isMobile: isMobile,
      isTablet: isTablet,
      alignment: isMobile ? WrapAlignment.start : WrapAlignment.end,
    );

    // Action buttons for All Accounts, Self Wallet, All Wallet Report, and Expense Report views
    final bool isAllWalletReport = (customTitle == 'Wallet Report' && _selectedItem == NavItem.walletOverview);
    final bool isAllUserWallets = _selectedItem == NavItem.walletAll;
    final bool showActionButtons = (isAllAccounts && (customTitle == null || customTitle == 'Account Reports')) ||
        (isSelfWallet && (customTitle == null || customTitle == 'Wallet Report')) ||
        isAllWalletReport ||
        isAllUserWallets ||
        isExpenseReportOnly;
    
    // For All Account Reports: Only Add Amount and Withdraw
    // For Self Wallet and All Wallet Report: All 5 buttons
    // For Expense Report: Only Add Expenses button
    // For All User Wallets: Use new permission-based buttons
    final bool isWalletView = (isSelfWallet && (customTitle == null || customTitle == 'Wallet Report')) || isAllWalletReport || isAllUserWallets;
    
    final Widget? actionButtons = showActionButtons
        ? Row(
            mainAxisSize: isMobile && isSelfWallet ? MainAxisSize.max : MainAxisSize.min,
            mainAxisAlignment: isMobile && isSelfWallet ? MainAxisAlignment.end : MainAxisAlignment.start,
            children: [
              // For Expense Report: Only show Add Expenses button
              if (isExpenseReportOnly) ...[
                // Add Expenses button
                Container(
                  decoration: BoxDecoration(
                    color: AppTheme.warningColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: _showNewAddExpensesDialog,
                      borderRadius: BorderRadius.circular(12),
                      child: Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 8 : 10,
                          vertical: isMobile ? 4 : 6,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              decoration: BoxDecoration(
                                color: AppTheme.warningColor,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(
                                Icons.receipt_long,
                                size: 12,
                                color: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 5),
                            Text(
                              isMobile ? 'Expenses' : 'Add Expenses',
                              style: TextStyle(
                                color: AppTheme.warningColor,
                                fontWeight: FontWeight.w600,
                                fontSize: isMobile ? 11 : 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ] else ...[
              // Add Amount button (hidden for Self Wallet and All Wallet Report)
              // For All User Wallets: Check permission _canAddAmountAll
              if (isAllUserWallets && _canAddAmountAll) ...[
                Container(
                  decoration: BoxDecoration(
                    color: AppTheme.primaryColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: _showNewAddAmountDialog,
                      borderRadius: BorderRadius.circular(12),
                      child: Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 8 : 10,
                          vertical: isMobile ? 4 : 6,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              decoration: BoxDecoration(
                                color: AppTheme.primaryColor,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(
                                Icons.add,
                                size: 12,
                                color: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 5),
                            Text(
                              isMobile ? 'Add' : 'Add Amount',
                              style: TextStyle(
                                color: AppTheme.primaryColor,
                                fontWeight: FontWeight.w600,
                                fontSize: isMobile ? 11 : 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 6),
              ] else if (!isSelfWallet && !isAllWalletReport) ...[
                Container(
                  decoration: BoxDecoration(
                    color: AppTheme.primaryColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: _showNewAddAmountDialog,
                      borderRadius: BorderRadius.circular(12),
                      child: Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 8 : 10,
                          vertical: isMobile ? 4 : 6,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              decoration: BoxDecoration(
                                color: AppTheme.primaryColor,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(
                                Icons.add,
                                size: 12,
                                color: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 5),
                            Text(
                              isMobile ? 'Add' : 'Add Amount',
                              style: TextStyle(
                                color: AppTheme.primaryColor,
                                fontWeight: FontWeight.w600,
                                fontSize: isMobile ? 11 : 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 6),
              ],
              // Withdraw button (hidden for Self Wallet and All Wallet Report)
              // For All User Wallets: Check permission _canWithdrawAll
              if (isAllUserWallets && _canWithdrawAll) ...[
                Container(
                  decoration: BoxDecoration(
                    color: AppTheme.errorColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: _showNewWithdrawDialog,
                      borderRadius: BorderRadius.circular(12),
                      child: Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 8 : 10,
                          vertical: isMobile ? 4 : 6,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              decoration: BoxDecoration(
                                color: AppTheme.errorColor,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(
                                Icons.remove,
                                size: 12,
                                color: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 5),
                            Text(
                              'Withdraw',
                              style: TextStyle(
                                color: AppTheme.errorColor,
                                fontWeight: FontWeight.w600,
                                fontSize: isMobile ? 11 : 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 6),
              ] else if (!isSelfWallet && !isAllWalletReport) ...[
                Container(
                  decoration: BoxDecoration(
                    color: AppTheme.errorColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: _showNewWithdrawDialog,
                      borderRadius: BorderRadius.circular(12),
                      child: Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 8 : 10,
                          vertical: isMobile ? 4 : 6,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              decoration: BoxDecoration(
                                color: AppTheme.errorColor,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(
                                Icons.remove,
                                size: 12,
                                color: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 5),
                            Text(
                              'Withdraw',
                              style: TextStyle(
                                color: AppTheme.errorColor,
                                fontWeight: FontWeight.w600,
                                fontSize: isMobile ? 11 : 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ],
              // Only show Expenses, Collection, and Transaction buttons for Wallet views
              if (isWalletView) ...[
                // Add spacing only if previous buttons were shown (not Self Wallet, but not for All Wallet Report)
                // For All User Wallets: add spacing if Add Amount or Withdraw buttons were shown
                if (isAllUserWallets && (_canAddAmountAll || _canWithdrawAll)) SizedBox(width: isMobile ? 4 : 6)
                else if (!isSelfWallet && !isAllWalletReport) SizedBox(width: isMobile ? 4 : 6),
                // Mobile: Use icon-only buttons with tooltips, Desktop: Full buttons with text
                if (isMobile)
                  Align(
                    alignment: Alignment.centerRight,
                    child: Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      alignment: WrapAlignment.end,
                      children: [
                      // Add Expenses button - check permission based on view
                      // For All User Wallets: use _canAddExpenseAll, otherwise use _canCreateExpenses
                      if ((isAllUserWallets && _canAddExpenseAll) || (!isAllUserWallets && _canCreateExpenses))
                        Tooltip(
                          message: 'Add Expenses',
                          child: Material(
                            color: Colors.transparent,
                            child: InkWell(
                              onTap: _showNewAddExpensesDialog,
                              borderRadius: BorderRadius.circular(12),
                              child: Container(
                                width: 44,
                                height: 44,
                                decoration: BoxDecoration(
                                  color: AppTheme.warningColor.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(
                                    color: AppTheme.warningColor.withOpacity(0.3),
                                    width: 1,
                                  ),
                                ),
                                child: Icon(
                                  Icons.receipt_long,
                                  size: 20,
                                  color: AppTheme.warningColor,
                                ),
                              ),
                            ),
                          ),
                        ),
                      // Add Collection button - check permission based on view
                      // For All User Wallets: use _canAddCollectionAll, otherwise use _canCreateCollection
                      if ((isAllUserWallets && _canAddCollectionAll) || (!isAllUserWallets && _canCreateCollection))
                        Tooltip(
                          message: 'Add Collection',
                          child: Material(
                            color: Colors.transparent,
                            child: InkWell(
                              onTap: _showNewAddCollectionDialog,
                              borderRadius: BorderRadius.circular(12),
                              child: Container(
                                width: 44,
                                height: 44,
                                decoration: BoxDecoration(
                                  color: AppTheme.secondaryColor.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(
                                    color: AppTheme.secondaryColor.withOpacity(0.3),
                                    width: 1,
                                  ),
                                ),
                                child: Icon(
                                  Icons.payments,
                                  size: 20,
                                  color: AppTheme.secondaryColor,
                                ),
                              ),
                            ),
                          ),
                        ),
                      // Add Transaction button - check permission based on view
                      // For All User Wallets: use _canAddTransactionAll, otherwise use _canCreateTransaction
                      if ((isAllUserWallets && _canAddTransactionAll) || (!isAllUserWallets && _canCreateTransaction))
                        Tooltip(
                          message: 'Add Transaction',
                          child: Material(
                            color: Colors.transparent,
                            child: InkWell(
                              onTap: _showNewAddTransactionDialog,
                              borderRadius: BorderRadius.circular(12),
                              child: Container(
                                width: 44,
                                height: 44,
                                decoration: BoxDecoration(
                                  color: AppTheme.accentBlue.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(
                                    color: AppTheme.accentBlue.withOpacity(0.3),
                                    width: 1,
                                  ),
                                ),
                                child: Icon(
                                  Icons.swap_horizontal_circle,
                                  size: 20,
                                  color: AppTheme.accentBlue,
                                ),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  )
                else ...[
                  // Desktop: Full buttons with text
                // Add Expenses button - check permission based on view
                // For All User Wallets: use _canAddExpenseAll, otherwise use _canCreateExpenses
                if ((isAllUserWallets && _canAddExpenseAll) || (!isAllUserWallets && _canCreateExpenses))
                  Container(
                    decoration: BoxDecoration(
                      color: AppTheme.warningColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: _showNewAddExpensesDialog,
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 10,
                              vertical: 6,
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Container(
                                width: 16,
                                height: 16,
                                decoration: BoxDecoration(
                                  color: AppTheme.warningColor,
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.receipt_long,
                                  size: 12,
                                  color: Colors.white,
                                ),
                              ),
                              const SizedBox(width: 5),
                              Text(
                                  'Add Expenses',
                                style: TextStyle(
                                  color: AppTheme.warningColor,
                                  fontWeight: FontWeight.w600,
                                    fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                if ((isAllUserWallets && _canAddExpenseAll) || (!isAllUserWallets && _canCreateExpenses)) const SizedBox(width: 6),
                // Add Collection button - check permission based on view
                // For All User Wallets: use _canAddCollectionAll, otherwise use _canCreateCollection
                if ((isAllUserWallets && _canAddCollectionAll) || (!isAllUserWallets && _canCreateCollection))
                  Container(
                    decoration: BoxDecoration(
                      color: AppTheme.secondaryColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: _showNewAddCollectionDialog,
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 10,
                              vertical: 6,
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Container(
                                width: 16,
                                height: 16,
                                decoration: BoxDecoration(
                                  color: AppTheme.secondaryColor,
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.payments,
                                  size: 12,
                                  color: Colors.white,
                                ),
                              ),
                              const SizedBox(width: 5),
                              Text(
                                  'Add Collection',
                                style: TextStyle(
                                  color: AppTheme.secondaryColor,
                                  fontWeight: FontWeight.w600,
                                    fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                if (((isAllUserWallets && _canAddCollectionAll) || (!isAllUserWallets && _canCreateCollection)) && 
                    ((isAllUserWallets && _canAddTransactionAll) || (!isAllUserWallets && _canCreateTransaction))) const SizedBox(width: 6),
                // Add Transaction button - check permission based on view
                // For All User Wallets: use _canAddTransactionAll, otherwise use _canCreateTransaction
                if ((isAllUserWallets && _canAddTransactionAll) || (!isAllUserWallets && _canCreateTransaction))
                  Container(
                    decoration: BoxDecoration(
                      color: AppTheme.accentBlue.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: _showNewAddTransactionDialog,
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 10,
                              vertical: 6,
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Container(
                                width: 16,
                                height: 16,
                                decoration: BoxDecoration(
                                  color: AppTheme.accentBlue,
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.swap_horizontal_circle,
                                  size: 12,
                                  color: Colors.white,
                                ),
                              ),
                              const SizedBox(width: 5),
                              Text(
                                  'Add Transaction',
                                style: TextStyle(
                                  color: AppTheme.accentBlue,
                                  fontWeight: FontWeight.w600,
                                    fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
                ],
              ],
            ],
          )
        : null;

    final showUserDropdown = customTitle == 'Wallet Report';
    final dropdownSpacing = isMobile ? 12.0 : (isTablet ? 14.0 : 16.0);

    final headerCard = Container(
      width: double.infinity,
      padding: EdgeInsets.symmetric(
        horizontal: horizontalPadding,
        vertical: verticalPadding,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: AppTheme.borderColor.withOpacity(0.8)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 18,
            offset: const Offset(0, 8),
          ),
          BoxShadow(
            color: Colors.black.withOpacity(0.02),
            blurRadius: 4,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: (!isMobile && !isTablet && actionButtons != null) || (isMobile && isSelfWallet && actionButtons != null)
            ? MainAxisAlignment.spaceBetween 
            : MainAxisAlignment.start,
        children: [
          if (showBackButton) ...[
            IconButton(
              onPressed: () {
                if (router != null && router.canPop()) {
                  router.pop();
                } else if (navigator.canPop()) {
                  navigator.pop();
                }
              },
              icon: const Icon(Icons.arrow_back_ios_new_rounded),
              color: AppTheme.textPrimary,
            ),
            SizedBox(width: spacing),
          ],
          Flexible(child: title),
          if (actionButtons != null) ...[
            if (!isMobile && !isTablet) ...[
              Spacer(),
            ] else if (isMobile && isSelfWallet) ...[
              // For mobile Self Wallet, let icons float to the right without spacing
            ] else ...[
              SizedBox(width: isMobile ? 6 : spacing),
            ],
            // For mobile Self Wallet, don't wrap in Flexible to prevent shrinking
            isMobile && isSelfWallet ? actionButtons : Flexible(child: actionButtons),
          ],
          // Hide standard dashboard buttons when All Accounts custom buttons are shown
          if (actionButtons == null) ...[
          SizedBox(width: spacing),
          Flexible(child: buttonRow),
          ],
        ],
      ),
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        headerCard,
      ],
    );
  }

  Future<void> _loadAccountsList() async {
    if (_isLoadingAccounts || !mounted) return;
    
    try {
    setState(() {
      _isLoadingAccounts = true;
        _hasAccountLoadError = false;
        _accountLoadErrorMessage = null;
      });
    } catch (_) {
      // Widget disposed, ignore
      return;
    }
    
    try {
      final result = await PaymentModeService.getPaymentModes();
      if (!mounted) {
        return;
      }

      try {
        setState(() {
          if (result['success'] == true) {
            final List<dynamic> paymentModesRaw = result['paymentModes'] as List<dynamic>? ?? [];
            
            // Map backend payment modes to account list
            _allAccountsList = paymentModesRaw
                .map<Map<String, dynamic>?>((mode) {
                  try {
                    final modeMap = Map<String, dynamic>.from(mode as Map);
                    final assignedReceiver = modeMap['assignedReceiver'];
                    final receiverName = assignedReceiver is Map
                        ? (assignedReceiver['name'] ?? 'Unknown')
                        : (assignedReceiver is String ? assignedReceiver : 'Unknown');
                    
                    return {
                      'id': modeMap['_id'] ?? modeMap['id'],
                      '_id': modeMap['_id'] ?? modeMap['id'],
                      'name': modeMap['modeName'] ?? '',
                      'modeName': modeMap['modeName'] ?? '',
                      'description': modeMap['description'] ?? '',
                      'mode': _extractModeFromName(modeMap['modeName'] ?? ''),
                      'autoPay': modeMap['autoPay'] ?? false,
                      'isActive': modeMap['isActive'] ?? true,
                      'assignedReceiver': receiverName,
                    };
                  } catch (e) {
                    debugPrint('Error mapping payment mode: $e');
                    return null;
                  }
                })
                .whereType<Map<String, dynamic>>()
                .where((account) => account['isActive'] == true)
                .toList();
            
            debugPrint('Loaded ${_allAccountsList.length} active accounts');
            _hasAccountLoadError = false;
            // Load recent accounts from storage
            _loadRecentAccounts();
          } else {
          _allAccountsList = [];
            final errorMsg = result['message'] ?? 'Unknown error';
            debugPrint('Failed to load accounts: $errorMsg');
            _hasAccountLoadError = true;
            _accountLoadErrorMessage = errorMsg;
            
            // Show error to user
            if (mounted) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Failed to load accounts: $errorMsg'),
                      backgroundColor: AppTheme.errorColor,
                      duration: const Duration(seconds: 3),
                      action: SnackBarAction(
                        label: 'Retry',
                        textColor: Colors.white,
                        onPressed: () {
                          _loadAccountsList();
                        },
                      ),
                    ),
                  );
                }
              });
            }
          }
          _isLoadingAccounts = false;
        });
      } catch (setStateError) {
        // Widget disposed, ignore
        debugPrint('setState error (widget disposed): $setStateError');
        return;
      }
    } catch (e) {
      if (!mounted) {
        return;
      }
      try {
        setState(() {
          _allAccountsList = [];
          _isLoadingAccounts = false;
          _hasAccountLoadError = true;
          _accountLoadErrorMessage = e.toString();
        });
      } catch (_) {
        // Widget disposed, ignore
        return;
      }
      debugPrint('Error loading accounts: $e');
      if (mounted) {
        try {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to load accounts: ${e.toString()}'),
              backgroundColor: AppTheme.errorColor,
              duration: const Duration(seconds: 3),
              action: SnackBarAction(
                label: 'Retry',
                textColor: Colors.white,
                onPressed: () {
                  _loadAccountsList();
                },
              ),
            ),
          );
        } catch (_) {
          // Context invalid, ignore
        }
      }
    }
  }

  // Helper: Extract mode type from mode name
  String _extractModeFromName(String name) {
    final lowerName = name.toLowerCase();
    if (lowerName.contains('cash')) return 'Cash';
    if (lowerName.contains('upi')) return 'UPI';
    if (lowerName.contains('bank')) return 'Bank';
    return 'Cash'; // Default
  }

  // Helper: Get account suggestions based on search text
  List<Map<String, dynamic>> _getAccountSuggestions(String searchText) {
    if (searchText.isEmpty) {
      // Return all accounts with recently used first
      return _getPrioritizedAccounts();
    }
    
    final lowerSearch = searchText.toLowerCase();
    return _allAccountsList.where((account) {
      final name = (account['name'] ?? account['modeName'] ?? '').toString().toLowerCase();
      final mode = (account['mode'] ?? '').toString().toLowerCase();
      final description = (account['description'] ?? '').toString().toLowerCase();
      final receiver = (account['assignedReceiver'] ?? '').toString().toLowerCase();
      
      return name.contains(lowerSearch) ||
             mode.contains(lowerSearch) ||
             description.contains(lowerSearch) ||
             receiver.contains(lowerSearch);
    }).toList();
  }

  // Helper: Get prioritized accounts (recent first, then others alphabetically)
  List<Map<String, dynamic>> _getPrioritizedAccounts() {
    // Separate recent and other accounts
    final recent = <Map<String, dynamic>>[];
    final others = <Map<String, dynamic>>[];
    
    for (var account in _allAccountsList) {
      final accountId = (account['id'] ?? account['_id'])?.toString() ?? '';
      if (_recentAccountIds.contains(accountId)) {
        recent.add(account);
      } else {
        others.add(account);
      }
    }
    
    // Sort recent by usage order, others alphabetically
    recent.sort((a, b) {
      final aId = (a['id'] ?? a['_id'])?.toString() ?? '';
      final bId = (b['id'] ?? b['_id'])?.toString() ?? '';
      final aIndex = _recentAccountIds.indexOf(aId);
      final bIndex = _recentAccountIds.indexOf(bId);
      return aIndex.compareTo(bIndex);
    });
    
    others.sort((a, b) {
      final aName = (a['name'] ?? a['modeName'] ?? '').toString();
      final bName = (b['name'] ?? b['modeName'] ?? '').toString();
      return aName.toLowerCase().compareTo(bName.toLowerCase());
    });
    
    return [...recent, ...others];
  }

  // Helper: Update recent accounts list
  void _updateRecentAccounts(String? accountId) {
    if (accountId == null || accountId.isEmpty) return;
    
    // Remove if exists, then add to front
    _recentAccountIds.remove(accountId);
    _recentAccountIds.insert(0, accountId);
    
    // Keep only last 5 recent accounts
    if (_recentAccountIds.length > 5) {
      _recentAccountIds = _recentAccountIds.take(5).toList();
    }
    
    // Save to SharedPreferences for persistence
    _saveRecentAccounts();
  }

  // Helper: Load recent accounts from SharedPreferences
  Future<void> _loadRecentAccounts() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final recentIds = prefs.getStringList('recent_account_ids') ?? [];
      if (mounted) {
        setState(() {
          _recentAccountIds = recentIds;
        });
      }
    } catch (e) {
      debugPrint('Error loading recent accounts: $e');
    }
  }

  // Helper: Save recent accounts to SharedPreferences
  Future<void> _saveRecentAccounts() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setStringList('recent_account_ids', _recentAccountIds);
    } catch (e) {
      debugPrint('Error saving recent accounts: $e');
    }
  }

  Widget _buildAccountFilterDropdown(bool isMobile, bool isTablet) {
    final dropdownWidth = isMobile ? double.infinity : 300.0;

    // Loading state
    if (_isLoadingAccounts) {
      return SizedBox(
        width: dropdownWidth,
        child: Container(
          padding: EdgeInsets.all(isMobile ? 12 : 16),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: AppTheme.borderColor),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              const SizedBox(width: 12),
              Flexible(
                child: Text(
                  'Loading accounts...',
                  style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Error state
    if (_hasAccountLoadError) {
      return SizedBox(
        width: dropdownWidth,
        child: Container(
          padding: EdgeInsets.all(isMobile ? 12 : 16),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: AppTheme.errorColor.withOpacity(0.5)),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.error_outline,
                    color: AppTheme.errorColor,
                    size: 20,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Failed to load accounts',
                      style: AppTheme.bodyMedium.copyWith(
                        color: AppTheme.errorColor,
                        fontWeight: FontWeight.w600,
                      ),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  ),
                ],
              ),
              if (_accountLoadErrorMessage != null && _accountLoadErrorMessage!.isNotEmpty) ...[
                const SizedBox(height: 4),
                Text(
                  _accountLoadErrorMessage!,
                  style: AppTheme.bodySmall.copyWith(
                    color: AppTheme.textSecondary,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
              const SizedBox(height: 8),
              TextButton.icon(
                onPressed: () {
                  _loadAccountsList();
                },
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('Retry'),
                style: TextButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Empty state
    if (_allAccountsList.isEmpty && !_isLoadingAccounts && !_hasAccountLoadError) {
      return SizedBox(
        width: dropdownWidth,
        child: Container(
          padding: EdgeInsets.all(isMobile ? 12 : 16),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: AppTheme.borderColor),
          ),
          child: Row(
            children: [
              Icon(
                Icons.info_outline,
                color: AppTheme.textSecondary,
                size: 20,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  'No accounts available',
                  style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Get prioritized accounts for dropdown
    final prioritizedAccounts = _getPrioritizedAccounts();

    // Get display text for selected account
    String displayText = 'All Accounts';
    if (_selectedAccountFilterId != null && _selectedAccountFilterId!.isNotEmpty) {
      final selectedAccount = prioritizedAccounts.firstWhere(
        (account) {
          final id = (account['id'] ?? account['_id'])?.toString() ?? '';
          return id == _selectedAccountFilterId;
        },
        orElse: () => <String, dynamic>{},
      );
      if (selectedAccount.isNotEmpty) {
        displayText = (selectedAccount['name'] ?? selectedAccount['modeName'] ?? 'Unknown Account').toString();
      }
    }
    
    // Calculate button height for proper menu offset
    final double buttonHeight = isMobile ? 56.0 : 56.0;
    final Offset menuOffset = Offset(0, buttonHeight + 4);

    return SizedBox(
      width: dropdownWidth,
      child: Material(
        elevation: 8,
        color: Colors.transparent,
        shadowColor: Colors.transparent,
        child: PopupMenuButton<String?>(
          offset: menuOffset, // Position menu at bottom of button
          elevation: 8,
          shadowColor: Colors.black.withOpacity(0.08),
          surfaceTintColor: Colors.transparent,
          color: Colors.white,
          constraints: BoxConstraints(
            minWidth: dropdownWidth,
            maxWidth: dropdownWidth,
            maxHeight: 300,
          ),
          shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
          onSelected: (String? value) {
            // Special constant for "All Accounts"
            const String allAccountsValue = 'all_accounts';
            
            final accountId = value;
            
            // Normalize: convert "all_accounts" or null or empty string to null
            final normalizedAccountId = (accountId == null || accountId.isEmpty || accountId == allAccountsValue) 
                ? null 
                : accountId;
            
            // Normalize existing selection for comparison
            final normalizedSelectedId = (_selectedAccountFilterId?.isEmpty ?? true) 
                ? null 
                : _selectedAccountFilterId;
            
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            debugPrint('üîç [ACCOUNT REPORTS] Account Selected in Dropdown:');
            debugPrint('   Timestamp: ${DateTime.now().toIso8601String()}');
            debugPrint('   Raw value from dropdown: "$accountId"');
            debugPrint('   Normalized accountId: $normalizedAccountId');
            debugPrint('   Previous _selectedAccountFilterId: "$_selectedAccountFilterId"');
            debugPrint('   Normalized previous: $normalizedSelectedId');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Prevent infinite loop: Don't reload if same account is selected
            if (normalizedSelectedId == normalizedAccountId) {
              debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Same account selected, skipping reload');
              return;
            }
            
            // Prevent infinite loop: Don't reload if already loading
            if (_isLoadingFinancialData || _isInitializingAccountReports) {
              debugPrint('‚ö†Ô∏è  [ACCOUNT REPORTS] Already loading, skipping reload');
              return;
            }
            
            final accountName = normalizedAccountId != null
                ? prioritizedAccounts.firstWhere(
                    (account) {
                      final id = (account['id'] ?? account['_id'])?.toString() ?? '';
                      return id == normalizedAccountId;
                    },
                    orElse: () => <String, dynamic>{},
                  )['name']?.toString() ?? 'Unknown'
                : 'All Accounts';
            
            debugPrint('   Selected accountName: $accountName');
            debugPrint('   _isLoadingFinancialData: $_isLoadingFinancialData');
            debugPrint('   _isInitializingAccountReports: $_isInitializingAccountReports');
            debugPrint('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            setState(() {
              _selectedAccountFilterId = normalizedAccountId; // Store normalized value (null for "All Accounts")
              _accountReportsDataLoaded = false; // Reset flag
              _accountReportsCallbackScheduled = true; // Prevent post-frame callback from triggering
            });
            
            debugPrint('‚úÖ [ACCOUNT REPORTS] Account filter set: "$_selectedAccountFilterId"');
            
            // Update recent accounts if an account was selected (not "All Accounts")
            if (normalizedAccountId != null && normalizedAccountId.isNotEmpty) {
              _updateRecentAccounts(normalizedAccountId);
            }
            
            // Reload data with new filter
            debugPrint('üîÑ [ACCOUNT REPORTS] Calling _loadFinancialData with:');
            debugPrint('   forceRefresh: true');
            debugPrint('   isSelfWallet: ${_selectedItem == NavItem.walletSelf}');
            debugPrint('   _selectedAccountFilterId: "$_selectedAccountFilterId"');
            debugPrint('   isAllAccounts: ${_selectedAccountFilterId == null}');
            _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
          },
          itemBuilder: (context) {
            const String allAccountsValue = 'all_accounts';
            
            return [
          // First item: "All Accounts" option
              PopupMenuItem<String?>(
                value: allAccountsValue, // Use constant instead of null for better reliability
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                child: Row(
                  children: [
                    if (_selectedAccountFilterId == null)
                      Icon(
                        Icons.check,
                        size: 18,
                        color: AppTheme.primaryColor,
                      )
                    else
                      const SizedBox(width: 18),
                    if (_selectedAccountFilterId == null) const SizedBox(width: 8),
                    const Expanded(
            child: Text('All Accounts'),
                    ),
                  ],
                ),
          ),
          // Then all accounts
          ...prioritizedAccounts.map((account) {
            final accountId = (account['id'] ?? account['_id'])?.toString() ?? '';
                    final accountName = (account['name'] ?? account['modeName'] ?? 'Unknown Account').toString();
            final isRecent = accountId.isNotEmpty && _recentAccountIds.contains(accountId);
                final isSelected = accountId == _selectedAccountFilterId;
            
                return PopupMenuItem<String?>(
              value: accountId,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                        child: Row(
                          children: [
                      if (isSelected)
                        Icon(
                          Icons.check,
                          size: 18,
                          color: AppTheme.primaryColor,
                        )
                      else
                        const SizedBox(width: 18),
                      if (isSelected) const SizedBox(width: 8),
                            Expanded(
                                        child: Text(
                                          accountName,
                                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                            fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                          ),
                                        ),
                                      ),
                                      if (isRecent) ...[
                                        const SizedBox(width: 8),
                                        Container(
                                          padding: const EdgeInsets.symmetric(
                                            horizontal: 6,
                                            vertical: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: AppTheme.secondaryColor.withOpacity(0.1),
                                            borderRadius: BorderRadius.circular(4),
                                          ),
                                          child: Text(
                                            'Recent',
                                            style: AppTheme.bodySmall.copyWith(
                                              fontSize: 10,
                                              color: AppTheme.secondaryColor,
                                              fontWeight: FontWeight.w600,
                                            ),
                                          ),
                                        ),
                                      ],
                ],
              ),
            );
          }).toList(),
            ];
          },
          // Child: Button that looks exactly like DropdownButtonFormField
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: 'Filter by Account',
              hintText: 'Select an account',
              prefixIcon: const Icon(Icons.account_balance_wallet_outlined),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              suffixIcon: const Icon(Icons.arrow_drop_down),
            ),
            isFocused: false,
            isEmpty: false,
            child: Text(
              displayText,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
      ),
    );
  }


  Widget _buildUserFilterDropdown(bool isMobile, bool isTablet) {
    if (_isLoadingUsers) {
      return SizedBox(
        height: 40,
        child: Align(
          alignment: Alignment.centerLeft,
          child: SizedBox(
            width: 20,
            height: 20,
            child: const CircularProgressIndicator(strokeWidth: 2),
          ),
        ),
      );
    }

    final filterProvider = _filterProvider;
    final dropdownWidth = isMobile ? double.infinity : 200.0;
    final bool hasOptions = _userOptions.isNotEmpty;
    final List<String> selectedLabels = filterProvider.selectedUserDisplayLabels.values
        .where((label) => label.trim().isNotEmpty)
        .toList(growable: false);
    final int selectionCount = selectedLabels.length;
    final bool hasSelection = selectionCount > 0;
    String displayLabel = 'All Users';
    if (selectionCount == 1) {
      displayLabel = selectedLabels.first;
    } else if (selectionCount > 1) {
      displayLabel = '$selectionCount users selected';
    }
    final bool isInteractive = hasOptions || hasSelection;

    final InputDecoration decoration = InputDecoration(
      labelText: 'Filter by user',
      filled: true,
      fillColor: Colors.white,
      enabled: isInteractive,
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      contentPadding: EdgeInsets.symmetric(
        horizontal: isMobile ? 12 : 16,
        vertical: isMobile ? 12 : 14,
      ),
      suffixIcon: const Icon(Icons.arrow_drop_down),
    );

    return SizedBox(
      width: dropdownWidth,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(12),
          onTap: isInteractive
              ? () => _showUserSelectionDialog(
                    isMobile: isMobile,
                    isTablet: isTablet,
                  )
              : null,
          child: InputDecorator(
            decoration: decoration,
            isEmpty: false,
            child: Padding(
              padding: EdgeInsets.symmetric(
                vertical: isMobile ? 2 : 4,
              ),
              child: Text(
                displayLabel,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: AppTheme.bodyMedium.copyWith(
                  fontWeight: FontWeight.w600,
                  color: isInteractive
                      ? AppTheme.textPrimary
                      : AppTheme.textSecondary.withOpacity(0.6),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildUserStatusDropdown(bool isMobile, bool isTablet) {
    final dropdownWidth = isMobile ? double.infinity : 200.0;
    final List<String> statusOptions = ['All', 'Active', 'Inactive'];

    final filterProvider = _filterProvider;
    final currentValue = filterProvider.selectedUserStatus != null && statusOptions.contains(filterProvider.selectedUserStatus)
        ? filterProvider.selectedUserStatus
        : 'All';
    
    // Calculate button height for proper menu offset
    final double buttonHeight = isMobile ? 56.0 : 56.0;
    
    // Calculate offset to position menu at bottom of button with small gap
    final Offset menuOffset = Offset(0, buttonHeight + 4);
    
    return SizedBox(
      width: dropdownWidth,
      child: Material(
        elevation: 8,
        color: Colors.transparent,
        shadowColor: Colors.transparent,
        child: PopupMenuButton<String>(
          offset: menuOffset, // Position menu at bottom of button
          elevation: 8,
          shadowColor: Colors.black.withOpacity(0.08),
          surfaceTintColor: Colors.transparent,
          color: Colors.white,
          constraints: BoxConstraints(
            minWidth: dropdownWidth,
            maxWidth: dropdownWidth,
            maxHeight: 300, // Limit dropdown menu height to prevent overflow
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12), // Match button border radius
          ),
          onSelected: (String? newValue) {
            if (newValue != null) {
              filterProvider.setUserStatus(newValue);
              _applyFilters();
            }
          },
          itemBuilder: (context) {
            return statusOptions.map<PopupMenuEntry<String>>((String status) {
              final isSelected = (status == 'All' && currentValue == 'All') || 
                                 (status != 'All' && status == currentValue);
              
              return PopupMenuItem<String>(
                value: status,
                padding: EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                child: Row(
                  children: [
                    if (isSelected)
                      Icon(
                        Icons.check,
                        size: 18,
                        color: AppTheme.primaryColor,
                      )
                    else
                      const SizedBox(width: 18),
                    if (isSelected) const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        status,
                        style: AppTheme.bodyMedium.copyWith(
                          fontWeight: FontWeight.w600,
                          color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                        ),
                      ),
                    ),
                  ],
                ),
              );
            }).toList();
          },
          // Child: Button that looks exactly like DropdownButtonFormField
          child: InputDecorator(
        decoration: InputDecoration(
          labelText: 'Status',
          filled: true,
          fillColor: Colors.white,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          contentPadding: EdgeInsets.symmetric(
            horizontal: isMobile ? 12 : 16,
            vertical: isMobile ? 12 : 14,
          ),
              suffixIcon: const Icon(Icons.arrow_drop_down),
        ),
            isFocused: false,
            isEmpty: false,
            child: Text(
              currentValue,
              style: AppTheme.bodyMedium.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _showUserSelectionDialog({
    required bool isMobile,
    required bool isTablet,
  }) async {
    final filterProvider = _filterProvider;
    final bool hasSelection = filterProvider.selectedUserIds.isNotEmpty || _selectedUserLabelMatchers.isNotEmpty;
    if (_userOptions.isEmpty && !hasSelection) {
      return;
    }

    final TextEditingController searchController = TextEditingController();
    final List<Map<String, String>> sourceOptions =
        _userOptions.map((option) => Map<String, String>.from(option)).toList();

    for (final id in filterProvider.selectedUserIds) {
      final bool alreadyExists = sourceOptions.any((option) => option['id'] == id);
      if (!alreadyExists) {
        final String label = filterProvider.selectedUserDisplayLabels[id] ?? id;
        sourceOptions.insert(0, {'id': id, 'label': label});
      }
    }

    List<Map<String, String>> filteredOptions =
        List<Map<String, String>>.from(sourceOptions);

    final Map<String, String> idToLabel = {
      for (final option in sourceOptions)
        if ((option['id'] ?? '').isNotEmpty)
          option['id']!: (option['label'] ?? option['id']!)
    };

    final Map<String, String> idToRole = {};
    for (final option in sourceOptions) {
      final String id = (option['id'] ?? '').trim();
      if (id.isEmpty) {
        continue;
      }
      String role = (option['role'] ?? '').trim();
      if (role.isEmpty) {
        final String label = (option['label'] ?? '').trim();
        final int separatorIndex = label.indexOf('-');
        if (separatorIndex > 0) {
          role = label.substring(0, separatorIndex).trim();
        }
      }
      if (role.isNotEmpty) {
        idToRole[id] = role;
      }
    }

    final Map<String, Set<String>> roleToIds = {};
    idToRole.forEach((id, role) {
      final String normalizedRole = role.trim().isEmpty ? 'Others' : role.trim();
      roleToIds.putIfAbsent(normalizedRole, () => <String>{}).add(id);
    });

    if (roleToIds.isEmpty && sourceOptions.isNotEmpty) {
      roleToIds['Users'] = sourceOptions
          .map((option) => option['id'] ?? '')
          .where((id) => id.isNotEmpty)
          .toSet();
    }

    final List<String> roleOrder = roleToIds.keys.toList()
      ..sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));

    final Set<String> tempSelectedIds = {...filterProvider.selectedUserIds};

    Map<String, dynamic>? result;

    try {
      result = await showDialog<Map<String, dynamic>>(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return StatefulBuilder(
            builder: (context, setDialogState) {

              void handleSearch(String query) {
                final String normalized = query.trim().toLowerCase();
                setDialogState(() {
                  if (normalized.isEmpty) {
                    filteredOptions = List<Map<String, String>>.from(sourceOptions);
                  } else {
                    filteredOptions = sourceOptions.where((option) {
                      final String label = (option['label'] ?? '').toLowerCase();
                      final String id = (option['id'] ?? '').toLowerCase();
                      final String role = (option['role'] ?? '').toLowerCase();
                      return label.contains(normalized) ||
                          id.contains(normalized) ||
                          role.contains(normalized);
                    }).map<Map<String, String>>(
                      (option) => Map<String, String>.from(option),
                    ).toList();
                  }
                });
              }

              void toggleRole(String role, bool select) {
                final Set<String> roleIds = roleToIds[role] ?? <String>{};
                setDialogState(() {
                  if (select) {
                    tempSelectedIds.addAll(roleIds);
                  } else {
                    tempSelectedIds.removeWhere(roleIds.contains);
                  }
                });
              }

              bool isRoleFullySelected(String role) {
                final Set<String> roleIds = roleToIds[role] ?? <String>{};
                if (roleIds.isEmpty) return false;
                return roleIds.every(tempSelectedIds.contains);
              }

              bool isRolePartiallySelected(String role) {
                final Set<String> roleIds = roleToIds[role] ?? <String>{};
                if (roleIds.isEmpty) return false;
                final bool anySelected = roleIds.any(tempSelectedIds.contains);
                return anySelected && !isRoleFullySelected(role);
              }

              void toggleUser(String id, bool select) {
                setDialogState(() {
                  if (select) {
                    tempSelectedIds.add(id);
                  } else {
                    tempSelectedIds.remove(id);
                  }
                });
              }

              final double listHeight = isMobile ? 280 : 320;

              return AlertDialog(
                backgroundColor: Colors.white,
                contentPadding: EdgeInsets.zero,
                insetPadding: EdgeInsets.symmetric(
                  horizontal: isMobile ? 16 : 40,
                  vertical: 24,
                ),
                content: SizedBox(
                  width: isMobile ? double.maxFinite : 460,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: double.infinity,
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 16 : 20,
                          vertical: isMobile ? 14 : 16,
                        ),
                        decoration: BoxDecoration(
                          color: AppTheme.primaryColor.withOpacity(0.08),
                          borderRadius: const BorderRadius.vertical(
                            top: Radius.circular(20),
                          ),
                        ),
                        child: Text(
                          'Filter by user',
                          style: AppTheme.headingSmall.copyWith(
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                      ),
                      Padding(
                        padding: EdgeInsets.fromLTRB(
                          isMobile ? 16 : 20,
                          16,
                          isMobile ? 16 : 20,
                          0,
                        ),
                        child: TextField(
                          controller: searchController,
                          autofocus: true,
                          decoration: InputDecoration(
                            prefixIcon: const Icon(Icons.search),
                            hintText: 'Type to search users...',
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                          ),
                          onChanged: handleSearch,
                        ),
                      ),
                      if (tempSelectedIds.isNotEmpty) ...[
                        const SizedBox(height: 12),
                        Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: isMobile ? 16 : 20,
                          ),
                          child: Align(
                            alignment: Alignment.centerLeft,
                            child: Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: tempSelectedIds.map((id) {
                                final String label =
                                    idToLabel[id] ?? filterProvider.selectedUserDisplayLabels[id] ?? id;
                                return InputChip(
                                  label: Text(label),
                                  onDeleted: () {
                                    toggleUser(id, false);
                                  },
                                );
                              }).toList(),
                            ),
                          ),
                        ),
                      ],
                      if (roleOrder.isNotEmpty) ...[
                        const SizedBox(height: 12),
                        Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: isMobile ? 16 : 20,
                          ),
                          child: Align(
                            alignment: Alignment.centerLeft,
                            child: Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: roleOrder.map((role) {
                                final bool fullySelected = isRoleFullySelected(role);
                                final bool partiallySelected = isRolePartiallySelected(role);
                                return FilterChip(
                                  label: Text(
                                    roleToIds[role] != null
                                        ? '$role (${roleToIds[role]!.length})'
                                        : role,
                                  ),
                                  selected: fullySelected,
                                  showCheckmark: true,
                                  avatar: partiallySelected
                                      ? Icon(
                                          Icons.remove,
                                          size: 16,
                                          color: AppTheme.primaryColor,
                                        )
                                      : null,
                                  onSelected: (value) => toggleRole(role, value),
                                );
                              }).toList(),
                            ),
                          ),
                        ),
                      ],
                      const SizedBox(height: 12),
                      Divider(height: 1, color: AppTheme.borderColor),
                      SizedBox(
                        height: listHeight,
                        child: filteredOptions.isEmpty
                            ? Center(
                                child: Text(
                                  'No users found',
                                  style: AppTheme.bodyMedium.copyWith(
                                    color: AppTheme.textSecondary,
                                  ),
                                ),
                              )
                            : ListView.separated(
                                padding: EdgeInsets.symmetric(
                                  vertical: 8,
                                  horizontal: isMobile ? 8 : 12,
                                ),
                                itemBuilder: (context, index) {
                                  final Map<String, String> option = filteredOptions[index];
                                  final String id = (option['id'] ?? '').trim();
                                  if (id.isEmpty) {
                                    return const SizedBox.shrink();
                                  }
                                  final String label =
                                      (option['label'] ?? id).trim();
                                  final String role =
                                      (option['role'] ?? '').trim();
                                  final bool isSelected = tempSelectedIds.contains(id);

                                  return CheckboxListTile(
                                    value: isSelected,
                                    onChanged: (checked) {
                                      toggleUser(id, checked ?? false);
                                    },
                                    title: Text(
                                      label,
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                      style: AppTheme.bodyMedium.copyWith(
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    subtitle: role.isNotEmpty ? Text(role) : null,
                                    secondary: Icon(
                                      Icons.person_outline,
                                      color: isSelected
                                          ? AppTheme.primaryColor
                                          : AppTheme.textSecondary,
                                    ),
                                    controlAffinity: ListTileControlAffinity.trailing,
                                  );
                                },
                                separatorBuilder: (context, index) =>
                                    const SizedBox(height: 4),
                                itemCount: filteredOptions.length,
                              ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: EdgeInsets.symmetric(
                          horizontal: isMobile ? 12 : 20,
                          vertical: 10,
                        ),
                        child: Row(
                          children: [
                            TextButton(
                              onPressed: () {
                                setDialogState(() {
                                  tempSelectedIds.clear();
                                });
                              },
                              child: const Text('Clear All'),
                            ),
                            const Spacer(),
                            TextButton(
                              onPressed: () => Navigator.of(context).pop(),
                              child: const Text('Cancel'),
                            ),
                            const SizedBox(width: 8),
                            FilledButton(
                              onPressed: () {
                                final List<Map<String, String>> selections =
                                    tempSelectedIds.map((id) {
                                  final String label =
                                      idToLabel[id] ?? filterProvider.selectedUserDisplayLabels[id] ?? id;
                                  return {
                                    'id': id,
                                    'label': label,
                                    if (idToRole[id]?.isNotEmpty == true)
                                      'role': idToRole[id]!,
                                  };
                                }).toList();
                                Navigator.of(context).pop({
                                  'selectedOptions': selections,
                                });
                              },
                              child: const Text('Apply'),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          );
        },
      );
    } finally {
      searchController.dispose();
    }

    if (!mounted || result == null) {
      return;
    }

    final List<dynamic> selectedOptionsDynamic =
        result['selectedOptions'] as List<dynamic>? ?? [];

    final Set<String> nextSelectedIds = <String>{};
    final Map<String, String> nextDisplayLabels = <String, String>{};
    final Set<String> nextLabelMatchers = <String>{};

    for (final dynamic option in selectedOptionsDynamic) {
      if (option is Map) {
        final Map<String, dynamic> optionMap = Map<String, dynamic>.from(option);
        final String id = optionMap['id']?.toString() ?? '';
        final String label = optionMap['label']?.toString() ?? id;
        if (id.isNotEmpty) {
          nextSelectedIds.add(id);
          if (label.isNotEmpty) {
            nextDisplayLabels[id] = label;
            nextLabelMatchers.add(label.toLowerCase());
          } else {
            nextDisplayLabels[id] = id;
          }
        } else if (label.isNotEmpty) {
          final String labelKey = _labelOnlyKey(label);
          nextDisplayLabels[labelKey] = label;
          nextLabelMatchers.add(label.toLowerCase());
        }
      }
    }

    filterProvider.setSelectedUsers(nextSelectedIds, labels: nextDisplayLabels);
    setState(() {
      _selectedUserLabelMatchers
        ..clear()
        ..addAll(nextLabelMatchers);
    });
    _syncSelectedUserLabels();
    _applyFilters();
  }

  Widget _buildFinancialCards(bool isMobile, bool isTablet, {bool isAllAccounts = false}) {
    return Row(
      children: [
        Expanded(
          child: _buildFinancialCardOld(
            'Cash In',
            _formatAmount(_cashIn),
            Icons.arrow_downward,
            AppTheme.textSecondary,
            isMobile,
            isTablet,
            iconColor: AppTheme.secondaryColor,
          ),
        ),
        SizedBox(width: isMobile ? 4 : 16),
        Expanded(
          child: _buildFinancialCardOld(
            'Cash Out',
            _formatAmount(_cashOut),
            Icons.arrow_upward,
            AppTheme.textSecondary,
            isMobile,
            isTablet,
            iconColor: AppTheme.errorColor,
          ),
        ),
        SizedBox(width: isMobile ? 4 : 16),
        Expanded(
          child: _buildFinancialCardOld(
            'Balance',
            _formatAmount(_balance),
            Icons.account_balance_wallet,
            _balance >= 0 ? Colors.green : Colors.red,
            isMobile,
            isTablet,
          ),
        ),
      ],
    );
  }

  Widget _buildDashboardActionButtons({
    required bool isMobile,
    required bool isTablet,
    WrapAlignment alignment = WrapAlignment.end,
  }) {
    final spacing = isMobile ? 12.0 : (isTablet ? 14.0 : 16.0);
    final buttons = _dashboardActionButtonList(
      isMobile,
    );

    Alignment resolvedAlignment;
    switch (alignment) {
      case WrapAlignment.start:
        resolvedAlignment = Alignment.centerLeft;
        break;
      case WrapAlignment.center:
        resolvedAlignment = Alignment.center;
        break;
      case WrapAlignment.end:
      default:
        resolvedAlignment = Alignment.centerRight;
        break;
    }

    return Align(
      alignment: resolvedAlignment,
      child: FittedBox(
        fit: BoxFit.scaleDown,
        alignment: Alignment.centerRight,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (int i = 0; i < buttons.length; i++) ...[
              if (i > 0) SizedBox(width: spacing),
              buttons[i],
            ],
          ],
        ),
      ),
    );
  }

  List<Widget> _dashboardActionButtonList(bool isMobile) {
    final buttons = <Widget>[];

    buttons.addAll([
      _buildDashboardActionButton(
        label: 'Add Amount',
        icon: Icons.add_circle,
        color: AppTheme.primaryColor,
        onPressed: _openAddAmount,
        isMobile: isMobile,
      ),
      _buildDashboardActionButton(
        label: 'Withdraw',
        icon: Icons.remove_circle,
        color: AppTheme.errorColor,
        onPressed: _openWithdrawAmount,
        isMobile: isMobile,
      ),
      _buildDashboardActionButton(
        label: 'Add Expenses',
        icon: Icons.receipt_long,
        color: AppTheme.warningColor,
        onPressed: _openAddExpenses,
        isMobile: isMobile,
      ),
      _buildDashboardActionButton(
        label: 'Add Transaction',
        icon: Icons.swap_horizontal_circle,
        color: AppTheme.accentBlue,
        onPressed: _openAddTransaction,
        isMobile: isMobile,
      ),
      _buildDashboardActionButton(
        label: 'Add Collection',
        icon: Icons.payments,
        color: AppTheme.secondaryColor,
        onPressed: _openAddCollection,
        isMobile: isMobile,
      ),
    ]);

    return buttons;
  }

  Widget _buildDashboardActionButton({
    required String label,
    required IconData icon,
    required Color color,
    required VoidCallback onPressed,
    required bool isMobile,
  }) {
    final horizontalPadding = isMobile ? 14.0 : 18.0;
    final verticalPadding = isMobile ? 12.0 : 14.0;

    return ElevatedButton.icon(
      onPressed: onPressed,
      icon: Icon(icon, size: isMobile ? 16 : 18),
      label: Text(
        label,
        style: AppTheme.bodyMedium.copyWith(
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
      style: ElevatedButton.styleFrom(
        backgroundColor: color.withOpacity(0.12),
        foregroundColor: color,
        elevation: 0,
        padding: EdgeInsets.symmetric(
          horizontal: horizontalPadding,
          vertical: verticalPadding,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(999),
        ),
        textStyle: AppTheme.bodyMedium.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  // Cash In Card - Modern gradient style
  Widget _buildCashInCard(String amount, bool isMobile, bool isTablet) {
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 0.0, end: 1.0),
      duration: const Duration(milliseconds: 600),
      curve: Curves.easeOut,
      builder: (context, value, child) {
        return Transform.scale(
          scale: 0.95 + (0.05 * value),
          child: Opacity(
            opacity: value,
            child: Container(
              padding: EdgeInsets.all(isMobile ? 18 : (isTablet ? 20 : 24)),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [
                    Colors.green.shade50,
                    Colors.green.shade100.withOpacity(0.3),
                    Colors.white,
                  ],
                ),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: Colors.green.withOpacity(0.3),
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.green.withOpacity(0.2),
                    blurRadius: 12,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.15),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: const Icon(
                      Icons.arrow_downward,
                      color: Colors.green,
                      size: 24,
                    ),
                  ),
                  const SizedBox(height: 16),
          Text(
                    'Cash In',
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.textSecondary,
                      fontSize: isMobile ? 13 : 14,
                      fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Text(
                    amount,
                    style: AppTheme.headingMedium.copyWith(
                      fontSize: isMobile ? 22 : (isTablet ? 26 : 28),
                      fontWeight: FontWeight.bold,
                      color: Colors.green.shade700,
                      letterSpacing: 0.5,
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  // Cash Out Card - Border accent style
  Widget _buildCashOutCard(String amount, bool isMobile, bool isTablet) {
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 0.0, end: 1.0),
      duration: const Duration(milliseconds: 800),
      curve: Curves.easeOut,
      builder: (context, value, child) {
        return Transform.scale(
          scale: 0.95 + (0.05 * value),
          child: Opacity(
            opacity: value,
            child: Container(
              padding: EdgeInsets.all(isMobile ? 18 : (isTablet ? 20 : 24)),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(16),
                border: Border(
                  left: BorderSide(
                    color: Colors.red,
                    width: 4,
                  ),
                  top: BorderSide(color: AppTheme.borderColor),
                  right: BorderSide(color: AppTheme.borderColor),
                  bottom: BorderSide(color: AppTheme.borderColor),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.red.withOpacity(0.1),
                    blurRadius: 10,
                    offset: const Offset(0, 3),
                  ),
                ],
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Cash Out',
            style: AppTheme.bodyMedium.copyWith(
              color: AppTheme.textSecondary,
                            fontSize: isMobile ? 13 : 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(height: 12),
                        Text(
                          amount,
                          style: AppTheme.headingMedium.copyWith(
                            fontSize: isMobile ? 22 : (isTablet ? 26 : 28),
                            fontWeight: FontWeight.bold,
                            color: Colors.red.shade700,
                            letterSpacing: 0.5,
                          ),
                        ),
                      ],
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: const Icon(
                      Icons.arrow_upward,
                      color: Colors.red,
                      size: 24,
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
  // Balance Card - Premium centered style
  Widget _buildBalanceCard(String amount, bool isMobile, bool isTablet) {
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 0.0, end: 1.0),
      duration: const Duration(milliseconds: 1000),
      curve: Curves.easeOut,
      builder: (context, value, child) {
        return Transform.scale(
          scale: 0.95 + (0.05 * value),
          child: Opacity(
            opacity: value,
            child: Container(
              padding: EdgeInsets.all(isMobile ? 18 : (isTablet ? 20 : 24)),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: AppTheme.primaryColor.withOpacity(0.3),
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: AppTheme.primaryColor.withOpacity(0.15),
                    blurRadius: 15,
                    offset: const Offset(0, 5),
                    spreadRadius: 1,
                  ),
                ],
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: AppTheme.primaryColor.withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.account_balance_wallet,
                      color: AppTheme.primaryColor,
                      size: isMobile ? 28 : 32,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Balance',
                    style: AppTheme.bodyMedium.copyWith(
                      color: AppTheme.textSecondary,
                      fontSize: isMobile ? 13 : 14,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    amount,
                    style: AppTheme.headingMedium.copyWith(
                      fontSize: isMobile ? 22 : (isTablet ? 26 : 28),
                      fontWeight: FontWeight.bold,
                      color: AppTheme.primaryColor,
                      letterSpacing: 0.5,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildFinancialCardOld(
    String title,
    String amount,
    IconData icon,
    Color color,
    bool isMobile,
    bool isTablet, {
    Color? iconColor,
  }) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 10 : (isTablet ? 18 : 20)),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: AppTheme.borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
          Text(
                title,
                style: AppTheme.bodyMedium.copyWith(
                  color: AppTheme.textSecondary,
                  fontSize: isMobile ? 12 : 14,
                ),
              ),
              Icon(icon, color: iconColor ?? color, size: isMobile ? 16 : 24),
            ],
          ),
          SizedBox(height: isMobile ? 5 : 8),
          Text(
            amount,
            style: AppTheme.headingMedium.copyWith(
              fontSize: isMobile ? 17 : (isTablet ? 22 : 24),
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDashboardFinancialCard(
    String title,
    String amount,
    IconData icon,
    Color color,
    bool isMobile,
    bool isTablet, {
    Color? iconColor,
  }) {
    return Container(
      padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 18 : 20)),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: AppTheme.borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                title,
                style: AppTheme.bodyMedium.copyWith(
                  color: AppTheme.textSecondary,
                  fontSize: isMobile ? 13 : 14,
                ),
              ),
              Icon(icon, color: iconColor ?? color, size: isMobile ? 20 : 24),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            amount,
            style: AppTheme.headingMedium.copyWith(
              fontSize: isMobile ? 20 : (isTablet ? 22 : 24),
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDateRangePicker(bool isMobile, bool isTablet, {bool isSelfWallet = false, String? customTitle, bool isAllAccounts = false, bool isExpenseReportOnly = false}) {
    final isWalletReport = customTitle == 'Wallet Report';
    
    final filterContent = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        // User Filter Dropdown (only for Wallet Report, at the top)
        if (isWalletReport) ...[
          if (isMobile)
            Column(
              children: [
                _buildUserFilterDropdown(isMobile, isTablet),
                SizedBox(height: isMobile ? 12 : 16),
                _buildUserStatusDropdown(isMobile, isTablet),
              ],
            )
          else
            Row(
              children: [
                _buildUserFilterDropdown(isMobile, isTablet),
                SizedBox(width: 12),
                _buildUserStatusDropdown(isMobile, isTablet),
              ],
            ),
          SizedBox(height: isMobile ? 12 : 16),
        ],
        // TOP ROW: Date Inputs and Action Buttons
        if (isMobile)
          // Mobile: Stack vertically for better UX and to prevent overflow
          Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Date inputs - full width, stacked vertically
              _buildDateInput(
                _filterProvider.startDate,
                'From',
                () async {
                  final filterProvider = _filterProvider;
                  final DateTime? picked = await showDatePicker(
                    context: context,
                    initialDate: filterProvider.startDate ?? DateTime.now(),
                    firstDate: DateTime(2020),
                    lastDate: DateTime.now(),
                  );
                  if (picked != null) {
                    filterProvider.setDateRange(picked, filterProvider.endDate);
                    _applyFilters();
                  }
                },
                isMobile,
              ),
              const SizedBox(height: 10),
              _buildDateInput(
                _filterProvider.endDate,
                'To',
                () async {
                  final filterProvider = _filterProvider;
                  final DateTime? picked = await showDatePicker(
                    context: context,
                    initialDate: filterProvider.endDate ?? (filterProvider.startDate ?? DateTime.now()),
                    firstDate: filterProvider.startDate ?? DateTime(2020),
                    lastDate: DateTime.now(),
                  );
                  if (picked != null) {
                    filterProvider.setDateRange(filterProvider.startDate, picked);
                    _applyFilters();
                  }
                },
                isMobile,
              ),
              const SizedBox(height: 12),
              // Action buttons row - optimized for mobile
              Row(
                children: [
                  Expanded(
                    child: SizedBox(
                      height: 44,
                      child: ElevatedButton(
                        onPressed: () {
                          final filterProvider = _filterProvider;
                          filterProvider.setQuickRange(null);
                          _applyFilters();
                        },
                        style: ElevatedButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          textStyle: AppTheme.bodySmall.copyWith(
                            fontWeight: FontWeight.w600,
                            fontSize: 14,
                          ),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                        child: const Text('Apply'),
                      ),
                    ),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: SizedBox(
                      height: 44,
                      child: OutlinedButton(
                        onPressed: _clearFilters,
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          textStyle: AppTheme.bodySmall.copyWith(
                            fontWeight: FontWeight.w600,
                            fontSize: 14,
                          ),
                          side: BorderSide(color: AppTheme.borderColor.withOpacity(0.8)),
                          foregroundColor: AppTheme.textSecondary,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                        ),
                        child: const Text('Clear All'),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          )
        else
          // Desktop/Tablet: Keep horizontal layout
          Row(
            children: [
              _buildDateInputContainer(
                child: _buildDateInput(
                  _filterProvider.startDate,
                  'From',
                  () async {
                    final filterProvider = _filterProvider;
                    final DateTime? picked = await showDatePicker(
                      context: context,
                      initialDate: filterProvider.startDate ?? DateTime.now(),
                      firstDate: DateTime(2020),
                      lastDate: DateTime.now(),
                    );
                    if (picked != null) {
                      filterProvider.setDateRange(picked, filterProvider.endDate);
                      _applyFilters();
                    }
                  },
                  isMobile,
                ),
                isMobile: isMobile,
                isTablet: isTablet,
              ),
              const SizedBox(width: 8),
              _buildDateInputContainer(
                child: _buildDateInput(
                  _filterProvider.endDate,
                  'To',
                  () async {
                    final filterProvider = _filterProvider;
                    final DateTime? picked = await showDatePicker(
                      context: context,
                      initialDate: filterProvider.endDate ?? (filterProvider.startDate ?? DateTime.now()),
                      firstDate: filterProvider.startDate ?? DateTime(2020),
                      lastDate: DateTime.now(),
                    );
                    if (picked != null) {
                      filterProvider.setDateRange(filterProvider.startDate, picked);
                      _applyFilters();
                    }
                  },
                  isMobile,
                ),
                isMobile: isMobile,
                isTablet: isTablet,
              ),
              const SizedBox(width: 8),
              SizedBox(
                height: isMobile ? 34 : 36,
                child: ElevatedButton(
                  onPressed: () {
                    final filterProvider = _filterProvider;
                    filterProvider.setQuickRange(null);
                    _applyFilters();
                  },
                  style: ElevatedButton.styleFrom(
                    padding: EdgeInsets.symmetric(horizontal: isMobile ? 12 : 16, vertical: 0),
                    textStyle: AppTheme.bodySmall.copyWith(
                      fontWeight: FontWeight.w600,
                      fontSize: isMobile ? 12 : 13,
                    ),
                  ),
                  child: const Text('Apply'),
                ),
              ),
              const SizedBox(width: 8),
              SizedBox(
                height: isMobile ? 34 : 36,
                child: OutlinedButton(
                  onPressed: _clearFilters,
                  style: OutlinedButton.styleFrom(
                    padding: EdgeInsets.symmetric(horizontal: isMobile ? 12 : 16, vertical: 0),
                    textStyle: AppTheme.bodySmall.copyWith(
                      fontWeight: FontWeight.w600,
                      fontSize: isMobile ? 12 : 13,
                    ),
                    side: BorderSide(color: AppTheme.borderColor.withOpacity(0.8)),
                    foregroundColor: AppTheme.textSecondary,
                  ),
                  child: const Text('Clear All'),
                ),
              ),
            ],
          ),
        SizedBox(height: isMobile ? 12 : 8),
        // QUICK SELECT ROW: Standard Periods + Quarters
        // Mobile: Optimized layout (quick buttons in row, quarters in 2x2 grid), Desktop: Full width row
        LayoutBuilder(
          builder: (context, constraints) {
            final spacing = isMobile ? 6.0 : 12.0;
            final buttons = _buildAllQuickButtons(context, isMobile);

            if (isMobile) {
              // Mobile: Separate quick date buttons and quarter buttons for better layout
              final quickDateButtons = buttons.take(4).toList(); // First 4: This Month, Last Month, This FY, Previous FY
              final quarterButtons = buttons.skip(4).toList(); // Last 4: Q1, Q2, Q3, Q4

              return Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // Quick date buttons in a row
                  Wrap(
                    spacing: spacing,
                    runSpacing: spacing,
                    alignment: WrapAlignment.start,
                    children: quickDateButtons,
                  ),
                  SizedBox(height: spacing),
                  // Quarter buttons in 2x2 grid
                  Row(
                    children: [
                      Expanded(
                        child: Column(
                          children: [
                            quarterButtons[0],
                            SizedBox(height: spacing),
                            quarterButtons[2],
                          ],
                        ),
                      ),
                      SizedBox(width: spacing),
                      Expanded(
                        child: Column(
                          children: [
                            quarterButtons[1],
                            SizedBox(height: spacing),
                            quarterButtons[3],
                          ],
                        ),
                      ),
                    ],
                  ),
                ],
              );
            } else {
              // Desktop/Tablet: Keep original row layout
              return Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  for (final button in buttons)
                    Expanded(
                      child: Padding(
                        padding: EdgeInsets.symmetric(horizontal: spacing / 2),
                        child: button,
                      ),
                    ),
                ],
              );
            }
          },
        ),
        SizedBox(height: isMobile ? 12 : 16),
        // Mode selector (hidden for All Account Reports and Expense Report)
        if (!isAllAccounts && !isExpenseReportOnly)
        Align(
          alignment: Alignment.centerLeft,
          child: _buildModeSelector(isMobile, isTablet),
        ),
      ],
    );

    // Use collapsible container for Self Wallet and All Wallet Report (non-account, non-expense-report views)
    // This keeps Account Reports and pure Expense Report screens using the inline filters.
    final bool useCollapsibleContainer = !isAllAccounts && !isExpenseReportOnly;

    if (!useCollapsibleContainer) {
      return filterContent;
    }

    // Wrap in collapsible container (used by Self Wallet, All Wallet Report, etc.)
    final activeCount = _getActiveFilterCount();
    final summary = _getActiveFilterSummary();

    return Container(
      width: double.infinity,
      clipBehavior: Clip.none, // Allow dropdown menus to appear above this container
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: AppTheme.borderColor.withOpacity(0.8)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 18,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        children: [
          InkWell(
            onTap: () {
              if (!mounted) return;
              setState(() {
                _isFiltersExpanded = !_isFiltersExpanded;
              });
            },
            borderRadius: const BorderRadius.vertical(top: Radius.circular(18)),
            child: Container(
              padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 18 : 22)),
              child: Row(
                children: [
                  Icon(
                    Icons.filter_list,
                    color: AppTheme.primaryColor,
                    size: isMobile ? 20 : 24,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Filters',
                          style: AppTheme.headingSmall.copyWith(
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        if (!_isFiltersExpanded && activeCount > 0) ...[
                          const SizedBox(height: 4),
                          Text(
                            summary,
                            style: AppTheme.bodySmall.copyWith(
                              color: AppTheme.textSecondary,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ],
                    ),
                  ),
                  if (activeCount > 0)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: AppTheme.primaryColor.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        '$activeCount',
                        style: AppTheme.bodySmall.copyWith(
                          color: AppTheme.primaryColor,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                    ),
                  const SizedBox(width: 8),
                  AnimatedRotation(
                    turns: _isFiltersExpanded ? 0.5 : 0,
                    duration: const Duration(milliseconds: 200),
                    child: Icon(
                      Icons.expand_more,
                      color: AppTheme.textSecondary,
                    ),
                  ),
                ],
              ),
            ),
          ),
          if (_isFiltersExpanded)
            Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Divider(height: 1),
                Padding(
                  padding: EdgeInsets.all(isMobile ? 12 : (isTablet ? 18 : 22)),
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      // Validate constraints to prevent assertion errors
                      final maxWidth = constraints.maxWidth;
                      // For SizedBox, if constraints are invalid, just don't set width (use default behavior)
                      if (maxWidth.isFinite && maxWidth > 0) {
                        return SizedBox(
                          width: maxWidth,
                          child: filterContent,
                        );
                      } else {
                        // If constraints are invalid, return content without width constraint
                        return filterContent;
                      }
                    },
                  ),
                ),
              ],
            ),
        ],
      ),
    );
  }

  Widget _buildDateInputContainer({
    required Widget child,
    required bool isMobile,
    required bool isTablet,
  }) {
    if (isMobile) {
      return Expanded(child: child);
    }

    final double targetWidth = isTablet ? 300 : 340;

    return SizedBox(
      width: targetWidth,
      child: child,
    );
  }

  Widget _buildDateInput(DateTime? date, String label, VoidCallback onTap, bool isMobile) {
    final bool hasDate = date != null;
    final String displayText = hasDate ? DateFormat('dd MMM yyyy').format(date!) : 'Select date';

    return InkWell(
      onTap: onTap,
      child: Container(
        constraints: BoxConstraints(minHeight: isMobile ? 44 : 46),
        padding: EdgeInsets.symmetric(horizontal: isMobile ? 14 : 16, vertical: isMobile ? 12 : 10),
        decoration: BoxDecoration(
          color: AppTheme.surfaceColor,
          borderRadius: BorderRadius.circular(isMobile ? 12 : 16),
          border: Border.all(color: AppTheme.borderColor.withOpacity(0.9)),
        ),
        child: Row(
          children: [
            Icon(Icons.calendar_today, size: isMobile ? 16 : 16, color: AppTheme.textSecondary),
            SizedBox(width: isMobile ? 10 : 8),
            // Show label on mobile too for clarity when stacked vertically
            Text(
              label,
              style: AppTheme.bodySmall.copyWith(
                fontWeight: FontWeight.w600,
                fontSize: isMobile ? 12 : 13,
                color: AppTheme.textSecondary,
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: Text(
                displayText,
                style: AppTheme.bodySmall.copyWith(
                  fontWeight: FontWeight.w500,
                  fontSize: isMobile ? 13 : 13,
                  color: hasDate ? AppTheme.textPrimary : AppTheme.textMuted,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
                textAlign: TextAlign.end,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildQuickDateButton(
    BuildContext context,
    String label,
    String key,
    VoidCallback onTap,
    bool isMobile,
  ) {
    final filterProvider = _filterProvider;
    final bool isSelected = filterProvider.selectedQuickRange == key;
    final ColorScheme colorScheme = Theme.of(context).colorScheme;
    return _PillIconButton(
      label: label,
      onTap: onTap,
      isSelected: isSelected,
      isCompact: isMobile,
      leadingIcon: Icons.calendar_today,
      trailingIcon: isSelected ? Icons.close_rounded : null,
      selectedGradientColors: [
        AppTheme.primaryColor,
        AppTheme.primaryColor.withOpacity(0.8),
      ],
      unselectedBackgroundColor: AppTheme.surfaceColor,
      borderColor: isSelected ? AppTheme.primaryColor : AppTheme.borderColor,
      textStyle: AppTheme.bodySmall.copyWith(
        fontSize: isMobile ? 11 : 12,
        fontWeight: FontWeight.w700,
        color: isSelected ? colorScheme.onPrimary : AppTheme.textPrimary,
      ),
      iconColor: isSelected ? colorScheme.onPrimary : AppTheme.primaryColor,
    );
  }

  Widget _buildQuarterButton(String label, String tooltip, int quarter, bool isMobile) {
    final filterProvider = _filterProvider;
    final isSelected = filterProvider.selectedQuarter == quarter;
    
    return Tooltip(
      message: tooltip,
      child: InkWell(
        onTap: () => _setQuarterRange(quarter),
        borderRadius: BorderRadius.circular(isMobile ? 10 : 8),
        child: Container(
          width: isMobile ? double.infinity : null,
          padding: EdgeInsets.symmetric(
            horizontal: isMobile ? 12 : 6, 
            vertical: isMobile ? 10 : 6
          ),
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: isSelected ? AppTheme.primaryColor.withOpacity(0.15) : AppTheme.surfaceColor,
            borderRadius: BorderRadius.circular(isMobile ? 10 : 8),
            border: Border.all(
              color: isSelected ? AppTheme.primaryColor : AppTheme.borderColor,
              width: isMobile ? 1.5 : 1,
            ),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            softWrap: false,
            overflow: TextOverflow.ellipsis,
            style: AppTheme.bodySmall.copyWith(
              fontSize: isMobile ? 11 : 11,
              fontWeight: FontWeight.w700,
              color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
            ),
          ),
        ),
      ),
    );
  }

  void _setQuarterRange(int quarter) {
    final filterProvider = _filterProvider;
    final now = DateTime.now();
    final currentYear = now.year;
    final currentMonth = now.month;

    if (!_quarterConfig.containsKey(quarter)) return;

    final financialYearBase = currentMonth >= 4 ? currentYear : currentYear - 1;
    DateTimeRange range = _computeQuarterDateRange(quarter, financialYearBase);

    // Intelligent year navigation: if the quarter is in the future, use previous year
    if (range.start.isAfter(DateTime(now.year, now.month, now.day))) {
      range = _computeQuarterDateRange(quarter, financialYearBase - 1);
    }

    filterProvider.setDateRange(range.start, range.end);
    filterProvider.setQuickRange(null, quarter: quarter);
    _applyFilters();
  }

  DateTimeRange _computeQuarterDateRange(int quarter, int financialYearBase) {
    final config = _quarterConfig[quarter];
    if (config == null) {
      final fallbackDate = DateTime(financialYearBase, 1, 1);
      return DateTimeRange(start: fallbackDate, end: fallbackDate);
    }

    final startYear = financialYearBase + config['yearOffset']!;
    final start = DateTime(startYear, config['startMonth']!, 1);
    final end = DateTime(startYear, config['endMonth']! + 1, 1).subtract(const Duration(days: 1));

    return DateTimeRange(start: start, end: end);
  }

  void _setQuickDateRange(String period) {
    final filterProvider = _filterProvider;
    final now = DateTime.now();
    DateTime start, end;

    switch (period) {
      case 'thisMonth':
        start = DateTime(now.year, now.month, 1);
        end = now;
        break;
      case 'lastMonth':
        final lastMonth = DateTime(now.year, now.month - 1);
        start = DateTime(lastMonth.year, lastMonth.month, 1);
        end = DateTime(now.year, now.month, 0);
        break;
      case 'thisFinancialYear':
        // Assuming financial year starts in April (month 4)
        if (now.month >= 4) {
          start = DateTime(now.year, 4, 1);
        } else {
          start = DateTime(now.year - 1, 4, 1);
        }
        end = now;
        break; 
      case 'lastFinancialYear':
        // Assuming financial year starts in April (month 4)
        if (now.month >= 4) {
          start = DateTime(now.year - 1, 4, 1);
          end = DateTime(now.year, 3, 31);
        } else {
          start = DateTime(now.year - 2, 4, 1);
          end = DateTime(now.year - 1, 3, 31);
        }
        break;
      case 'previousFinancialYear':
        // Previous Financial Year - goes back one year from current FY
        // If current year is 2025, this will show 2024 FY data
        if (now.month >= 4) {
          // Current FY is now.year (April now.year to March now.year+1)
          // Previous FY is now.year-1 (April now.year-1 to March now.year)
          start = DateTime(now.year - 1, 4, 1);
          end = DateTime(now.year, 3, 31);
        } else {
          // Current FY is now.year-1 (April now.year-1 to March now.year)
          // Previous FY is now.year-2 (April now.year-2 to March now.year-1)
          start = DateTime(now.year - 2, 4, 1);
          end = DateTime(now.year - 1, 3, 31);
        }
        break;
      default:
        return;
    }

    filterProvider.setDateRange(start, end);
    filterProvider.setQuickRange(period);
    _applyFilters();
  }

  bool _hasPendingApprovals() {
    return _getPendingApprovalCount('Expenses', 'Unapproved') > 0 ||
        _getPendingApprovalCount('Transactions', 'Unapproved') > 0 ||
        _getPendingApprovalCount('Collections', 'Unaccounted') > 0;
  }

  int _getPendingApprovalCount(String categoryKey, String statusKey) {
    final category = _filterBreakdown[categoryKey];
    if (category == null) return 0;
    final status = category[statusKey];
    if (status == null) return 0;
    final count = status['count'];
    if (count is int) return count;
    if (count is num) return count.toInt();
    return 0;
  }

  void _applyPendingApprovalsQuickFilter() {
    final hasPending = _hasPendingApprovals();

    if (!hasPending) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No pending approvals found.'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    final filterProvider = _filterProvider;
    setState(() {
      _pendingApprovalsMode = true;
      filterProvider.setType(null);
      filterProvider.setStatus(null);
      _selectedStatusSet.clear();
    });

    _applyFilters();
  }

  bool _hasFlaggedRecords() {
    return _getPendingApprovalCount('Expenses', 'Flagged') > 0 ||
        _getPendingApprovalCount('Transactions', 'Flagged') > 0 ||
        _getPendingApprovalCount('Collections', 'Flagged') > 0;
  }

  bool _isFlaggedQuickFilterActive() {
    if (_selectedStatusSet.contains('Flagged')) {
      return true;
    }
    final filterProvider = _filterProvider;
    if (filterProvider.selectedStatus == 'Flagged' && _selectedStatusSet.isEmpty) {
      return true;
    }
    return false;
  }

  void _applyFlaggedQuickFilter() {
    final filterProvider = _filterProvider;
    final hasFlagged = _hasFlaggedRecords();
    final isActive = _isFlaggedQuickFilterActive();

    if (!hasFlagged && !isActive) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No flagged records found.'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    setState(() {
      if (isActive) {
        _selectedStatusSet.remove('Flagged');
        if (filterProvider.selectedStatus == 'Flagged') {
          filterProvider.setStatus(null);
        }
      } else {
        if (filterProvider.selectedStatus != null && filterProvider.selectedStatus != 'Flagged') {
          _selectedStatusSet.add(filterProvider.selectedStatus!);
          filterProvider.setStatus(null);
        }
        _selectedStatusSet.add('Flagged');
      }
      _pendingApprovalsMode = false;
    });

    _applyFilters();
  }
  Widget _buildFilterBreakdown(bool isMobile, bool isTablet, {bool isSelfWallet = false, bool isAllAccounts = false, bool isExpenseReportOnly = false}) {
    final filterProvider = _filterProvider;
    final hasFilterSelection = _pendingApprovalsMode ||
        filterProvider.selectedType != null ||
        filterProvider.selectedStatus != null ||
        _selectedStatusSet.isNotEmpty ||
        filterProvider.selectedQuickRange != null ||
        filterProvider.selectedQuarter != null ||
        filterProvider.startDate != null ||
        filterProvider.endDate != null;
    final bool hasPendingApprovals = _hasPendingApprovals();
    final bool hasFlaggedRecords = _hasFlaggedRecords();
    final bool isFlaggedActive = _isFlaggedQuickFilterActive();

    final breakdownContent = Container(
      padding: EdgeInsets.all(isMobile ? 14 : (isTablet ? 18 : 24)),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Colors.white,
            AppTheme.surfaceColor.withOpacity(0.9),
          ],
        ),
        borderRadius: BorderRadius.circular(isMobile ? 16 : 20),
        border: Border.all(color: AppTheme.borderColor.withOpacity(0.6)),
        boxShadow: const [
          BoxShadow(
            color: Color(0x140F172A),
            blurRadius: 18,
            offset: Offset(0, 12),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          isMobile
              ? Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Filter breakdown',
                      style: AppTheme.headingMedium.copyWith(
                        fontSize: 16,
                        fontWeight: FontWeight.w700,
                        letterSpacing: 0.6,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 6,
                      runSpacing: 6,
                      children: [
                        if (isSelfWallet) ...[
                          ElevatedButton.icon(
                            onPressed: (hasFlaggedRecords || isFlaggedActive) ? _applyFlaggedQuickFilter : null,
                            icon: Icon(
                              Icons.flag_outlined,
                              size: 12,
                            ),
                            label: Text(
                              'Flagged',
                              style: AppTheme.bodySmall.copyWith(
                                fontWeight: FontWeight.w600,
                                fontSize: 10,
                              ),
                            ),
                            style: ButtonStyle(
                              elevation: MaterialStateProperty.all(0),
                              backgroundColor: MaterialStateProperty.resolveWith((states) {
                                if (states.contains(MaterialState.disabled)) {
                                  return AppTheme.surfaceColor.withOpacity(0.4);
                                }
                                if (states.contains(MaterialState.pressed) || states.contains(MaterialState.hovered)) {
                                  return AppTheme.warningColor.withOpacity(0.22);
                                }
                                if (isFlaggedActive) {
                                  return AppTheme.warningColor.withOpacity(0.22);
                                }
                                return AppTheme.warningColor.withOpacity(0.12);
                              }),
                              foregroundColor: MaterialStateProperty.resolveWith((states) {
                                if (states.contains(MaterialState.disabled)) {
                                  return AppTheme.textMuted;
                                }
                                return AppTheme.warningColor;
                              }),
                              overlayColor: MaterialStateProperty.all(AppTheme.warningColor.withOpacity(0.18)),
                              padding: MaterialStateProperty.all(
                                const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 4,
                                ),
                              ),
                              shape: MaterialStateProperty.all(
                                RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: BorderSide(
                                    color: AppTheme.warningColor.withOpacity(isFlaggedActive ? 0.6 : 0.4),
                                  ),
                                ),
                              ),
                              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            ),
                          ),
                          ElevatedButton.icon(
                            onPressed: hasPendingApprovals ? _applyPendingApprovalsQuickFilter : null,
                            icon: Icon(
                              Icons.hourglass_bottom,
                              size: 12,
                            ),
                            label: Text(
                              'Smart',
                              style: AppTheme.bodySmall.copyWith(
                                fontWeight: FontWeight.w600,
                                fontSize: 10,
                              ),
                            ),
                            style: ButtonStyle(
                              elevation: MaterialStateProperty.all(0),
                              backgroundColor: MaterialStateProperty.resolveWith((states) {
                                if (states.contains(MaterialState.disabled)) {
                                  return AppTheme.surfaceColor.withOpacity(0.4);
                                }
                                if (states.contains(MaterialState.hovered) || states.contains(MaterialState.pressed)) {
                                  return AppTheme.warningColor.withOpacity(0.18);
                                }
                                return AppTheme.warningColor.withOpacity(0.12);
                              }),
                              foregroundColor: MaterialStateProperty.resolveWith((states) {
                                if (states.contains(MaterialState.disabled)) {
                                  return AppTheme.textMuted;
                                }
                                return AppTheme.warningColor;
                              }),
                              overlayColor: MaterialStateProperty.all(AppTheme.warningColor.withOpacity(0.18)),
                              padding: MaterialStateProperty.all(
                                const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 4,
                                ),
                              ),
                              shape: MaterialStateProperty.all(
                                RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                  side: BorderSide(color: AppTheme.warningColor.withOpacity(0.4)),
                                ),
                              ),
                              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            ),
                          ),
                        ],
                        ElevatedButton.icon(
                          onPressed: hasFilterSelection ? _clearFilterBreakdownSelection : null,
                          icon: Icon(Icons.clear, size: 12),
                          label: Text(
                            'Clear',
                            style: AppTheme.bodySmall.copyWith(
                              fontWeight: FontWeight.w600,
                              fontSize: 10,
                            ),
                          ),
                          style: ButtonStyle(
                            elevation: MaterialStateProperty.all(0),
                            backgroundColor: MaterialStateProperty.resolveWith((states) {
                              if (states.contains(MaterialState.disabled)) {
                                return AppTheme.surfaceColor.withOpacity(0.4);
                              }
                              if (states.contains(MaterialState.hovered) || states.contains(MaterialState.pressed)) {
                                return AppTheme.primaryColor.withOpacity(0.14);
                              }
                              return Colors.white;
                            }),
                            foregroundColor: MaterialStateProperty.resolveWith((states) {
                              if (states.contains(MaterialState.disabled)) {
                                return AppTheme.textMuted;
                              }
                              return AppTheme.primaryColor;
                            }),
                            overlayColor: MaterialStateProperty.all(AppTheme.primaryColor.withOpacity(0.08)),
                            padding: MaterialStateProperty.all(
                              const EdgeInsets.symmetric(
                                horizontal: 8,
                                vertical: 4,
                              ),
                            ),
                            shape: MaterialStateProperty.all(
                              RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8),
                                side: BorderSide(color: AppTheme.primaryColor.withOpacity(0.5)),
                              ),
                            ),
                            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          ),
                        ),
                      ],
                    ),
                  ],
                )
              : Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Text(
                      'Filter breakdown',
                      style: AppTheme.headingMedium.copyWith(
                        fontSize: isMobile ? 16 : 20,
                        fontWeight: FontWeight.w700,
                        letterSpacing: 0.6,
                      ),
                    ),
                    Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (isSelfWallet) ...[
                    Padding(
                      padding: EdgeInsets.only(right: isMobile ? 8 : 10),
                      child: ElevatedButton.icon(
                        onPressed: (hasFlaggedRecords || isFlaggedActive) ? _applyFlaggedQuickFilter : null,
                        icon: Icon(
                          Icons.flag_outlined,
                          size: isMobile ? 14 : 16,
                        ),
                        label: Text(
                          'Flaggged',
                          style: AppTheme.bodySmall.copyWith(
                            fontWeight: FontWeight.w600,
                            fontSize: isMobile ? 11 : 12,
                          ),
                        ),
                        style: ButtonStyle(
                          elevation: MaterialStateProperty.all(0),
                          backgroundColor: MaterialStateProperty.resolveWith((states) {
                            if (states.contains(MaterialState.disabled)) {
                              return AppTheme.surfaceColor.withOpacity(0.4);
                            }
                            if (states.contains(MaterialState.pressed) || states.contains(MaterialState.hovered)) {
                              return AppTheme.warningColor.withOpacity(0.22);
                            }
                            if (isFlaggedActive) {
                              return AppTheme.warningColor.withOpacity(0.22);
                            }
                            return AppTheme.warningColor.withOpacity(0.12);
                          }),
                          foregroundColor: MaterialStateProperty.resolveWith((states) {
                            if (states.contains(MaterialState.disabled)) {
                              return AppTheme.textMuted;
                            }
                            return AppTheme.warningColor;
                          }),
                          overlayColor: MaterialStateProperty.all(AppTheme.warningColor.withOpacity(0.18)),
                          padding: MaterialStateProperty.all(
                            EdgeInsets.symmetric(
                              horizontal: isMobile ? 10 : 12,
                              vertical: isMobile ? 6 : 8,
                            ),
                          ),
                          shape: MaterialStateProperty.all(
                            RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10),
                              side: BorderSide(
                                color: AppTheme.warningColor.withOpacity(isFlaggedActive ? 0.6 : 0.4),
                              ),
                            ),
                          ),
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                      ),
                    ),
                    Padding(
                      padding: EdgeInsets.only(right: isMobile ? 8 : 10),
                      child: ElevatedButton.icon(
                        onPressed: hasPendingApprovals ? _applyPendingApprovalsQuickFilter : null,
                        icon: Icon(
                          Icons.hourglass_bottom,
                          size: isMobile ? 14 : 16,
                        ),
                        label: Text(
                          'Smart Approvals',
                          style: AppTheme.bodySmall.copyWith(
                            fontWeight: FontWeight.w600,
                            fontSize: isMobile ? 11 : 12,
                          ),
                        ),
                        style: ButtonStyle(
                          elevation: MaterialStateProperty.all(0),
                          backgroundColor: MaterialStateProperty.resolveWith((states) {
                            if (states.contains(MaterialState.disabled)) {
                              return AppTheme.surfaceColor.withOpacity(0.4);
                            }
                            if (states.contains(MaterialState.hovered) || states.contains(MaterialState.pressed)) {
                              return AppTheme.warningColor.withOpacity(0.18);
                            }
                            return AppTheme.warningColor.withOpacity(0.12);
                          }),
                          foregroundColor: MaterialStateProperty.resolveWith((states) {
                            if (states.contains(MaterialState.disabled)) {
                              return AppTheme.textMuted;
                            }
                            return AppTheme.warningColor;
                          }),
                          overlayColor: MaterialStateProperty.all(AppTheme.warningColor.withOpacity(0.18)),
                          padding: MaterialStateProperty.all(
                            EdgeInsets.symmetric(
                              horizontal: isMobile ? 10 : 12,
                              vertical: isMobile ? 6 : 8,
                            ),
                          ),
                          shape: MaterialStateProperty.all(
                            RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10),
                              side: BorderSide(color: AppTheme.warningColor.withOpacity(0.4)),
                            ),
                          ),
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                      ),
                    ),
                  ],
                  ElevatedButton.icon(
                    onPressed: hasFilterSelection ? _clearFilterBreakdownSelection : null,
                    icon: Icon(Icons.clear, size: isMobile ? 14 : 16),
                    label: Text(
                      'Clear Selection',
                      style: AppTheme.bodySmall.copyWith(
                        fontWeight: FontWeight.w600,
                        fontSize: isMobile ? 11 : 12,
                      ),
                    ),
                    style: ButtonStyle(
                      elevation: MaterialStateProperty.all(0),
                      backgroundColor: MaterialStateProperty.resolveWith((states) {
                        if (states.contains(MaterialState.disabled)) {
                          return AppTheme.surfaceColor.withOpacity(0.4);
                        }
                        if (states.contains(MaterialState.hovered) || states.contains(MaterialState.pressed)) {
                          return AppTheme.primaryColor.withOpacity(0.14);
                        }
                        return Colors.white;
                      }),
                      foregroundColor: MaterialStateProperty.resolveWith((states) {
                        if (states.contains(MaterialState.disabled)) {
                          return AppTheme.textMuted;
                        }
                        return AppTheme.primaryColor;
                      }),
                      overlayColor: MaterialStateProperty.all(AppTheme.primaryColor.withOpacity(0.08)),
                      padding: MaterialStateProperty.all(
                        EdgeInsets.symmetric(
                          horizontal: isMobile ? 10 : 12,
                          vertical: isMobile ? 6 : 8,
                        ),
                      ),
                      shape: MaterialStateProperty.all(
                        RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                          side: BorderSide(color: AppTheme.primaryColor.withOpacity(0.5)),
                        ),
                      ),
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  ),
                ],
              ),
            ],
          ),
          SizedBox(height: isMobile ? 16 : 20),
          // Flexbox layout with three cards (or only Expenses for Expense Report)
          // For Self Wallet, filter cards based on permissions
          Builder(
            builder: (context) {
              if (isExpenseReportOnly) {
                return Align(
                  alignment: Alignment.centerLeft,
                  child: ConstrainedBox(
                    constraints: BoxConstraints(
                      maxWidth: isMobile ? double.infinity : (isTablet ? 400 : 450),
                    ),
                    child: _buildFilterBreakdownCard('Expenses', 'Expenses', isMobile, isTablet),
                  ),
                );
              }
              
              // For Self Wallet, only show cards user has permission to view
              if (isSelfWallet) {
                final List<Widget> cards = [];
                if (_canViewSelfWalletExpenses) {
                  cards.add(_buildFilterBreakdownCard('Expenses', 'Expenses', isMobile, isTablet));
                }
                if (_canViewSelfWalletTransaction) {
                  cards.add(_buildFilterBreakdownCard('Transactions', 'Transactions', isMobile, isTablet));
                }
                if (_canViewSelfWalletCollection) {
                  cards.add(_buildFilterBreakdownCard('Collections', 'Collections', isMobile, isTablet));
                }
                
                if (cards.isEmpty) {
                  return const SizedBox.shrink();
                }
                
                if (isMobile) {
                  return Column(
                    children: [
                      for (int i = 0; i < cards.length; i++) ...[
                        cards[i],
                        if (i < cards.length - 1) SizedBox(height: isMobile ? 16 : 20),
                      ],
                    ],
                  );
                } else {
                  return Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      for (int i = 0; i < cards.length; i++) ...[
                        Expanded(child: cards[i]),
                        if (i < cards.length - 1) SizedBox(width: 16),
                      ],
                    ],
                  );
                }
              }
              
              // For other views, show all cards
              return isMobile
                  ? Column(
                      children: [
                        _buildFilterBreakdownCard('Expenses', 'Expenses', isMobile, isTablet),
                        SizedBox(height: isMobile ? 16 : 20),
                        _buildFilterBreakdownCard('Transactions', 'Transactions', isMobile, isTablet),
                        SizedBox(height: isMobile ? 16 : 20),
                        _buildFilterBreakdownCard('Collections', 'Collections', isMobile, isTablet),
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: _buildFilterBreakdownCard('Expenses', 'Expenses', isMobile, isTablet),
                        ),
                        SizedBox(width: isMobile ? 12 : 16),
                        Expanded(
                          child: _buildFilterBreakdownCard('Transactions', 'Transactions', isMobile, isTablet),
                        ),
                        SizedBox(width: isMobile ? 12 : 16),
                        Expanded(
                          child: _buildFilterBreakdownCard('Collections', 'Collections', isMobile, isTablet),
                        ),
                      ],
                    );
            },
          ),
        ],
      ),
    );

    // Use collapsible container for Self Wallet and All Wallet Report (non-account, non-expense-report views)
    // This keeps Account Reports and pure Expense Report screens using the inline breakdown.
    final bool useCollapsibleContainer = !isAllAccounts && !isExpenseReportOnly;

    if (!useCollapsibleContainer) {
      return breakdownContent;
    }

    // Wrap in collapsible container (used by Self Wallet, All Wallet Report, etc.)
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: AppTheme.borderColor.withOpacity(0.8)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 18,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        children: [
          InkWell(
            onTap: () {
              if (!mounted) return;
              setState(() {
                _isFilterBreakdownExpanded = !_isFilterBreakdownExpanded;
              });
            },
            borderRadius: const BorderRadius.vertical(top: Radius.circular(18)),
            child: Container(
              padding: EdgeInsets.all(isMobile ? 16 : (isTablet ? 18 : 22)),
              child: Row(
                children: [
                  Icon(
                    Icons.analytics_outlined,
                    color: AppTheme.primaryColor,
                    size: isMobile ? 20 : 24,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Filter Breakdown',
                          style: AppTheme.headingSmall.copyWith(
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 8),
                  AnimatedRotation(
                    turns: _isFilterBreakdownExpanded ? 0.5 : 0,
                    duration: const Duration(milliseconds: 200),
                    child: Icon(
                      Icons.expand_more,
                      color: AppTheme.textSecondary,
                    ),
                  ),
                ],
              ),
            ),
          ),
          if (_isFilterBreakdownExpanded)
            Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Divider(height: 1),
                breakdownContent,
              ],
            ),
        ],
      ),
    );
  }

  Widget _buildFilterBreakdownCard(String categoryDisplay, String categoryKey, bool isMobile, bool isTablet) {
    final filterProvider = _filterProvider;
    final breakdown = _filterBreakdown[categoryKey] ?? {};
    final isSelected = filterProvider.selectedType == categoryKey;
    
    int totalCount = 0;
    double totalAmount = 0.0;
    breakdown.forEach((status, data) {
      if (status == 'Rejected') {
        return;
      }
      totalCount += data['count'] as int;
      totalAmount += data['amount'] as double;
    });
    
    return AnimatedContainer(
      duration: const Duration(milliseconds: 220),
      curve: Curves.easeOutCubic,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            Colors.white,
            AppTheme.surfaceColor.withOpacity(0.95),
          ],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
        borderRadius: BorderRadius.circular(isMobile ? 14 : 18),
        border: Border.all(
          color: (isSelected ? AppTheme.primaryColor : AppTheme.borderColor).withOpacity(isSelected ? 0.9 : 0.7),
          width: isSelected ? 1.6 : 1.1,
        ),
        boxShadow: const [
          BoxShadow(
            color: Color(0x120F172A),
            blurRadius: 16,
            offset: Offset(0, 10),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          InkWell(
            onTap: () {
              filterProvider.setType(categoryKey);
              filterProvider.setStatus(null);
              setState(() {
                _selectedStatusSet.clear();
              });
              _applyFilters();
            },
            child: Container(
              padding: EdgeInsets.all(isMobile ? 12 : 16),
              decoration: BoxDecoration(
                color: AppTheme.surfaceColor,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  topRight: Radius.circular(12),
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  if (isSelected) ...[
                    Container(
                      width: 8,
                      height: 8,
                      decoration: const BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 8),
                  ],
                  Text(
                    categoryDisplay,
                    style: AppTheme.headingSmall.copyWith(
                      fontSize: isMobile ? 14 : 16,
                      fontWeight: FontWeight.bold,
                      color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                      letterSpacing: 0.5,
                    ),
                  ),
                ],
              ),
            ),
          ),
          // Table
          ClipRRect(
            borderRadius: BorderRadius.only(
              bottomLeft: Radius.circular(isMobile ? 14 : 18),
              bottomRight: Radius.circular(isMobile ? 14 : 18),
            ),
            child: Table(
              border: TableBorder.symmetric(
                inside: BorderSide(color: AppTheme.borderColor.withOpacity(0.4), width: 0.8),
                outside: BorderSide(color: AppTheme.borderColor.withOpacity(0.5), width: 1),
              ),
            columnWidths: {
              0: FlexColumnWidth(2),
              1: FlexColumnWidth(1),
              2: FlexColumnWidth(1.5),
            },
              children: [
                // Header Row
                TableRow(
                  decoration: BoxDecoration(
                    color: AppTheme.primaryColor.withOpacity(0.06),
                  ),
                  children: [
                    _buildTableCell('Status', isMobile, isTablet, isHeader: true),
                    _buildTableCell('Count', isMobile, isTablet, isHeader: true, alignEnd: true),
                    _buildTableCell('Amount', isMobile, isTablet, isHeader: true, alignEnd: true),
                  ],
                ),
                // Data Rows
                ...breakdown.entries.where((entry) => entry.key != 'Rejected').map((entry) {
                  final status = entry.key;
                  final data = entry.value;
                  final count = data['count'] as int;
                  final amount = data['amount'] as double;
                final filterProvider = _filterProvider;
                final isSelectedStatus = filterProvider.selectedType == categoryKey &&
                    (filterProvider.selectedStatus == status || _selectedStatusSet.contains(status));

                  return TableRow(
                    decoration: BoxDecoration(
                      color: isSelectedStatus
                          ? AppTheme.primaryColor.withOpacity(0.1)
                          : Colors.white,
                    ),
                    children: [
                      _buildClickableStatusCell(
                        status,
                        isMobile,
                        isTablet,
                        () {
                          filterProvider.setType(categoryKey);
                          filterProvider.setStatus(status);
                          setState(() {
                            _selectedStatusSet
                              ..clear()
                              ..add(status);
                          });
                          _applyFilters();
                        },
                        isSelected: isSelectedStatus,
                      ),
                      _buildTableCell(count.toString(), isMobile, isTablet, alignEnd: true),
                      _buildTableCell(_formatAmount(amount), isMobile, isTablet, alignEnd: true),
                    ],
                  );
                }).toList(),
                // Total Row
                TableRow(
                  decoration: BoxDecoration(
                    color: AppTheme.surfaceColor.withOpacity(0.7),
                  ),
                  children: [
                    _buildTableCell('Total', isMobile, isTablet, isTotal: true),
                    _buildTableCell(totalCount.toString(), isMobile, isTablet, isTotal: true, alignEnd: true),
                    _buildTableCell(_formatAmount(totalAmount), isMobile, isTablet, isTotal: true, alignEnd: true),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _clearFilterBreakdownSelection() {
    final filterProvider = _filterProvider;
    final hasTypeOrStatus = filterProvider.selectedType != null || filterProvider.selectedStatus != null || _selectedStatusSet.isNotEmpty;
    final hasDateSelection = filterProvider.startDate != null || filterProvider.endDate != null;
    final hasQuickSelection = filterProvider.selectedQuickRange != null || filterProvider.selectedQuarter != null;
    final hasPendingSelection = _pendingApprovalsMode;

    if (!hasTypeOrStatus && !hasDateSelection && !hasQuickSelection && !hasPendingSelection) {
      return;
    }

    filterProvider.setType(null);
    filterProvider.setStatus(null);
    filterProvider.setQuickRange(null);
    filterProvider.clearDateRange();
    setState(() {
      _selectedStatusSet.clear();
      _pendingApprovalsMode = false;
    });

    _applyFilters();
  }

  TableRow _buildCategoryHeaderRow(String categoryDisplay, String categoryKey, bool isMobile, bool isTablet) {
    final filterProvider = _filterProvider;
    final isSelected = filterProvider.selectedType == categoryKey;
    return TableRow(
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor,
      ),
      children: [
        InkWell(
          onTap: () {
            filterProvider.setType(categoryKey);
            filterProvider.setStatus(null);
            setState(() {
              _selectedStatusSet.clear();
            });
            _applyFilters();
          },
          child: Padding(
            padding: EdgeInsets.all(isMobile ? 10 : 12),
            child: Row(
              children: [
                if (isSelected) ...[
                  Container(
                    width: 8,
                    height: 8,
                    decoration: const BoxDecoration(
                      color: Colors.green,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 8),
                ],
                Text(
                  categoryDisplay,
                  style: AppTheme.headingSmall.copyWith(
                    fontSize: isMobile ? 13 : 14,
                    fontWeight: FontWeight.bold,
                    color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        ),
        _buildTableCell('', isMobile, isTablet, isHeader: true),
        _buildTableCell('', isMobile, isTablet, isHeader: true),
      ],
    );
  }

  List<TableRow> _buildCategoryDataRows(String categoryKey, bool isMobile, bool isTablet) {
    final breakdown = _filterBreakdown[categoryKey] ?? {};
    List<TableRow> rows = [];
    
    breakdown.forEach((status, data) {
      final count = data['count'] as int;
      final amount = data['amount'] as double;
    final filterProvider = _filterProvider;
    final isSelected = filterProvider.selectedType == categoryKey &&
        (filterProvider.selectedStatus == status || _selectedStatusSet.contains(status));
      
      rows.add(
        TableRow(
          decoration: BoxDecoration(
            color: isSelected ? AppTheme.primaryColor.withOpacity(0.1) : Colors.white,
          ),
          children: [
            _buildClickableStatusCell(
              status,
              isMobile,
              isTablet,
              () {
            filterProvider.setType(categoryKey);
            filterProvider.setStatus(status);
            setState(() {
              _selectedStatusSet
                ..clear()
                ..add(status);
            });
                _applyFilters();
              },
              isSelected: isSelected,
            ),
            _buildTableCell(count.toString(), isMobile, isTablet, alignEnd: true),
            _buildTableCell(_formatAmount(amount), isMobile, isTablet, alignEnd: true),
          ],
        ),
      );
    });
    
    return rows;
  }

  TableRow _buildCategoryTotalRow(String categoryKey, bool isMobile, bool isTablet) {
    final breakdown = _filterBreakdown[categoryKey] ?? {};
    int totalCount = 0;
    double totalAmount = 0.0;
    
    breakdown.forEach((status, data) {
      if (status == 'Rejected') {
        return;
      }
      totalCount += data['count'] as int;
      totalAmount += data['amount'] as double;
    });
    
    return TableRow(
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor.withOpacity(0.5),
      ),
      children: [
        _buildTableCell('Total', isMobile, isTablet, isTotal: true),
        _buildTableCell(totalCount.toString(), isMobile, isTablet, isTotal: true, alignEnd: true),
        _buildTableCell(_formatAmount(totalAmount), isMobile, isTablet, isTotal: true, alignEnd: true),
      ],
    );
  }

  Widget _buildTableCell(
    String text,
    bool isMobile,
    bool isTablet, {
    bool isHeader = false,
    bool isTotal = false,
    bool alignEnd = false,
  }) {
    return Padding(
      padding: EdgeInsets.all(isMobile ? 10 : 12),
      child: Text(
        text,
        style: AppTheme.bodyMedium.copyWith(
          fontSize: isMobile ? 12 : (isTablet ? 13 : 14),
          fontWeight: isHeader || isTotal ? FontWeight.bold : FontWeight.normal,
          color: isTotal ? AppTheme.textMuted : (isHeader ? AppTheme.textPrimary : AppTheme.textSecondary),
        ),
        textAlign: alignEnd ? TextAlign.right : TextAlign.left,
      ),
    );
  }

  Widget _buildClickableStatusCell(
    String status,
    bool isMobile,
    bool isTablet,
    VoidCallback onTap, {
    bool isSelected = false,
  }) {
    return InkWell(
      onTap: onTap,
      child: Padding(
        padding: EdgeInsets.all(isMobile ? 10 : 12),
        child: Row(
          children: [
            if (isSelected) ...[
              Container(
                width: 6,
                height: 6,
                decoration: const BoxDecoration(
                  color: Colors.green,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 6),
            ],
            ...() {
              final icon = _buildStatusIcon(status, isMobile: isMobile, isTablet: isTablet);
              if (icon == null) {
                return <Widget>[];
              }
              return [icon, const SizedBox(width: 6)];
            }(),
            Expanded(
              child: Text(
                status,
                style: AppTheme.bodyMedium.copyWith(
                  fontSize: isMobile ? 12 : (isTablet ? 13 : 14),
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  color: isSelected ? AppTheme.primaryColor : AppTheme.textSecondary,
                ),
                textAlign: TextAlign.left,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget? _buildStatusIcon(String status, {required bool isMobile, required bool isTablet}) {
    final double size = isMobile ? 14 : (isTablet ? 15 : 16);
    switch (status) {
      case 'Approved':
        return Icon(Icons.check_circle_rounded, size: size, color: AppTheme.secondaryColor);
      case 'Unapproved':
        return Icon(Icons.cancel_rounded, size: size, color: AppTheme.errorColor);
      case 'Accounted':
        return Icon(Icons.verified_rounded, size: size, color: AppTheme.accentBlue);
      case 'Unaccounted':
        return Icon(Icons.account_circle_rounded, size: size, color: AppTheme.primaryColor);
      case 'Flagged':
        return Icon(Icons.flag_rounded, size: size, color: AppTheme.warningColor);
      case 'Rejected':
        return Icon(Icons.block_rounded, size: size, color: AppTheme.errorColor);
      default:
        return null;
    }
  }

  Widget _buildFilterColumn(String category, String categoryKey, bool isMobile, bool isTablet) {
    final breakdown = _filterBreakdown[categoryKey]!;
    int totalCount = 0;
    double totalAmount = 0.0;

    breakdown.forEach((status, data) {
      totalCount += data['count'] as int;
      totalAmount += data['amount'] as double;
    });

    final filterProvider = _filterProvider;
    final isSelected = filterProvider.selectedType == categoryKey;

    return Container(
      padding: EdgeInsets.all(isMobile ? 12 : 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(10),
        border: Border.all(
          color: isSelected ? AppTheme.primaryColor : AppTheme.borderColor,
          width: isSelected ? 2 : 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          InkWell(
            onTap: () {
              filterProvider.setType(categoryKey);
              filterProvider.setStatus(null);
              _applyFilters();
            },
            child: Row(
              children: [
                if (isSelected) ...[
                  Container(
                    width: 8,
                    height: 8,
                    decoration: const BoxDecoration(
                      color: Colors.green,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 8),
                ],
          Text(
                  category,
                  style: AppTheme.headingSmall.copyWith(
                    fontSize: isMobile ? 15 : 16,
                    fontWeight: FontWeight.bold,
                    color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                  ),
                ),
              ],
            ),
          ),
          SizedBox(height: isMobile ? 10 : 12),
          ...breakdown.entries.where((entry) => entry.key != 'Rejected').map((entry) {
            final status = entry.key;
            final data = entry.value;
            final count = data['count'] as int;
            final amount = data['amount'] as double;
            final filterProvider = _filterProvider;
            final isSelectedStatus = filterProvider.selectedType == categoryKey &&
                (filterProvider.selectedStatus == status || _selectedStatusSet.contains(status));

            String icon = '';
            if (status == 'Approved' || status == 'Accounted') icon = '‚úÖ';
            else if (status == 'Unapproved' || status == 'Unaccounted') icon = '‚ùå';
            else if (status == 'Flagged') icon = 'üö©';
            else if (status == 'Rejected') icon = '‚õî';

            return InkWell(
              onTap: () {
                filterProvider.setType(categoryKey);
                filterProvider.setStatus(status);
                setState(() {
                  _selectedStatusSet
                    ..clear()
                    ..add(status);
                });
                _applyFilters();
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 4),
                child: Row(
                  children: [
                    if (isSelectedStatus) ...[
                      Container(
                        width: 6,
                        height: 6,
                        decoration: const BoxDecoration(
                          color: Colors.green,
                          shape: BoxShape.circle,
                        ),
                      ),
                      const SizedBox(width: 6),
                    ],
          Text(
                      '$icon $status: $count ${_formatAmount(amount)}',
                      style: AppTheme.bodySmall.copyWith(
                        fontWeight: isSelectedStatus ? FontWeight.bold : FontWeight.w500,
                        color: isSelectedStatus ? AppTheme.primaryColor : AppTheme.textPrimary,
                      ),
                    ),
                  ],
                ),
              ),
            );
          }).toList(),
          const Divider(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Total:',
                style: AppTheme.bodyMedium.copyWith(fontWeight: FontWeight.bold),
              ),
              Text(
                '$totalCount ${_formatAmount(totalAmount)}',
                style: AppTheme.bodyMedium.copyWith(
                  fontWeight: FontWeight.bold,
                  color: AppTheme.primaryColor,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  Widget _buildTableFilters(bool isMobile, bool isTablet, {bool isSelfWallet = false, bool isAllAccounts = false, bool isExpenseReportOnly = false}) {
    final filterWidth = isMobile ? null : (isTablet ? 200.0 : 220.0);
    final horizontalSpacing = isMobile ? 8.0 : (isTablet ? 10.0 : 12.0);
    final buttonHeight = isMobile ? 38.0 : (isTablet ? 38.0 : 40.0);

    Widget buildFilter(Widget child) {
      if (isMobile) {
        return SizedBox(width: double.infinity, child: child);
      }
      return SizedBox(width: filterWidth, child: child);
    }

    final Widget clearFiltersButton = SizedBox(
      height: buttonHeight,
      child: OutlinedButton(
        onPressed: _clearFilters,
        style: OutlinedButton.styleFrom(
          padding: EdgeInsets.symmetric(
            horizontal: isMobile ? 10 : (isTablet ? 18 : 20),
            vertical: isMobile ? 8 : 12,
          ),
          foregroundColor: AppTheme.primaryColor,
          side: BorderSide(color: AppTheme.primaryColor.withOpacity(0.6)),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
        ),
        child: Text(
          'Clear Filters',
          style: TextStyle(fontSize: isMobile ? 11 : null),
        ),
      ),
    );

    final Widget exportButton = SizedBox(
      height: buttonHeight,
      child: _buildExportButtons(isMobile, isTablet, isAllAccounts: isAllAccounts),
    );

    if (isMobile) {
      // Type options: Add Amount and Withdraw for All Account Reports, standard types for others
      // Filter based on permissions for Self Wallet
      List<String> typeOptions = isAllAccounts
          ? ['All', 'Add Amount', 'Withdraw', 'Expenses', 'Transactions', 'Collections']
          : ['All', 'Expenses', 'Transactions', 'Collections'];
      
      // For Self Wallet, filter out types that user doesn't have permission to view
      if (isSelfWallet && !isAllAccounts) {
        final List<String> filteredOptions = ['All'];
        if (_canViewSelfWalletExpenses) filteredOptions.add('Expenses');
        if (_canViewSelfWalletTransaction) filteredOptions.add('Transactions');
        if (_canViewSelfWalletCollection) filteredOptions.add('Collections');
        typeOptions = filteredOptions;
      }
      
      final List<Widget> mobileChildren = [];
      
      // Type filter (shown for all views including Expense Report)
      mobileChildren.add(
        buildFilter(
          _buildDropdownFilter(
            'Type',
            _filterProvider.selectedType ?? 'All',
            typeOptions,
            (value) {
              final filterProvider = _filterProvider;
              debugPrint('üîç [SELF WALLET] Type filter changed: ${filterProvider.selectedType} ‚Üí ${value == 'All' ? null : value}');
              setState(() {
                filterProvider.setType(value == 'All' ? null : value);
                if (filterProvider.selectedType == null) {
                  filterProvider.setStatus(null);
                }
                _selectedStatusSet.clear();
              });
              _applyFilters();
            },
            isMobile,
            isTablet,
          ),
        ),
      );
      mobileChildren.add(SizedBox(height: horizontalSpacing));
      mobileChildren.add(
        buildFilter(
          _buildStatusFilterControl(
            isMobile: isMobile,
            isTablet: isTablet,
            isSelfWallet: isSelfWallet,
            isAllAccounts: isAllAccounts,
          ),
        ),
      );
      mobileChildren.add(SizedBox(height: horizontalSpacing));
      // Expense Type Category filter (only for Expense Report, after Status)
      if (isExpenseReportOnly) {
        mobileChildren.add(
          buildFilter(
            _buildExpenseTypeDropdownFilter(
              label: 'Expense Type',
              currentValue: _selectedExpenseTypeCategory ?? 'All',
              onChanged: (value) {
                setState(() {
                  _selectedExpenseTypeCategory = value == 'All' ? null : value;
                });
                _applyFilters();
              },
              isMobile: isMobile,
              isTablet: isTablet,
            ),
          ),
        );
        mobileChildren.add(SizedBox(height: horizontalSpacing));
      }
      // Mode filter (visible for All Account Reports, hidden for Expense Report)
      if (!isExpenseReportOnly) {
        // Use Account Reports specific modes for Account Reports, otherwise use full list
        // Wrap Mode dropdown with ValueListenableBuilder to wait for payment modes
      mobileChildren.add(
        ValueListenableBuilder<bool>(
          valueListenable: _paymentModesLoadedNotifier,
          builder: (context, _, __) {
            // Show active payment modes from database for all views (including Self Wallet)
            final List<String> modeOptions = isAllAccounts 
                ? _getActiveModeOptions(isAccountReports: true) 
                : _getActiveModeOptions();
            return buildFilter(
              _buildDropdownFilter(
                'Mode',
                _filterProvider.selectedMode ?? 'All',
                modeOptions,
                (value) {
                  final filterProvider = _filterProvider;
                  if (isSelfWallet) {
                    debugPrint('üîç [SELF WALLET] Mode filter changed: ${filterProvider.selectedMode} ‚Üí ${value == 'All' ? null : value}');
                  }
                  filterProvider.setMode(value == 'All' ? null : value);
                  _applyFilters();
                },
                isMobile,
                isTablet,
              ),
            );
          },
        ),
      );
        mobileChildren.add(SizedBox(height: horizontalSpacing));
      }

      if (isSelfWallet || isAllAccounts || isExpenseReportOnly) {
        mobileChildren.add(
          Row(
            children: [
              Expanded(child: exportButton),
              SizedBox(width: horizontalSpacing),
              Expanded(child: clearFiltersButton),
            ],
          ),
        );
      } else {
        mobileChildren.add(clearFiltersButton);
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: mobileChildren,
      );
    }

    // Type options: Add Amount and Withdraw for All Account Reports, standard types for others
    // Filter based on permissions for Self Wallet
    List<String> typeOptions = isAllAccounts
        ? ['All', 'Add Amount', 'Withdraw', 'Expenses', 'Transactions', 'Collections']
        : ['All', 'Expenses', 'Transactions', 'Collections'];
    
    // For Self Wallet, filter out types that user doesn't have permission to view
    if (isSelfWallet && !isAllAccounts) {
      final List<String> filteredOptions = ['All'];
      if (_canViewSelfWalletExpenses) filteredOptions.add('Expenses');
      if (_canViewSelfWalletTransaction) filteredOptions.add('Transactions');
      if (_canViewSelfWalletCollection) filteredOptions.add('Collections');
      typeOptions = filteredOptions;
    }

    final List<Widget> rowChildren = [];
    
    // Type filter (shown for all views including Expense Report, positioned before Status)
    rowChildren.add(
      buildFilter(
        _buildDropdownFilter(
          'Type',
          _filterProvider.selectedType ?? 'All',
          typeOptions,
          (value) {
              final filterProvider = _filterProvider;
              setState(() {
                filterProvider.setType(value == 'All' ? null : value);
                if (filterProvider.selectedType == null) {
                  filterProvider.setStatus(null);
                }
                _selectedStatusSet.clear();
              });
            _applyFilters();
          },
          isMobile,
          isTablet,
        ),
      ),
    );
    rowChildren.add(SizedBox(width: horizontalSpacing));
    rowChildren.add(
      buildFilter(
        _buildStatusFilterControl(
          isMobile: isMobile,
          isTablet: isTablet,
          isSelfWallet: isSelfWallet,
        ),
      ),
    );
    rowChildren.add(SizedBox(width: horizontalSpacing));
    // Expense Type Category filter (only for Expense Report, after Status)
    if (isExpenseReportOnly) {
      rowChildren.add(
        buildFilter(
          _buildExpenseTypeDropdownFilter(
            label: 'Expense Type',
            currentValue: _selectedExpenseTypeCategory ?? 'All',
            onChanged: (value) {
              setState(() {
                _selectedExpenseTypeCategory = value == 'All' ? null : value;
              });
              _applyFilters();
            },
            isMobile: isMobile,
            isTablet: isTablet,
          ),
        ),
      );
      rowChildren.add(SizedBox(width: horizontalSpacing));
    }
    // Mode filter (visible for All Account Reports, hidden for Expense Report)
    if (!isExpenseReportOnly) {
      // Use Account Reports specific modes for Account Reports, otherwise use full list
      // Wrap Mode dropdown with ValueListenableBuilder to wait for payment modes
      rowChildren.add(
        ValueListenableBuilder<bool>(
          valueListenable: _paymentModesLoadedNotifier,
          builder: (context, _, __) {
            // Show active payment modes from database for all views (including Self Wallet)
            final List<String> modeOptions = isAllAccounts 
                ? _getActiveModeOptions(isAccountReports: true) 
                : _getActiveModeOptions();
            return buildFilter(
              _buildDropdownFilter(
                'Mode',
                _filterProvider.selectedMode ?? 'All',
                modeOptions,
                (value) {
                  final filterProvider = _filterProvider;
                  if (isSelfWallet) {
                    debugPrint('üîç [SELF WALLET] Mode filter changed: ${filterProvider.selectedMode} ‚Üí ${value == 'All' ? null : value}');
                  }
                  filterProvider.setMode(value == 'All' ? null : value);
                  _applyFilters();
                },
                isMobile,
                isTablet,
              ),
            );
          },
        ),
      );
      rowChildren.add(SizedBox(width: horizontalSpacing));
    }
    rowChildren.add(const Spacer());

    if (isSelfWallet || isAllAccounts || isExpenseReportOnly) {
      rowChildren.add(exportButton);
      rowChildren.add(SizedBox(width: horizontalSpacing));
    }

    rowChildren.add(clearFiltersButton);

    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: rowChildren,
    );
  }

  Widget _buildDropdownFilter(
    String label,
    String currentValue,
    List<String> items,
    ValueChanged<String?> onChanged,
    bool isMobile,
    bool isTablet,
  ) {
    // Ensure items list is not empty - always have at least 'All'
    final safeItems = items.isEmpty ? ['All'] : items;
    
    // Validate that currentValue exists in items, otherwise use first item
    final validatedValue = safeItems.contains(currentValue) ? currentValue : safeItems.first;
    final displayText = _formatStatusLabel(validatedValue);
    final finalDisplayText = displayText.isEmpty ? validatedValue : displayText;
    
    // Calculate button height for proper menu offset
    final double buttonHeight = isMobile ? 56.0 : 56.0; // Standard InputDecoration height
    
    // Calculate offset to position menu at bottom of button with small gap
    final Offset menuOffset = Offset(0, buttonHeight + 4);
    
    // Calculate dropdown width - match button width
    final double dropdownWidth = isMobile ? double.infinity : 200.0;
    
    return Material(
      elevation: 8,
      color: Colors.transparent,
      shadowColor: Colors.transparent, // Hide Material shadow, we only need elevation for z-index
      child: PopupMenuButton<String>(
        offset: menuOffset, // Position menu at bottom of button
        elevation: 8,
        shadowColor: Colors.black.withOpacity(0.08),
        surfaceTintColor: Colors.transparent,
        color: Colors.white,
        constraints: BoxConstraints(
          minWidth: dropdownWidth,
          maxWidth: dropdownWidth,
          maxHeight: 300, // Limit dropdown menu height to prevent overflow
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8), // Rounded corners for dropdown menu
        ),
        onSelected: (value) {
          onChanged(value);
        },
        itemBuilder: (context) {
          return safeItems.map<PopupMenuEntry<String>>((String item) {
            final itemDisplayText = _formatStatusLabel(item);
            final finalItemText = itemDisplayText.isEmpty ? item : itemDisplayText;
            final isSelected = item == validatedValue;
            
            return PopupMenuItem<String>(
              value: item,
              padding: EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 8,
              ),
              child: Row(
                children: [
                  if (isSelected)
                    Icon(
                      Icons.check,
                      size: 18,
                      color: AppTheme.primaryColor,
                    )
                  else
                    const SizedBox(width: 18),
                  if (isSelected) const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      finalItemText,
                      style: AppTheme.bodyMedium.copyWith(
                        color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            );
          }).toList();
        },
        // Child: Button that looks exactly like DropdownButtonFormField
        child: InputDecorator(
      decoration: InputDecoration(
        labelText: label,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: BorderSide(color: AppTheme.borderColor),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: BorderSide(color: AppTheme.borderColor),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: BorderSide(color: AppTheme.primaryColor, width: 2),
        ),
        contentPadding: EdgeInsets.symmetric(
          horizontal: isMobile ? 10 : 12,
          vertical: isMobile ? 8 : 10,
        ),
            suffixIcon: Icon(
              Icons.keyboard_arrow_down,
              color: AppTheme.textSecondary,
            ),
          ),
          isFocused: false,
          isEmpty: false,
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Expanded(
          child: Text(
                  finalDisplayText,
            style: AppTheme.bodyMedium,
            overflow: TextOverflow.ellipsis,
          ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper method to map expense type name to valid category
  String _mapExpenseTypeToCategory(String typeName) {
    final normalizedType = typeName.trim().toLowerCase();
    
    // Office-related expenses
    if (normalizedType.contains('office') || 
        normalizedType.contains('stationary') || 
        normalizedType.contains('stationery') ||
        normalizedType.contains('tea') ||
        normalizedType.contains('coffee') ||
        normalizedType.contains('cafe') ||
        normalizedType.contains('snacks') ||
        normalizedType.contains('supplies')) {
      return 'Office';
    }
    
    // Travel-related expenses
    if (normalizedType.contains('travel') || 
        normalizedType.contains('fuel') ||
        normalizedType.contains('transport') ||
        normalizedType.contains('taxi') ||
        normalizedType.contains('uber') ||
        normalizedType.contains('cab')) {
      return 'Travel';
    }
    
    // Marketing-related expenses
    if (normalizedType.contains('marketing') || 
        normalizedType.contains('advertisement') ||
        normalizedType.contains('advert') ||
        normalizedType.contains('promotion') ||
        normalizedType.contains('social media')) {
      return 'Marketing';
    }
    
    // Maintenance-related expenses
    if (normalizedType.contains('maintenance') || 
        normalizedType.contains('repair') ||
        normalizedType.contains('service') ||
        normalizedType.contains('electricity') ||
        normalizedType.contains('water') ||
        normalizedType.contains('internet') ||
        normalizedType.contains('rent')) {
      return 'Maintenance';
    }
    
    // Default to Misc for everything else
    return 'Misc';
  }

  // Helper method to get image URL for expense type
  String? _getExpenseTypeImageUrl(String typeName) {
    // First, try to find in _expenseTypesWithImages
    final expenseType = _expenseTypesWithImages.firstWhere(
      (et) => (et['name'] as String?)?.toLowerCase() == typeName.toLowerCase(),
      orElse: () => <String, dynamic>{},
    );
    
    if (expenseType.isNotEmpty && expenseType['imageUrl'] != null) {
      final imageUrl = expenseType['imageUrl']?.toString();
      if (imageUrl != null && imageUrl.isNotEmpty) {
        return imageUrl;
      }
    }
    
    // Fallback to default images based on name
    final normalizedType = typeName.trim().toLowerCase();
    
    if (normalizedType.contains('office') || normalizedType.contains('coffee') || normalizedType.contains('cafe')) {
      return 'https://images.unsplash.com/photo-1495474472287-4d71bcdd2085?w=400&h=400&fit=crop';
    }
    if (normalizedType.contains('travel') || normalizedType.contains('bus') || normalizedType.contains('transport')) {
      return 'https://images.unsplash.com/photo-1544620347-c4fd4a3d5957?w=400&h=400&fit=crop';
    }
    if (normalizedType.contains('marketing') || normalizedType.contains('advert') || normalizedType.contains('promo')) {
      return 'https://images.unsplash.com/photo-1552664730-d307ca884978?w=400&h=400&fit=crop';
    }
    if (normalizedType.contains('maintenance') || normalizedType.contains('repair') || normalizedType.contains('tool')) {
      return 'https://images.unsplash.com/photo-1504148455328-c376907d081c?w=400&h=400&fit=crop';
    }
    if (normalizedType.contains('misc') || normalizedType.contains('miscellaneous') || normalizedType.contains('other')) {
      return 'https://images.unsplash.com/photo-1554224155-6726b3ff858f?w=400&h=400&fit=crop';
    }
    if (normalizedType.contains('tea') || normalizedType.contains('stationary')) {
      return 'https://images.unsplash.com/photo-1554224155-6726b3ff858f?w=400&h=400&fit=crop';
    }
    
    return null;
  }

  // Custom dropdown for expense types with images
  Widget _buildExpenseTypeDropdownFilter({
    required String label,
    required String? currentValue,
    required ValueChanged<String?> onChanged,
    required bool isMobile,
    required bool isTablet,
  }) {
    // Ensure currentValue is included in options if it's set and not 'All'
    final Set<String> expenseTypeSet = {'All', ..._expenseCategories};
    if (currentValue != null && currentValue != 'All' && !expenseTypeSet.contains(currentValue)) {
      expenseTypeSet.add(currentValue);
    }
    final expenseTypeOptions = expenseTypeSet.toList();
    
    // Validate that currentValue exists in options, otherwise use 'All'
    final validatedValue = (currentValue != null && expenseTypeOptions.contains(currentValue))
        ? currentValue
        : 'All';
    
    // Calculate button height for proper menu offset
    final double buttonHeight = isMobile ? 56.0 : 56.0; // Standard InputDecoration height
    
    // Calculate offset to position menu at bottom of button with small gap
    final Offset menuOffset = Offset(0, buttonHeight + 4);
    
    // Calculate dropdown width - match button width
    final double dropdownWidth = isMobile ? double.infinity : 200.0;
    
    // Get display value with image for button
    final String displayValue = validatedValue;
    final imageUrl = validatedValue != 'All' ? _getExpenseTypeImageUrl(validatedValue) : null;
    
    return Material(
      elevation: 8,
      color: Colors.transparent,
      shadowColor: Colors.transparent, // Hide Material shadow, we only need elevation for z-index
      child: PopupMenuButton<String>(
        offset: menuOffset, // Position menu at bottom of button
        elevation: 8,
        shadowColor: Colors.black.withOpacity(0.08),
        surfaceTintColor: Colors.transparent,
        color: Colors.white,
        constraints: BoxConstraints(
          minWidth: dropdownWidth,
          maxWidth: dropdownWidth,
          maxHeight: 300, // Limit dropdown menu height to prevent overflow
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8), // Rounded corners for dropdown menu
        ),
        onSelected: (value) {
          onChanged(value);
        },
        itemBuilder: (context) {
          return expenseTypeOptions.map<PopupMenuEntry<String>>((String item) {
            final isSelected = item == validatedValue;
            final itemImageUrl = item != 'All' ? _getExpenseTypeImageUrl(item) : null;
            
            return PopupMenuItem<String>(
          value: item,
              padding: EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 8,
              ),
          child: Row(
            children: [
                  if (isSelected)
                    Icon(
                      Icons.check,
                      size: 18,
                      color: AppTheme.primaryColor,
                    )
                  else
                    const SizedBox(width: 18),
                  if (isSelected) const SizedBox(width: 8),
                  if (itemImageUrl != null)
                Container(
                  width: 32,
                  height: 32,
                  margin: const EdgeInsets.only(right: 12),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(color: AppTheme.borderColor.withOpacity(0.3)),
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(6),
                    child: Image.network(
                          itemImageUrl,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          color: AppTheme.backgroundColor,
                          child: Icon(
                            Icons.category_outlined,
                            size: 18,
                            color: AppTheme.textSecondary,
                          ),
                        );
                      },
                      loadingBuilder: (context, child, loadingProgress) {
                        if (loadingProgress == null) return child;
                        return Center(
                          child: SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                )
                  else if (item != 'All')
                Container(
                  width: 32,
                  height: 32,
                  margin: const EdgeInsets.only(right: 12),
                  decoration: BoxDecoration(
                    color: AppTheme.backgroundColor,
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(color: AppTheme.borderColor.withOpacity(0.3)),
                  ),
                  child: Icon(
                    Icons.category_outlined,
                    size: 18,
                    color: AppTheme.textSecondary,
                  ),
                ),
              Expanded(
                    child: Text(
                      item,
                      style: AppTheme.bodyMedium.copyWith(
                        color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
              ),
            ],
          ),
        );
          }).toList();
        },
        // Child: Button that looks exactly like DropdownButtonFormField
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: label,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: AppTheme.borderColor),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: AppTheme.borderColor),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide(color: AppTheme.primaryColor, width: 2),
            ),
            contentPadding: EdgeInsets.symmetric(
              horizontal: isMobile ? 10 : 12,
              vertical: isMobile ? 8 : 10,
            ),
            suffixIcon: Icon(
              Icons.keyboard_arrow_down,
              color: AppTheme.textSecondary,
            ),
          ),
          isFocused: false,
          isEmpty: false,
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (imageUrl != null && validatedValue != 'All')
                Container(
                  width: 24,
                  height: 24,
                  margin: const EdgeInsets.only(right: 8),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: AppTheme.borderColor.withOpacity(0.3)),
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: Image.network(
                      imageUrl,
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          color: AppTheme.backgroundColor,
                          child: Icon(
                            Icons.category_outlined,
                            size: 14,
                            color: AppTheme.textSecondary,
                          ),
                        );
                      },
                    ),
                  ),
                )
              else if (validatedValue != 'All')
                Container(
                  width: 24,
                  height: 24,
                  margin: const EdgeInsets.only(right: 8),
                  decoration: BoxDecoration(
                    color: AppTheme.backgroundColor,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: AppTheme.borderColor.withOpacity(0.3)),
                  ),
                  child: Icon(
                    Icons.category_outlined,
                    size: 14,
                    color: AppTheme.textSecondary,
                  ),
                ),
              Expanded(
                child: Text(
                  displayValue,
                  style: AppTheme.bodyMedium,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatusFilterControl({
    required bool isMobile,
    required bool isTablet,
    required bool isSelfWallet,
    bool isAllAccounts = false,
  }) {
    if (!isSelfWallet || isAllAccounts) {
      return _buildDropdownFilter(
        'Status',
        _getStatusDisplayText(),
        _getStatusOptions(),
        (value) {
          final filterProvider = _filterProvider;
          if (isSelfWallet) {
            debugPrint('üîç [SELF WALLET] Status filter changed (dropdown): ${filterProvider.selectedStatus} ‚Üí ${value == 'All' ? null : value}');
          }
          setState(() {
            filterProvider.setStatus(value == 'All' ? null : value);
            _selectedStatusSet.clear();
          });
          _applyFilters();
        },
        isMobile,
        isTablet,
      );
    }

    final List<String> options = _getStatusOptions().where((option) => option != 'All').toList();
    final String chipLabel = _selectedStatusSet.isEmpty
        ? 'All'
        : (_selectedStatusSet.length == 1
            ? (_formatStatusLabel(_selectedStatusSet.first).isEmpty
                ? _selectedStatusSet.first
                : _formatStatusLabel(_selectedStatusSet.first))
            : '${_selectedStatusSet.length} selected');

    return PopupMenuButton<String>(
      offset: Offset(0, isMobile ? 40 : 45),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: 'Status',
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: AppTheme.borderColor),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: AppTheme.borderColor),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: AppTheme.primaryColor, width: 2),
          ),
          contentPadding: EdgeInsets.symmetric(
            horizontal: isMobile ? 10 : 12,
            vertical: isMobile ? 8 : 10,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          mainAxisSize: MainAxisSize.min,
          children: [
            Expanded(
              child: Text(
                chipLabel,
                style: AppTheme.bodyMedium,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            const Icon(Icons.arrow_drop_down),
          ],
        ),
      ),
      itemBuilder: (context) => [
        ...options.map((status) {
          final bool isSelected = _selectedStatusSet.contains(status);
          return PopupMenuItem<String>(
            value: status,
            child: Row(
              children: [
                SizedBox(
                  width: 24,
                  height: 24,
                  child: Checkbox(
                    value: isSelected,
                    onChanged: null,
                    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    visualDensity: VisualDensity.compact,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    _formatStatusLabel(status).isEmpty ? status : _formatStatusLabel(status),
                    style: TextStyle(fontSize: isMobile ? 14 : 15),
                  ),
                ),
              ],
            ),
          );
        }),
        const PopupMenuDivider(),
        PopupMenuItem<String>(
          value: 'clear',
          child: Row(
            children: [
              Icon(Icons.clear_all, size: isMobile ? 18 : 20, color: AppTheme.primaryColor),
              const SizedBox(width: 12),
              Text(
                'Clear All',
                style: TextStyle(
                  fontSize: isMobile ? 14 : 15,
                  color: AppTheme.primaryColor,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
      ],
      onSelected: (value) {
        if (value == 'clear') {
          debugPrint('üîç [SELF WALLET] Status filter cleared - clearing all selections');
          setState(() {
            _selectedStatusSet.clear();
            final filterProvider = _filterProvider;
            filterProvider.setStatus(null);
          });
          _applyFilters();
        } else {
          final wasSelected = _selectedStatusSet.contains(value);
          debugPrint('üîç [SELF WALLET] Status filter changed (multi-select): $value');
          debugPrint('   Was selected: $wasSelected');
          setState(() {
            if (_selectedStatusSet.contains(value)) {
              _selectedStatusSet.remove(value);
              debugPrint('   Removed from selection. New set: $_selectedStatusSet');
            } else {
              _selectedStatusSet.add(value);
              debugPrint('   Added to selection. New set: $_selectedStatusSet');
            }
            final filterProvider = _filterProvider;
            filterProvider.setStatus(null);
          });
          _applyFilters();
        }
      },
    );
  }


  Widget _buildModeSelector(bool isMobile, bool isTablet, {bool isAccountReports = false}) {
    // Wait for payment modes to load before building selector
    return ValueListenableBuilder<bool>(
      valueListenable: _paymentModesLoadedNotifier,
      builder: (context, _, __) {
        final double buttonHeight = isMobile ? 36 : 40;
        final double spacing = isMobile ? 6 : 10;
        // Get active mode options from payment modes
        final List<String> modeOptions = _getActiveModeOptions(isAccountReports: isAccountReports);

    return ConstrainedBox(
      constraints: BoxConstraints(
        maxWidth: isMobile ? double.infinity : (isTablet ? 320 : 360),
      ),
      child: Wrap(
        spacing: spacing,
        runSpacing: spacing,
        children: modeOptions.map((mode) {
          final filterProvider = _filterProvider;
          final bool isSelected = (filterProvider.selectedMode == null && mode == 'All') || filterProvider.selectedMode == mode;

          return SizedBox(
            height: buttonHeight,
            child: OutlinedButton(
              onPressed: isSelected
                  ? null
                  : () {
                      final filterProvider = _filterProvider;
                      filterProvider.setMode(mode == 'All' ? null : mode);
                      _applyFilters();
                    },
              style: OutlinedButton.styleFrom(
                padding: EdgeInsets.symmetric(horizontal: isMobile ? 8 : 16),
                minimumSize: Size.zero,
                tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                textStyle: AppTheme.bodyMedium.copyWith(
                  fontWeight: FontWeight.w600,
                  fontSize: isMobile ? 11 : 14,
                ),
                foregroundColor: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                backgroundColor: isSelected ? AppTheme.primaryColor.withValues(alpha: 0.12) : AppTheme.surfaceColor,
                side: BorderSide(
                  color: isSelected
                      ? AppTheme.primaryColor
                      : AppTheme.borderColor.withValues(alpha: 0.8),
                  width: isSelected ? 1.6 : 1,
                ),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: Text(
                mode,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          );
        }).toList(),
      ),
    );
      },
    );
  }

  List<_LegendEntry> _getVisibleLegendEntries() {
    const Map<String, _LegendEntry> legendItems = {
      'approve': _LegendEntry(icon: Icons.check, color: Colors.green, label: 'Approve'),
      'unapprove': _LegendEntry(icon: Icons.undo, color: Colors.orange, label: 'Unapprove'),
      'reject': _LegendEntry(icon: Icons.close, color: Colors.red, label: 'Reject'),
      'edit': _LegendEntry(icon: Icons.edit, color: AppTheme.primaryColor, label: 'Edit'),
      'flag': _LegendEntry(icon: Icons.flag, color: AppTheme.warningColor, label: 'Flag'),
      'delete': _LegendEntry(icon: Icons.delete, color: Colors.redAccent, label: 'Delete'),
    };

    return legendItems.entries
        .where((entry) => _isActionButtonVisible(entry.key))
        .map((entry) => entry.value)
        .toList();
  }

  Widget _buildShowingIndicator(
    bool isMobile,
    bool isTablet, {
    bool enableExport = true,
  }) {
    final filterProvider = _filterProvider;
    String viewText = 'All Transactions';
    if (_pendingApprovalsMode) {
      viewText = 'Smart Approvals';
    } else if (filterProvider.selectedType != null) {
      viewText = filterProvider.selectedType!;
      if (_selectedStatusSet.isNotEmpty) {
        viewText += _selectedStatusSet.length == 1
            ? ' - ${_selectedStatusSet.first}'
            : ' - ${_selectedStatusSet.length} statuses';
      } else if (filterProvider.selectedStatus != null) {
        viewText += ' - ${filterProvider.selectedStatus}';
      }
    }

    final legendEntries = _getVisibleLegendEntries();
    final bool hasLegend = legendEntries.isNotEmpty;
    final bool hasExportButtons = enableExport && _filteredData.isNotEmpty;

    final Widget showingInfo = Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.search, size: 18, color: AppTheme.textSecondary),
        const SizedBox(width: 8),
        Text(
          'üîç Showing: $viewText (${_filteredData.length} records)',
          style: AppTheme.bodyMedium.copyWith(
            color: AppTheme.textSecondary,
            fontSize: isMobile ? 13 : 14,
          ),
        ),
      ],
    );

    final double legendSpacing = isMobile ? 10.0 : 20.0;
    final double legendIconSize = isMobile ? 14.0 : (isTablet ? 17.0 : 18.0);
    final TextStyle legendTextStyle = AppTheme.bodySmall.copyWith(
      fontWeight: FontWeight.w600,
      fontSize: isMobile ? 11 : 13,
    );

    final Widget legendLine = hasLegend
        ? Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              for (int i = 0; i < legendEntries.length; i++) ...[
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      legendEntries[i].icon,
                      color: legendEntries[i].color,
                      size: legendIconSize,
                    ),
                    SizedBox(width: isMobile ? 4 : 6),
                    Text(
                      legendEntries[i].label,
                      style: legendTextStyle.copyWith(color: legendEntries[i].color),
                    ),
                  ],
                ),
                if (i != legendEntries.length - 1) SizedBox(width: legendSpacing),
              ],
            ],
          )
        : const SizedBox.shrink();

    final Widget legendLineMobile = hasLegend
        ? Wrap(
            spacing: legendSpacing,
            runSpacing: 8,
            children: [
              for (int i = 0; i < legendEntries.length; i++)
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      legendEntries[i].icon,
                      color: legendEntries[i].color,
                      size: legendIconSize,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      legendEntries[i].label,
                      style: legendTextStyle.copyWith(color: legendEntries[i].color),
                    ),
                  ],
                ),
            ],
          )
        : const SizedBox.shrink();

    if (isMobile) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          showingInfo,
          if (hasLegend) ...[
            const SizedBox(height: 8),
            legendLineMobile,
          ],
        ],
      );
    }

    final List<Widget> rowChildren = [
      Flexible(
        fit: FlexFit.loose,
        child: showingInfo,
      ),
    ];

    if (hasLegend) {
      rowChildren.add(const SizedBox(width: 12));
      rowChildren.add(
        Flexible(
          child: legendLine,
        ),
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: rowChildren,
    );
  }

  Widget _buildExportButtons(bool isMobile, bool isTablet, {bool isAllAccounts = false}) {
    final bool isBusy = _exportInProgress != null;
    final double iconSize = isMobile ? 14 : 16;
    final double fontSize = isMobile ? 12 : 13;

    return Builder(
      builder: (context) {
        return OutlinedButton.icon(
          onPressed: isBusy
              ? null
              : () async {
                  final RenderBox? button =
                      context.findRenderObject() as RenderBox?;
                  final OverlayState? overlayState = Overlay.of(context);
                  if (button == null || overlayState == null) {
                    return;
                  }
                  final RenderBox? overlay =
                      overlayState.context.findRenderObject() as RenderBox?;
                  if (overlay == null) {
                    return;
                  }
                  final Offset offset =
                      button.localToGlobal(Offset.zero, ancestor: overlay);
                  final RelativeRect position = RelativeRect.fromRect(
                    Rect.fromLTWH(
                      offset.dx,
                      offset.dy,
                      button.size.width,
                      button.size.height,
                    ),
                    Offset.zero & overlay.size,
                  );

                  final _ExportFormat? format = await showMenu<_ExportFormat>(
                    context: context,
                    position: position,
                    items: [
                      _buildExportMenuItem(
                        label: 'CSV',
                        icon: Icons.table_rows_outlined,
                        format: _ExportFormat.csv,
                        isMobile: isMobile,
                      ),
                      _buildExportMenuItem(
                        label: 'Excel',
                        icon: Icons.grid_on_outlined,
                        format: _ExportFormat.excel,
                        isMobile: isMobile,
                      ),
                      _buildExportMenuItem(
                        label: 'PDF',
                        icon: Icons.picture_as_pdf_outlined,
                        format: _ExportFormat.pdf,
                        isMobile: isMobile,
                      ),
                    ],
                  );

                  if (format != null) {
                    _exportTable(format, isAllAccounts: isAllAccounts);
                  }
                },
          icon: isBusy
              ? SizedBox(
                  width: iconSize,
                  height: iconSize,
                  child: const CircularProgressIndicator(strokeWidth: 2),
                )
              : Icon(Icons.download_outlined, size: iconSize),
          label: Text(
            isMobile ? 'Export' : 'Export As',
            style: AppTheme.bodySmall.copyWith(
              fontWeight: FontWeight.w600,
              fontSize: isMobile ? 11 : fontSize,
            ),
          ),
          style: OutlinedButton.styleFrom(
            padding: EdgeInsets.symmetric(
              horizontal: isMobile ? 10 : 16,
              vertical: isMobile ? 8 : 10,
            ),
            foregroundColor: AppTheme.primaryColor,
            side: BorderSide(color: AppTheme.primaryColor.withOpacity(0.6)),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
          ),
        );
      },
    );
  }

  PopupMenuItem<_ExportFormat> _buildExportMenuItem({
    required String label,
    required IconData icon,
    required _ExportFormat format,
    required bool isMobile,
  }) {
    return PopupMenuItem<_ExportFormat>(
      value: format,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: isMobile ? 18 : 20,
            color: AppTheme.primaryColor,
          ),
          const SizedBox(width: 12),
          Text(
            label,
            style: AppTheme.bodySmall.copyWith(
              fontWeight: FontWeight.w600,
              fontSize: isMobile ? 13 : 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFinancialDataTable(bool isMobile, bool isTablet, {bool isAllAccounts = false}) {
    if (_filteredData.isEmpty) {
      return Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: AppTheme.borderColor.withOpacity(0.8)),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.04),
              blurRadius: 16,
              offset: const Offset(0, 6),
            ),
            BoxShadow(
              color: Colors.black.withOpacity(0.02),
              blurRadius: 3,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.inbox_outlined, size: 48, color: AppTheme.textSecondary.withOpacity(0.5)),
          const SizedBox(height: 16),
                Text(
                  'No data found',
                  style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
                ),
              ],
            ),
          ),
        ),
      );
    }
    
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: AppTheme.borderColor.withOpacity(0.8), width: 1.1),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 18,
            offset: const Offset(0, 8),
          ),
          BoxShadow(
            color: Colors.black.withOpacity(0.02),
            blurRadius: 4,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Table Header
            if (!isMobile)
              Container(
                padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 12),
                decoration: BoxDecoration(
                  color: AppTheme.surfaceColor,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: AppTheme.borderColor.withOpacity(0.7)),
                ),
                child: Row(
                  children: [
                    if (isAllAccounts) _buildHeaderCell('Account', flex: 10, align: TextAlign.left),
                    _buildHeaderCell('Date & Time\nCreated By', flex: 10, align: TextAlign.left),
                    _buildHeaderCell('Type', flex: 8, align: TextAlign.left),
                    _buildHeaderCell('From ‚Üí To', flex: 16, align: TextAlign.left),
                    _buildHeaderCell('Mode', flex: 8, align: TextAlign.center),
                    _buildHeaderCell('Amount', flex: 7, align: TextAlign.left),
                    _buildHeaderCell('Approved By', flex: 6, align: TextAlign.left),
                    Expanded(
                      flex: 10,
                      child: Padding(
                        padding: const EdgeInsets.only(left: 24),
                        child: Align(
                          alignment: Alignment.center,
                          child: Text(
                            'Status',
                            textAlign: TextAlign.center,
                            style: AppTheme.labelMedium.copyWith(
                              fontWeight: FontWeight.w700,
                              fontSize: 13,
                              letterSpacing: 0.3,
                              height: 1.2,
                              color: AppTheme.textPrimary,
                            ),
                          ),
                        ),
                      ),
                    ),
                    Expanded(
                      flex: 12,
                      child: Padding(
                        padding: const EdgeInsets.only(right: 24),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: Text(
                            'Action',
                            textAlign: TextAlign.right,
                            style: AppTheme.labelMedium.copyWith(
                              fontWeight: FontWeight.w700,
                              fontSize: 13,
                              letterSpacing: 0.3,
                              height: 1.2,
                              color: AppTheme.textPrimary,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            if (!isMobile) const SizedBox(height: 10),
            // OPTIMIZATION: Use ListView.builder for virtualized rendering
            if (isMobile)
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: _filteredData.length,
                itemBuilder: (context, index) {
                  final itemData = _filteredData[index];
                  final item = Map<String, dynamic>.from(itemData);
                  final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? 'item_$index';
                  
                  DateTime date;
                  try {
                    date = item['date'] != null 
                        ? DateTime.parse(item['date'].toString()).toLocal()
                        : DateTime.now();
                  } catch (e) {
                    date = DateTime.now();
                  }
                  
                  final dateStr = DateFormat('dd MMM yyyy').format(date);
                  final timeStr = DateFormat('hh:mm a').format(date);
                  
                  // Extract createdBy with better fallback for collections
                  final createdByValue = item['createdBy'] ?? item['created_by'] ?? item['user'] ?? item['collectedBy'] ?? item['performedBy'] ?? item['sender'] ?? item['initiatedBy'];
                  String createdBy;
                  if (createdByValue is Map) {
                    createdBy = createdByValue['name']?.toString() ?? createdByValue['fullName']?.toString() ?? createdByValue['displayName']?.toString() ?? '-';
                  } else {
                    createdBy = _displayValue(createdByValue);
                  }
                  // If still empty or "-", try to get from 'from' field (for collections, from = collectedBy)
                  if ((createdBy.isEmpty || createdBy == '-') && item['type'] == 'Collections') {
                    createdBy = _displayValue(item['from']);
                  }
                  // If still empty, try 'from' field for other types too
                  if ((createdBy.isEmpty || createdBy == '-') && item['from'] != null) {
                    final fromValue = item['from'];
                    if (fromValue is Map) {
                      createdBy = fromValue['name']?.toString() ?? fromValue['fullName']?.toString() ?? fromValue['displayName']?.toString() ?? '-';
                    } else {
                      final fromStr = _displayValue(fromValue);
                      if (fromStr.isNotEmpty && fromStr != '-') {
                        createdBy = fromStr;
                      }
                    }
                  }
                  
                  final type = _displayValue(item['type']);
                  final from = _displayValue(item['from']);
                  String to = _displayValue(item['to']);
                  // For expenses, show expense type name in "to" field
                  if (type == 'Expenses') {
                    to = _displayValue(item['category'] ?? item['expenseType'] ?? item['to']);
                  }
                  final mode = _displayValue(item['mode']);
                  final amount = _formatAmount(_parseAmount(item['amount']));
                  final status = _displayValue(item['status']);
                  final accountName = isAllAccounts 
                      ? _displayValue(item['accountName'] ?? item['account'] ?? item['accountId'] ?? 'N/A')
                      : null;
                  
                  return _buildTransactionCard(context, dateStr, timeStr, createdBy, type, from, to, mode, amount, status, item, accountName: accountName, isAllAccounts: isAllAccounts);
                },
                key: const PageStorageKey('mobile_transaction_list'),
              )
            else
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: _filteredData.length,
                cacheExtent: 500, // Cache 500 pixels worth of items
                itemBuilder: (context, index) {
                  final itemData = _filteredData[index];
                  final item = Map<String, dynamic>.from(itemData);
                  final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? 'item_$index';
                  
                  DateTime date;
                  try {
                    date = item['date'] != null 
                        ? DateTime.parse(item['date'].toString()).toLocal()
                        : DateTime.now();
                  } catch (e) {
                    date = DateTime.now();
                  }
                  
                  final dateStr = DateFormat('dd MMM yyyy').format(date);
                  final timeStr = DateFormat('hh:mm a').format(date);
                  
                  // Extract createdBy with better fallback for collections
                  final createdByValue = item['createdBy'] ?? item['created_by'] ?? item['user'] ?? item['collectedBy'] ?? item['performedBy'] ?? item['sender'] ?? item['initiatedBy'];
                  String createdBy;
                  if (createdByValue is Map) {
                    createdBy = createdByValue['name']?.toString() ?? createdByValue['fullName']?.toString() ?? createdByValue['displayName']?.toString() ?? '-';
                  } else {
                    createdBy = _displayValue(createdByValue);
                  }
                  // If still empty or "-", try to get from 'from' field (for collections, from = collectedBy)
                  if ((createdBy.isEmpty || createdBy == '-') && item['type'] == 'Collections') {
                    createdBy = _displayValue(item['from']);
                  }
                  // If still empty, try 'from' field for other types too
                  if ((createdBy.isEmpty || createdBy == '-') && item['from'] != null) {
                    final fromValue = item['from'];
                    if (fromValue is Map) {
                      createdBy = fromValue['name']?.toString() ?? fromValue['fullName']?.toString() ?? fromValue['displayName']?.toString() ?? '-';
                    } else {
                      final fromStr = _displayValue(fromValue);
                      if (fromStr.isNotEmpty && fromStr != '-') {
                        createdBy = fromStr;
                      }
                    }
                  }
                  
                  final type = _displayValue(item['type']);
                  final from = _displayValue(item['from']);
                  String to = _displayValue(item['to']);
                  // For expenses, show expense type name in "to" field
                  if (type == 'Expenses') {
                    to = _displayValue(item['category'] ?? item['expenseType'] ?? item['to']);
                  }
                  final mode = _displayValue(item['mode']);
                  final amount = _formatAmount(_parseAmount(item['amount']));
                  // Extract approvedBy name properly for expenses
                  String approvedBy = '-';
                  // First check if approvedByName field exists (set during data conversion)
                  final approvedByName = item['approvedByName'] ?? item['approved_by_name'];
                  if (approvedByName != null && approvedByName.toString().trim().isNotEmpty) {
                    approvedBy = approvedByName.toString().trim();
                  } else {
                    // Extract from approvedBy field
                    final approvedByValue = item['approvedBy'] ?? item['approved_by'];
                    if (approvedByValue != null) {
                      if (approvedByValue is Map) {
                        approvedBy = approvedByValue['name']?.toString() ?? 
                                    approvedByValue['fullName']?.toString() ?? 
                                    approvedByValue['displayName']?.toString() ?? 
                                    '-';
                      } else if (approvedByValue is String) {
                        final value = approvedByValue.trim();
                        // If it looks like an ID (hex pattern with spaces), skip it and show '-'
                        if (value.isNotEmpty && !RegExp(r'^[a-f0-9\s]{15,}$', caseSensitive: false).hasMatch(value)) {
                          approvedBy = value;
                        }
                      }
                    }
                  }
                  final status = _displayValue(item['status']);
                  final accountName = isAllAccounts 
                      ? _displayValue(item['accountName'] ?? item['account'] ?? item['accountId'] ?? item['mode'] ?? 'Cash')
                      : null;
                  
                  return _buildTransactionRow(dateStr, timeStr, createdBy, type, from, to, mode, amount, approvedBy, status, index, item, accountName: accountName, isAllAccounts: isAllAccounts);
                },
                key: const PageStorageKey('desktop_transaction_list'),
              ),
          ],
        ),
      ),
    );
  }
  Future<void> _exportTable(_ExportFormat format, {bool isAllAccounts = false}) async {
    if (_filteredData.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No data available to export.'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    if (kIsWeb && format != _ExportFormat.pdf) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('CSV and Excel export are only available on mobile or desktop for now.'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    setState(() {
      _exportInProgress = format;
    });

    try {
      final exportData = _buildTableExportData(isAllAccounts: isAllAccounts);
      switch (format) {
        case _ExportFormat.csv:
          await _exportCsv(exportData);
          break;
        case _ExportFormat.excel:
          await _exportExcel(exportData);
          break;
        case _ExportFormat.pdf:
          await _exportPdf(exportData);
          break;
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Exported ${_describeExportFormat(format)} successfully.'),
          behavior: SnackBarBehavior.floating,
        ),
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to export: ${e.toString()}'),
            behavior: SnackBarBehavior.floating,
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _exportInProgress = null;
        });
      }
    }
  }

  String _describeExportFormat(_ExportFormat format) {
    switch (format) {
      case _ExportFormat.csv:
        return 'CSV';
      case _ExportFormat.excel:
        return 'Excel';
      case _ExportFormat.pdf:
        return 'PDF';
    }
  }

  Future<void> _exportCsv(_TableExportData exportData) async {
    final List<List<String>> data = [
      exportData.headers,
      ...exportData.rows,
    ];
    final String csvString = ListToCsvConverter().convert(data);
    final Uint8List bytes = Uint8List.fromList(utf8.encode(csvString));
    final File file = await _writeBytesToTempFile(bytes, 'csv');
    await _notifyFileSaved(file, description: 'CSV file saved');
  }

  Future<void> _exportExcel(_TableExportData exportData) async {
    final xlsio.Workbook workbook = xlsio.Workbook();
    final xlsio.Worksheet sheet = workbook.worksheets[0];
    sheet.name = 'Wallet Report';

    for (int c = 0; c < exportData.headers.length; c++) {
      sheet.getRangeByIndex(1, c + 1).setText(exportData.headers[c]);
    }

    for (int r = 0; r < exportData.rows.length; r++) {
      final row = exportData.rows[r];
      for (int c = 0; c < row.length; c++) {
        if (c == 7) {
          sheet.getRangeByIndex(r + 2, c + 1).setNumber(exportData.amountValues[r]);
          sheet.getRangeByIndex(r + 2, c + 1).numberFormat = r'"‚Çπ"#,##0.00';
        } else {
          sheet.getRangeByIndex(r + 2, c + 1).setText(row[c]);
        }
      }
    }

    final int lastRow = exportData.rows.length + 1;
    final int lastColumn = exportData.headers.length;
    sheet.getRangeByIndex(1, 1, lastRow, lastColumn).autoFitColumns();

    final List<int> bytes = workbook.saveAsStream();
    workbook.dispose();
    final File file = await _writeBytesToTempFile(Uint8List.fromList(bytes), 'xlsx');

    await _notifyFileSaved(file, description: 'Excel file saved');
  }

  Future<void> _exportPdf(_TableExportData exportData) async {
    final String fileName = _buildExportFileName('pdf');
    final pw.Document pdf = pw.Document();

    final List<List<String>> pdfRows = exportData.rows.map((row) {
      final updated = List<String>.from(row);
      if (updated.length > 7) {
        updated[7] = updated[7].replaceAll('‚Çπ', 'INR ');
      }
      return updated;
    }).toList();

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4.landscape,
        build: (context) => [
          pw.Text(
            'Wallet Report',
            style: pw.TextStyle(
              fontSize: 18,
              fontWeight: pw.FontWeight.bold,
            ),
          ),
          pw.SizedBox(height: 12),
          pw.Table.fromTextArray(
            headers: exportData.headers,
            data: pdfRows,
            cellAlignment: pw.Alignment.centerLeft,
            headerDecoration: pw.BoxDecoration(color: PdfColors.grey300),
            headerStyle: pw.TextStyle(
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.black,
            ),
            rowDecoration: pw.BoxDecoration(
              border: pw.TableBorder(
                horizontalInside: pw.BorderSide(color: PdfColors.grey400, width: 0.3),
              ),
            ),
            cellStyle: const pw.TextStyle(fontSize: 10),
          ),
        ],
      ),
    );

    final Uint8List bytes = await pdf.save();
    await Printing.sharePdf(bytes: bytes, filename: fileName);
  }

  Future<File> _writeBytesToTempFile(Uint8List bytes, String extension) async {
    final Directory directory = await getTemporaryDirectory();
    final String filePath = '${directory.path}/${_buildExportFileName(extension)}';
    final File file = File(filePath);
    await file.writeAsBytes(bytes, flush: true);
    return file;
  }

  String _buildExportFileName(String extension) {
    final String datePart = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final String timePart = DateFormat('HHmmss').format(DateTime.now());
    return 'Recording $datePart $timePart.$extension';
  }

  Future<void> _notifyFileSaved(File file, {required String description}) async {
    if (!mounted) return;
    final String fileName = file.path.split(Platform.pathSeparator).last;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$description\nSaved to: ${file.parent.path}',
            style: AppTheme.bodySmall.copyWith(color: Colors.white)),
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 5),
      ),
    );
  }

  Widget _buildTransactionRow(
    String date,
    String time,
    String createdBy,
    String type,
    String from,
    String to,
    String mode,
    String amount,
    String approvedBy,
    String status,
    int index,
    Map<String, dynamic> item, {
    String? accountName,
    bool isAllAccounts = false,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: index % 2 == 0 ? Colors.transparent : AppTheme.surfaceColor.withOpacity(0.3),
        border: Border(
          bottom: BorderSide(color: AppTheme.borderColor.withOpacity(0.5), width: 1),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 8),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            if (isAllAccounts)
              Expanded(
                flex: 10,
                child: _buildAccountNameColumn(accountName ?? 'Cash'),
              ),
            // Date & Time + Created By
            Expanded(
              flex: 10,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(date, style: AppTheme.bodyMedium.copyWith(fontWeight: FontWeight.w500, fontSize: 14)),
                  Text(time, style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary, fontSize: 12)),
                  const SizedBox(height: 2),
          Text(
                    'By: $createdBy',
                    style: AppTheme.bodySmall.copyWith(
                      color: AppTheme.textSecondary,
                      fontSize: 11,
                    ),
                  ),
                ],
              ),
            ),
            // Type
            Expanded(flex: 8, child: Text(type, style: AppTheme.bodyMedium)),
            // From ‚Üí To
            Expanded(
              flex: 16,
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Flexible(
                    flex: 1,
                    child: Text(
                      from,
                      style: AppTheme.bodyMedium,
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 6),
                    child: Icon(Icons.arrow_forward, size: 12, color: AppTheme.textSecondary.withOpacity(0.7)),
                  ),
                  Flexible(
                    flex: 1,
                    child: Text(
                      to,
                      style: AppTheme.bodyMedium,
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  ),
                ],
              ),
            ),
            // Mode (always visible, after "From ‚Üí To")
            Expanded(
              flex: 8,
              child: Align(
                alignment: Alignment.center,
                child: _buildModeBadge(mode),
              ),
            ),
            // Amount
            Expanded(
              flex: 7,
              child: Padding(
                padding: const EdgeInsets.only(left: 0),
                child: Text(
                  amount,
                  style: AppTheme.bodyMedium.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                  textAlign: TextAlign.left,
                ),
              ),
            ),
            // Approved By
            Expanded(
              flex: 6,
              child: Padding(
                padding: const EdgeInsets.only(left: 2),
                child: Text(
                  approvedBy,
                  style: AppTheme.bodyMedium,
                  textAlign: TextAlign.left,
                  overflow: TextOverflow.visible,
                  softWrap: true,
                  maxLines: 2,
                ),
              ),
            ),
            // Status
            Expanded(
              flex: 10,
              child: Padding(
                padding: const EdgeInsets.only(left: 24),
              child: Align(
                alignment: Alignment.center,
                child: _buildStatusChip(status),
              ),
            ),
            ),
            // Actions (visible for All Account Reports)
            Expanded(
              flex: 12,
              child: Padding(
                padding: const EdgeInsets.only(right: 24),
              child: Align(
                  alignment: Alignment.centerRight,
                  child: _buildActionButtons(item, status, isAllAccounts: isAllAccounts),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeaderCell(
    String title, {
    required int flex,
    TextAlign align = TextAlign.left,
  }) {
    return Expanded(
      flex: flex,
      child: Align(
        alignment: align == TextAlign.center
            ? Alignment.center
            : align == TextAlign.right
                ? Alignment.centerRight
                : Alignment.centerLeft,
        child: Text(
          title,
          textAlign: align,
          style: AppTheme.labelMedium.copyWith(
            fontWeight: FontWeight.w700,
            fontSize: 13,
            letterSpacing: 0.3,
            height: 1.2,
          ),
        ),
      ),
    );
  }

  Widget _buildAccountNameColumn(String accountName) {
    // Split account name into bank name and account number
    // Format: "ICICI Bank **** 5678" or "HDFC Bank ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234"
    String bankName = accountName;
    String accountNumber = '';
    
    // Try to split by common patterns
    if (accountName.contains('‚Ä¢‚Ä¢‚Ä¢‚Ä¢') || accountName.contains('****')) {
      final parts = accountName.split(RegExp(r'[‚Ä¢*]{4}'));
      if (parts.length >= 2) {
        bankName = parts[0].trim();
        accountNumber = '${accountName.contains('‚Ä¢‚Ä¢‚Ä¢‚Ä¢') ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : '****'}${parts[1].trim()}';
      } else if (parts.length == 1) {
        bankName = parts[0].trim();
        // Extract the masked part and number
        final match = RegExp(r'([‚Ä¢*]{4})\s*(\d+)').firstMatch(accountName);
        if (match != null) {
          accountNumber = '${match.group(1)} ${match.group(2)}';
        }
      }
    } else {
      // Try to split by last space or number pattern
      final match = RegExp(r'^(.+?)\s+(\d+.*)$').firstMatch(accountName);
      if (match != null) {
        bankName = match.group(1) ?? accountName;
        accountNumber = match.group(2) ?? '';
      }
    }
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          bankName,
          style: AppTheme.bodyMedium.copyWith(
            fontWeight: FontWeight.w500,
            fontSize: 14,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        if (accountNumber.isNotEmpty)
          Text(
            accountNumber,
            style: AppTheme.bodySmall.copyWith(
              color: AppTheme.textSecondary,
              fontSize: 12,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
      ],
    );
  }

  Widget _buildTransactionCard(
    BuildContext context,
    String date,
    String time,
    String createdBy,
    String type,
    String from,
    String to,
    String mode,
    String amount,
    String status,
    Map<String, dynamic> item, {
    String? accountName,
    bool isAllAccounts = false,
  }) {
    // Determine item type for handling tap
    final itemType = item['type']?.toString() ?? '';
    
    // Handle tap on card - open appropriate edit dialog
    void handleCardTap() {
      if (itemType == 'Collections') {
        _showEditCollectionDialog(item);
      } else if (itemType == 'Expenses') {
        _showEditExpenseDialog(item);
      } else if (itemType == 'Transactions') {
        _showNewAddTransactionDialog(
          existingTransactionData: item,
          isEditMode: true,
        );
      }
    }
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: handleCardTap,
          borderRadius: BorderRadius.circular(12),
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
            if (isAllAccounts && accountName != null) ...[
              Row(
                children: [
                  Icon(Icons.account_balance_wallet_outlined, size: 16, color: AppTheme.primaryColor),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      'Account: $accountName',
                      style: AppTheme.bodyMedium.copyWith(
                        fontWeight: FontWeight.w600,
                        color: AppTheme.primaryColor,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('$date ‚Ä¢ $time', style: AppTheme.bodySmall),
                    Text('By: $createdBy', style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary, fontSize: 11)),
                  ],
                ),
                _buildStatusChip(status),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Text('Type: ', style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary)),
                Text(type, style: AppTheme.bodyMedium),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                Text('From ‚Üí To: ', style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary)),
                Expanded(
                  child: Row(
                    children: [
                      Expanded(child: Text(from, style: AppTheme.bodyMedium, overflow: TextOverflow.ellipsis)),
                      Icon(Icons.arrow_forward, size: 14, color: AppTheme.textSecondary),
                      Expanded(child: Text(to, style: AppTheme.bodyMedium, overflow: TextOverflow.ellipsis)),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(amount, style: AppTheme.headingSmall),
                _buildModeBadge(mode),
              ],
            ),
            const SizedBox(height: 8),
            // Actions for mobile (visible for All Account Reports)
            Builder(
              builder: (context) {
                final buttons = _buildActionIconButtons(
                  item,
                  item['status']?.toString() ?? '',
                  iconSize: 18,
                  isAllAccounts: isAllAccounts,
                );

                if (buttons.isEmpty) {
                  return const SizedBox.shrink();
                }

                return Wrap(
                  alignment: WrapAlignment.end,
                  spacing: 6,
                  runSpacing: 6,
                  children: buttons,
                );
              },
            ),
          ],
        ),
        ),
        ),
      ),
    );
  }

  Widget _buildModeBadge(String mode) {
    if (mode.isEmpty || mode == '-') {
      return const SizedBox.shrink();
    }
    
    Color color;
    IconData icon;
    
    switch (mode.toUpperCase()) {
      case 'CASH':
        color = Colors.green;
        icon = Icons.money;
        break;
      case 'UPI':
        color = Colors.purple;
        icon = Icons.qr_code;
        break;
      case 'BANK':
        color = Colors.blue;
        icon = Icons.account_balance;
        break;
      default:
        color = AppTheme.textSecondary;
        icon = Icons.payment;
    }
    
    return Container(
      constraints: const BoxConstraints(minWidth: 55),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 5),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: color.withOpacity(0.4), width: 1.2),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Icon(icon, size: 13, color: color),
          const SizedBox(width: 4),
          Flexible(
            child: Text(
              mode,
              style: TextStyle(
                color: color,
                fontWeight: FontWeight.w600,
                fontSize: 11,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionIconButton({
    required IconData icon,
    required Color color,
    required String tooltip,
    required VoidCallback onPressed,
    double iconSize = 20,
  }) {
    final double dimension = iconSize + 16;
    return SizedBox(
      width: dimension,
      height: dimension,
      child: IconButton(
        icon: Icon(icon, color: color, size: iconSize),
        onPressed: onPressed,
        tooltip: tooltip,
        splashRadius: iconSize + 6,
        padding: EdgeInsets.zero,
        constraints: const BoxConstraints(),
      ),
    );
  }

  Widget _buildActionControl({
    required String key,
    required IconData icon,
    required Color color,
    required String label,
    required Future<void> Function() onExecute,
    double iconSize = 20,
    Future<void> Function(String reason)? onExecuteWithReason,
  }) {
    // Work like Smart Approvals: direct execution for most actions,
    // show dialog only for reject/flag when reason is needed
    final VoidCallback onPressed = () async {
      // For reject and flag, show dialog to get reason if onExecuteWithReason is provided
      if ((key == 'reject' || key == 'flag') && onExecuteWithReason != null) {
        final reasonController = TextEditingController();
        final result = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(key == 'reject' ? 'Reject Item' : 'Flag for Review'),
            content: TextField(
              controller: reasonController,
              decoration: InputDecoration(
                labelText: key == 'reject' ? 'Rejection Reason' : 'Flag Reason',
                hintText: key == 'reject' 
                    ? 'Enter reason for rejection...' 
                    : 'Enter reason for flagging...',
              ),
              maxLines: 3,
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: () {
                  if (key == 'flag' && reasonController.text.trim().isEmpty) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Please provide a flag reason'),
                        backgroundColor: AppTheme.errorColor,
                      ),
                    );
                    return;
                  }
                  Navigator.pop(context, true);
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: key == 'reject' ? AppTheme.errorColor : AppTheme.warningColor,
                ),
                child: Text(key == 'reject' ? 'Reject' : 'Flag'),
              ),
            ],
          ),
        );
        
        if (result == true && mounted) {
          await onExecuteWithReason(reasonController.text.trim());
        }
      } else {
        // For other actions (approve, edit, delete, unapprove), execute directly
        await onExecute();
      }
    };

    return _buildActionIconButton(
      icon: icon,
      color: color,
      tooltip: label,
      onPressed: onPressed,
      iconSize: iconSize,
    );
  }

  List<Widget> _buildActionIconButtons(
    Map<String, dynamic> item,
    String status, {
    double iconSize = 20,
    bool isAllAccounts = false,
  }) {
    final itemType = item['type'] as String? ?? '';
    final config = _resolveRowActions(status, itemType);
    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    final List<Widget> widgets = [];

    void addAction({
      required String key,
      required bool condition,
      required IconData icon,
      required Color color,
      required String tooltip,
      required Future<void> Function() onExecute,
      Future<void> Function(String reason)? onExecuteWithReason,
    }) {
      if (!condition || !_isActionButtonVisible(key)) return;
      widgets.add(
        _buildActionControl(
          key: key,
          icon: icon,
          color: color,
          label: tooltip,
          onExecute: onExecute,
          onExecuteWithReason: onExecuteWithReason,
          iconSize: iconSize,
        ),
      );
    }

    // For All Account Reports, show action buttons based on permissions and status
    // All actions should work even when status is "Approved" or "Completed" if permission allows
    if (isAllAccounts) {
      // In All Wallet Report, check permissions based on item type
      final bool hasItemType = itemType.isNotEmpty;
      
      // Determine permission flags based on item type for All Wallet Report
      bool canApprove = false;
      bool canUnapprove = false;
      bool canReject = false;
      bool canEdit = false;
      bool canFlag = false;
      bool canDelete = false;
      
      // Super Admin bypass: Super Admin can do all actions
      if (_isSuperAdmin) {
        canApprove = true;
        canUnapprove = true;
        canReject = true;
        canEdit = true;
        canFlag = true;
        canDelete = true;
      } else {
        // Check permissions based on item type for non-Super Admin
        // Normalize item type for comparison (handle case variations)
        final normalizedType = itemType.trim();
        
        if (normalizedType == 'Transactions' || normalizedType.toLowerCase() == 'transactions') {
          canApprove = _canApproveReportTransaction;
          canUnapprove = _canApproveReportTransaction; // Unapprove uses same permission as approve
          canReject = _canRejectReportTransaction;
          canEdit = _canEditReportTransaction;
          canFlag = _canFlagReportTransaction;
          canDelete = _canDeleteReportTransaction;
          
          // Debug logging
          debugPrint('üîç [ALL WALLET REPORT] Transactions permissions - approve=$canApprove, edit=$canEdit, delete=$canDelete, reject=$canReject, flag=$canFlag');
        } else if (normalizedType == 'Expenses' || normalizedType.toLowerCase() == 'expenses') {
          canApprove = _canApproveReportExpenses;
          canUnapprove = _canApproveReportExpenses;
          canReject = _canRejectReportExpenses;
          canEdit = _canEditReportExpenses;
          canFlag = _canFlagReportExpenses;
          canDelete = _canDeleteReportExpenses;
          
          // Debug logging
          debugPrint('üîç [ALL WALLET REPORT] Expenses permissions - approve=$canApprove, edit=$canEdit, delete=$canDelete, reject=$canReject, flag=$canFlag');
        } else if (normalizedType == 'Collections' || normalizedType.toLowerCase() == 'collections') {
          canApprove = _canApproveReportCollection;
          canUnapprove = _canApproveReportCollection;
          canReject = _canRejectReportCollection;
          canEdit = _canEditReportCollection;
          canFlag = _canFlagReportCollection;
          canDelete = _canDeleteReportCollection;
          
          // Debug logging
          debugPrint('üîç [ALL WALLET REPORT] Collections permissions - approve=$canApprove, edit=$canEdit, delete=$canDelete, reject=$canReject, flag=$canFlag');
        } else {
          // Debug: Log if item type doesn't match expected values
          if (hasItemType) {
            debugPrint('‚ö†Ô∏è [ALL WALLET REPORT] Unknown item type: "$itemType" (normalized: "$normalizedType")');
          }
        }
      }
      
      addAction(
        key: 'approve',
        condition: canApprove && status.toLowerCase() != 'approved' && status.toLowerCase() != 'completed',
        icon: Icons.check,
        color: Colors.green,
        tooltip: 'Approve',
        onExecute: () => _handleApprove(item),
      );

      addAction(
        key: 'unapprove',
        condition: canUnapprove && (status.toLowerCase() == 'approved' || status.toLowerCase() == 'completed'),
        icon: Icons.undo,
        color: Colors.orange,
        tooltip: 'Unapprove',
        onExecute: () => _handleUnapprove(item),
      );

      addAction(
        key: 'reject',
        condition: canReject, // Check permission for reject in All Wallet Report
        icon: Icons.close,
        color: Colors.red,
        tooltip: 'Reject',
        onExecute: () => _handleReject(item),
        onExecuteWithReason: (reason) => _handleReject(item, reason: reason),
      );

      addAction(
        key: 'edit',
        condition: canEdit && hasItemType, // Check permission and item type exists
        icon: Icons.edit,
        color: AppTheme.primaryColor,
        tooltip: 'Edit',
        onExecute: () => _handleEdit(item),
      );

      addAction(
        key: 'flag',
        condition: canFlag, // Check permission for flag in All Wallet Report
        icon: Icons.flag,
        color: AppTheme.warningColor,
        tooltip: 'Flag',
        onExecute: () => _handleFlag(item),
        onExecuteWithReason: (reason) => _handleFlag(item, reason: reason),
      );

      addAction(
        key: 'delete',
        condition: canDelete && hasItemType, // Check permission and item type exists
        icon: Icons.delete,
        color: Colors.redAccent,
        tooltip: 'Delete',
        onExecute: () => _handleDelete(item),
      );
    } else {
      // For Self Wallet and other views, check permissions based on item type
      final bool enableForSelfWallet = isSelfWallet && itemType.isNotEmpty;
      
      // Determine permission flags based on item type
      bool canApprove = config.canApprove;
      bool canUnapprove = config.canUnapprove;
      bool canReject = config.canReject;
      bool canEdit = config.canEdit;
      bool canFlag = config.canFlag;
      bool canDelete = config.canDelete;
      
      if (enableForSelfWallet) {
        // For Transactions: ONLY receiver can approve (no exceptions, not even SuperAdmin)
        // For other item types: Super Admin can do all actions
        if (itemType == 'Transactions') {
          // For transactions, receiver check is done in handler (async)
          // Button will be enabled if user has permission, but handler will validate receiver
          // This ensures only receiver can actually approve
          canApprove = _canApproveTransaction; // Permission check, receiver validation in handler
          canUnapprove = _canApproveTransaction; // Unapprove uses same permission as approve
          canReject = _canRejectTransaction;
          canEdit = _canEditTransaction;
          canFlag = _canFlagTransaction;
          canDelete = _canDeleteTransaction;
        } else if (_isSuperAdmin) {
          // Super Admin bypass: Super Admin can do all actions (for non-transactions)
          canApprove = true;
          canUnapprove = true;
          canReject = true;
          canEdit = true;
          canFlag = true;
          canDelete = true;
        } else {
          // Check permissions based on item type for non-Super Admin
          if (itemType == 'Expenses') {
            // ALL users can approve expenses (not just SuperAdmin)
            canApprove = true;
            canUnapprove = true;
            canReject = _canRejectExpenses;
            canEdit = _canEditExpenses;
            canFlag = _canFlagExpenses;
            canDelete = _canDeleteExpenses;
          } else if (itemType == 'Collections') {
            canApprove = _canApproveCollection;
            canUnapprove = _canApproveCollection;
            canReject = _canRejectCollection;
            canEdit = _canEditCollection;
            canFlag = _canFlagCollection;
            canDelete = _canDeleteCollection;
          }
        }
      }
      
      // For Self Wallet: Disable all actions when status is Approved/Completed
      // For other views: Allow actions based on permissions
      final bool isApprovedOrCompleted = status.toLowerCase() == 'approved' || status.toLowerCase() == 'completed';
      final bool shouldDisableActions = enableForSelfWallet && isApprovedOrCompleted;
      
      addAction(
        key: 'approve',
        condition: canApprove && status.toLowerCase() != 'approved' && status.toLowerCase() != 'completed',
        icon: Icons.check,
        color: Colors.green,
        tooltip: 'Approve',
        onExecute: () => _handleApprove(item),
      );

      addAction(
        key: 'unapprove',
        condition: canUnapprove && (status.toLowerCase() == 'approved' || status.toLowerCase() == 'completed') && !shouldDisableActions,
        icon: Icons.undo,
        color: Colors.orange,
        tooltip: 'Unapprove',
        onExecute: () => _handleUnapprove(item),
      );
      
      addAction(
        key: 'reject',
        condition: canReject && !shouldDisableActions,
        icon: Icons.close,
        color: Colors.red,
        tooltip: 'Reject',
        onExecute: () => _handleReject(item),
        onExecuteWithReason: (reason) => _handleReject(item, reason: reason),
      );

      addAction(
        key: 'edit',
        condition: canEdit && !shouldDisableActions,
        icon: Icons.edit,
        color: AppTheme.primaryColor,
        tooltip: 'Edit',
        onExecute: () => _handleEdit(item),
      );

      addAction(
        key: 'flag',
        condition: canFlag && !shouldDisableActions,
        icon: Icons.flag,
        color: AppTheme.warningColor,
        tooltip: 'Flag',
        onExecute: () => _handleFlag(item),
        onExecuteWithReason: (reason) => _handleFlag(item, reason: reason),
      );

      addAction(
        key: 'delete',
        condition: canDelete && !shouldDisableActions,
        icon: Icons.delete,
        color: Colors.redAccent,
        tooltip: 'Delete',
        onExecute: () => _handleDelete(item),
      );
    }

    return widgets;
  }

  Widget _buildActionButtons(Map<String, dynamic> item, String status, {bool isAllAccounts = false}) {
    final buttons = _buildActionIconButtons(item, status, isAllAccounts: isAllAccounts);

    if (buttons.isEmpty) {
      return const SizedBox.shrink();
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          for (var i = 0; i < buttons.length; i++) ...[
            if (i > 0) const SizedBox(width: 8),
            buttons[i],
          ],
        ],
      ),
    );
  }

  Future<void> _handleApprove(Map<String, dynamic> item) async {
    try {
      final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
      final itemType = item['type'] as String? ?? '';
      final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
      final bool isAllWalletReport = _selectedItem == NavItem.walletOverview;
      
      if (itemId.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Item ID not found')),
        );
        return;
      }

      // Check permissions for Self Wallet
      if (isSelfWallet) {
        final bool isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
        
        // For Transactions: ONLY the receiver can approve (no exceptions, not even SuperAdmin)
        if (itemType == 'Transactions') {
          // Check if current user is the receiver
          final currentUserId = await AuthService.getUserId();
          final receiver = item['receiver'];
          final receiverId = receiver is Map 
              ? (receiver['_id'] ?? receiver['id'])?.toString()
              : receiver?.toString();
          
          if (currentUserId == null || receiverId == null || currentUserId != receiverId) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Only the receiver can approve this transaction'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          }
        } else if (!isSuperAdmin) {
          // Expenses: ALL users can approve (permission check removed)
          // Only check permission for Collections
          if (itemType == 'Collections' && !_canApproveCollection) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to approve collections'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          }
        }
      }

      Map<String, dynamic> result;
      String successMessage = 'Item approved successfully';
      String errorMessage = 'Failed to approve item';

      if (itemType == 'Transactions') {
        result = await TransactionService.approveTransaction(itemId, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Transaction approved successfully';
        errorMessage = 'Failed to approve transaction';
      } else if (itemType == 'Expenses') {
        result = await ExpenseService.approveExpense(itemId, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Expense approved successfully';
        errorMessage = 'Failed to approve expense';
      } else if (itemType == 'Collections') {
        result = await CollectionService.approveCollection(itemId, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Collection approved successfully';
        errorMessage = 'Failed to approve collection';
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Unknown item type')),
        );
        return;
      }

      if (mounted) {
        if (result['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? successMessage),
              backgroundColor: Colors.green,
            ),
          );
          // Refresh both dashboard and financial data
          _loadDashboardData();
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? errorMessage),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
  Future<void> _handleUnapprove(Map<String, dynamic> item) async {
    try {
      final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
      final itemType = item['type'] as String? ?? '';
      final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
      final bool isAllWalletReport = _selectedItem == NavItem.walletOverview;

      if (itemId.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Item ID not found')),
        );
        return;
      }

      // Check permissions for Self Wallet (unapprove uses same permission as approve) - Super Admin bypass
      if (isSelfWallet) {
        final bool isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
        if (!isSuperAdmin) {
          if (itemType == 'Transactions' && !_canApproveTransaction) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to unapprove transactions'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          // Expenses: ALL users can unapprove (permission check removed)
          // Only check permission for Collections
          } else if (itemType == 'Collections' && !_canApproveCollection) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to unapprove collections'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          }
        }
      }

      Map<String, dynamic> result;
      String successMessage = 'Item moved to unapproved';
      String errorMessage = 'Failed to move item to unapproved';

      if (itemType == 'Transactions') {
        result = await TransactionService.cancelTransaction(itemId, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Transaction marked as unapproved';
        errorMessage = 'Failed to unapprove transaction';
      } else if (itemType == 'Expenses') {
        result = await ExpenseService.updateExpenseStatus(itemId, 'Unapproved', fromAllWalletReport: isAllWalletReport);
        successMessage = 'Expense marked as unapproved';
        errorMessage = 'Failed to unapprove expense';
      } else if (itemType == 'Collections') {
        result = await CollectionService.restoreCollection(itemId, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Collection sent back for review';
        errorMessage = 'Failed to unapprove collection';
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Unknown item type')),
        );
        return;
      }

      if (mounted) {
        if (result['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? successMessage),
              backgroundColor: AppTheme.warningColor,
            ),
          );
          _loadDashboardData();
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? errorMessage),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _handleReject(
    Map<String, dynamic> item, {
    String? reason,
  }) async {
    try {
      final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
      final itemType = item['type'] as String? ?? '';
      final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
      final bool isAllWalletReport = _selectedItem == NavItem.walletOverview;
      
      if (itemId.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Item ID not found')),
        );
        return;
      }

      // Check permissions for Self Wallet (Super Admin bypass)
      if (isSelfWallet) {
        final bool isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
        if (!isSuperAdmin) {
          if (itemType == 'Transactions' && !_canRejectTransaction) {
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('You do not have permission to reject transactions'),
                  backgroundColor: AppTheme.errorColor,
                ),
              );
            }
            return;
          } else if (itemType == 'Expenses' && !_canRejectExpenses) {
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('You do not have permission to reject expenses'),
                  backgroundColor: AppTheme.errorColor,
                ),
              );
            }
            return;
          } else if (itemType == 'Collections' && !_canRejectCollection) {
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('You do not have permission to reject collections'),
                  backgroundColor: AppTheme.errorColor,
                ),
              );
            }
            return;
          }
        }
      }

      final String resolvedReason =
          (reason != null && reason.trim().isNotEmpty) ? reason.trim() : 'Rejected from dashboard';

      Map<String, dynamic> result;
      String successMessage = 'Item rejected successfully';
      String errorMessage = 'Failed to reject item';

      if (itemType == 'Transactions') {
        result = await TransactionService.rejectTransaction(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Transaction rejected successfully';
        errorMessage = 'Failed to reject transaction';
      } else if (itemType == 'Expenses') {
        result = await ExpenseService.rejectExpense(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Expense rejected successfully';
        errorMessage = 'Failed to reject expense';
      } else if (itemType == 'Collections') {
        result = await CollectionService.rejectCollection(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Collection rejected successfully';
        errorMessage = 'Failed to reject collection';
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Unknown item type')),
          );
        }
        return;
      }

      if (mounted) {
        if (result['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? successMessage),
              backgroundColor: Colors.green,
            ),
          );
          // Refresh both dashboard and financial data
          _loadDashboardData();
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? errorMessage),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _handleFlag(
    Map<String, dynamic> item, {
    String? reason,
  }) async {
    try {
      final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
      final itemType = item['type'] as String? ?? '';
      final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
      final bool isAllWalletReport = _selectedItem == NavItem.walletOverview;

      if (itemId.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Item ID not found')),
        );
        return;
      }

      // Check permissions for Self Wallet (Super Admin bypass)
      if (isSelfWallet) {
        final bool isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
        if (!isSuperAdmin) {
          if (itemType == 'Transactions' && !_canFlagTransaction) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to flag transactions'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          } else if (itemType == 'Expenses' && !_canFlagExpenses) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to flag expenses'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          } else if (itemType == 'Collections' && !_canFlagCollection) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('You do not have permission to flag collections'),
                backgroundColor: AppTheme.errorColor,
              ),
            );
            return;
          }
        }
      }

      final String resolvedReason =
          (reason != null && reason.trim().isNotEmpty) ? reason.trim() : 'Flagged from dashboard';

      Map<String, dynamic> result;
      String successMessage = 'Item flagged for review';
      String errorMessage = 'Failed to flag item';

      if (itemType == 'Transactions') {
        result = await TransactionService.flagTransaction(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Transaction flagged successfully';
        errorMessage = 'Failed to flag transaction';
      } else if (itemType == 'Expenses') {
        result = await ExpenseService.flagExpense(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Expense flagged successfully';
        errorMessage = 'Failed to flag expense';
      } else if (itemType == 'Collections') {
        result = await CollectionService.flagCollection(itemId, resolvedReason, fromAllWalletReport: isAllWalletReport);
        successMessage = 'Collection flagged successfully';
        errorMessage = 'Failed to flag collection';
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Unknown item type')),
        );
        return;
      }

      if (mounted) {
        if (result['success'] == true) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? successMessage),
              backgroundColor: AppTheme.warningColor,
            ),
          );
          _loadDashboardData();
          _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(result['message'] ?? errorMessage),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _handleEdit(Map<String, dynamic> item) async {
    final itemType = item['type'] as String? ?? '';
    final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    
    if (itemId.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Item ID not found')),
      );
      return;
    }

    // Check permissions for Self Wallet
    if (isSelfWallet) {
      if (itemType == 'Transactions' && !_canEditTransaction) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('You do not have permission to edit transactions'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      } else if (itemType == 'Expenses' && !_canEditExpenses) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('You do not have permission to edit expenses'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      } else if (itemType == 'Collections' && !_canEditCollection) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('You do not have permission to edit collections'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }
    }

    if (itemType == 'Collections') {
      _showEditCollectionDialog(item);
    } else if (itemType == 'Expenses') {
      _showEditExpenseDialog(item);
    } else if (itemType == 'Transactions') {
      // Use the edit transaction dialog
      await _showNewAddTransactionDialog(
        existingTransactionData: item,
        isEditMode: true,
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Edit functionality not available for this item type')),
      );
    }
  }

  Future<void> _showEditCollectionDialog(Map<String, dynamic> item) async {
    final isMobile = MediaQuery.of(context).size.width < 600;
    final screenHeight = MediaQuery.of(context).size.height;
    
    // Extract existing data
    final customerName = item['customerName']?.toString() ?? '';
    final amount = (item['amount'] as num?)?.toDouble() ?? 0.0;
    final mode = item['mode']?.toString() ?? 'Cash';
    final notes = item['notes']?.toString() ?? '';
    final proofUrl = item['proofUrl']?.toString();
    final paymentModeId = item['paymentModeId']?.toString();
    
    // Extract receipt number from notes if it exists
    String receiptNo = '';
    if (notes.isNotEmpty && notes.contains('Receipt No:')) {
      final receiptMatch = RegExp(r'Receipt No:\s*([^\n]+)').firstMatch(notes);
      if (receiptMatch != null) {
        receiptNo = receiptMatch.group(1)?.trim() ?? '';
      }
    }
    
    // Controllers
    final formKey = GlobalKey<FormState>();
    final customerNameController = TextEditingController(text: customerName);
    final receiptNoController = TextEditingController(text: receiptNo);
    final amountController = TextEditingController(text: amount > 0 ? amount.toString() : '');
    final notesController = TextEditingController(text: notes.replaceAll(RegExp(r'Receipt No:\s*[^\n]+\n?'), '').trim());
    
    // State variables
    String? selectedAccountId = paymentModeId;
    String? selectedMode = mode;
    File? proofImage;
    String? existingProofUrl = proofUrl;
    bool isLoading = false;
    bool isLoadingAccounts = true;
    List<Map<String, dynamic>> accounts = [];
    String? userName;
    
    // Load user info
    try {
      userName = await AuthService.getUserName() ?? 'Unknown User';
    } catch (e) {
      userName = 'Unknown User';
    }
    
    // Helper functions
    String _extractModeFromName(String name) {
      final lowerName = name.toLowerCase();
      if (lowerName.contains('cash')) return 'Cash';
      if (lowerName.contains('upi')) return 'UPI';
      if (lowerName.contains('bank')) return 'Bank';
      return 'Cash';
    }
    
    // Load accounts
    try {
      final result = await PaymentModeService.getPaymentModes();
      if (result['success'] == true) {
        final paymentModes = result['paymentModes'] as List<dynamic>? ?? [];
        accounts = paymentModes.map((pm) {
          final assignedReceiver = pm['assignedReceiver'];
          final receiverName = assignedReceiver is Map
              ? (assignedReceiver['name'] ?? 'Unknown')
              : 'Unknown';

          return {
            'id': pm['_id'] ?? pm['id'],
            'name': pm['modeName'] ?? '',
            'description': pm['description'] ?? '',
            'mode': _extractModeFromName(pm['modeName'] ?? ''),
            'autoPay': pm['autoPay'] ?? false,
            'isActive': pm['isActive'] ?? true,
            'assignedReceiver': receiverName,
          };
        }).where((acc) => acc['isActive'] == true).toList();
        
        // If paymentModeId exists, try to find and select it
        if (paymentModeId != null && accounts.isNotEmpty) {
          final foundAccount = accounts.firstWhere(
            (acc) => acc['id'] == paymentModeId,
            orElse: () => <String, dynamic>{},
          );
          if (foundAccount.isNotEmpty) {
            selectedAccountId = paymentModeId;
            selectedMode = foundAccount['mode'];
          }
        }
      }
    } catch (e) {
      debugPrint('Error loading accounts: $e');
    }
    
    isLoadingAccounts = false;
    
    IconData _getModeIcon(String mode) {
      switch (mode) {
        case 'Cash':
          return Icons.money;
        case 'UPI':
          return Icons.qr_code;
        case 'Bank':
          return Icons.account_balance;
        default:
          return Icons.payment;
      }
    }
    
    if (!mounted) return;
    
    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            Future<void> _pickProofImage() async {
              try {
                final ImagePicker imagePicker = ImagePicker();
                final XFile? image = await imagePicker.pickImage(
                  source: ImageSource.gallery,
                  imageQuality: 80,
                );

                if (image != null) {
                  setDialogState(() {
                    proofImage = File(image.path);
                    existingProofUrl = null; // Clear existing URL when new image is selected
                  });
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error picking image: ${e.toString()}'),
                      backgroundColor: AppTheme.errorColor,
                    ),
                  );
                }
              }
            }
            
            return Dialog(
              backgroundColor: Colors.transparent,
              insetPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: Container(
                width: isMobile ? double.infinity : 500,
                constraints: BoxConstraints(
                  maxHeight: screenHeight * 0.85,
                  minHeight: 400,
                ),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Form(
                  key: formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header
                      Container(
                        padding: const EdgeInsets.all(20),
                        decoration: BoxDecoration(
                          color: AppTheme.secondaryColor,
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                        ),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.account_balance_wallet,
                              color: Colors.white,
                              size: 28,
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                'Edit Collection',
                                style: AppTheme.headingMedium.copyWith(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            if (userName != null)
                              Row(
                                children: [
                                  const Icon(
                                    Icons.person,
                                    color: Colors.white,
                                    size: 18,
                                  ),
                                  const SizedBox(width: 6),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 12,
                                      vertical: 6,
                                    ),
                                    decoration: BoxDecoration(
                                      color: Colors.white.withOpacity(0.2),
                                      borderRadius: BorderRadius.circular(8),
                                    ),
                                    child: Text(
                                      userName!,
                                      style: const TextStyle(
                                        color: Colors.white,
                                        fontWeight: FontWeight.w600,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(width: 12),
                                ],
                              ),
                            IconButton(
                              onPressed: () => Navigator.of(context).pop(),
                              icon: const Icon(
                                Icons.close_rounded,
                                color: Colors.white,
                                size: 24,
                              ),
                              tooltip: 'Close',
                              padding: EdgeInsets.zero,
                              constraints: const BoxConstraints(),
                            ),
                          ],
                        ),
                      ),

                      // Form Content
                      ConstrainedBox(
                        constraints: BoxConstraints(
                          maxHeight: screenHeight * 0.6,
                        ),
                        child: SingleChildScrollView(
                          padding: const EdgeInsets.all(24),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.stretch,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // Customer Name
                              TextFormField(
                                controller: customerNameController,
                                decoration: InputDecoration(
                                  labelText: 'Customer Name',
                                  prefixIcon: const Icon(Icons.person_outline),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                ),
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'Please enter customer name';
                                  }
                                  return null;
                                },
                              ),
                              const SizedBox(height: 20),

                              // Receipt No
                              TextFormField(
                                controller: receiptNoController,
                                decoration: InputDecoration(
                                  labelText: 'Receipt No',
                                  prefixIcon: const Icon(Icons.receipt_long),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                ),
                              ),
                              const SizedBox(height: 20),

                              // Amount
                              TextFormField(
                                controller: amountController,
                                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                inputFormatters: [
                                  FilteringTextInputFormatter.allow(
                                    RegExp(r'^\d+\.?\d{0,2}'),
                                  ),
                                ],
                                decoration: InputDecoration(
                                  labelText: 'Amount',
                                  prefixIcon: const Icon(Icons.currency_rupee),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                ),
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'Please enter amount';
                                  }
                                  final amount = double.tryParse(value);
                                  if (amount == null || amount <= 0) {
                                    return 'Please enter a valid amount';
                                  }
                                  return null;
                                },
                              ),
                              const SizedBox(height: 20),

                              // Account Selection
                              if (isLoadingAccounts)
                                const Center(
                                  child: Padding(
                                    padding: EdgeInsets.all(20.0),
                                    child: CircularProgressIndicator(),
                                  ),
                                )
                              else if (accounts.isEmpty)
                                DropdownButtonFormField<String>(
                                  value: selectedMode,
                                  decoration: InputDecoration(
                                    labelText: 'Payment Mode',
                                    prefixIcon: Icon(selectedMode != null
                                        ? _getModeIcon(selectedMode!)
                                        : Icons.payment),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    helperText: 'No accounts available. Select payment mode.',
                                    helperStyle: TextStyle(
                                      color: AppTheme.textSecondary,
                                      fontSize: 12,
                                    ),
                                  ),
                                  items: [
                                    DropdownMenuItem<String>(
                                      value: 'Cash',
                                      child: Row(
                                        children: [
                                          Icon(Icons.money, size: 20, color: AppTheme.primaryColor),
                                          const SizedBox(width: 12),
                                          const Text('Cash'),
                                        ],
                                      ),
                                    ),
                                    DropdownMenuItem<String>(
                                      value: 'UPI',
                                      child: Row(
                                        children: [
                                          Icon(Icons.qr_code, size: 20, color: AppTheme.primaryColor),
                                          const SizedBox(width: 12),
                                          const Text('UPI'),
                                        ],
                                      ),
                                    ),
                                    DropdownMenuItem<String>(
                                      value: 'Bank',
                                      child: Row(
                                        children: [
                                          Icon(Icons.account_balance, size: 20, color: AppTheme.primaryColor),
                                          const SizedBox(width: 12),
                                          const Text('Bank'),
                                        ],
                                      ),
                                    ),
                                  ],
                                  onChanged: (String? newValue) {
                                    setDialogState(() {
                                      selectedMode = newValue;
                                      selectedAccountId = null;
                                    });
                                  },
                                  validator: (value) {
                                    if (value == null) {
                                      return 'Please select a payment mode';
                                    }
                                    return null;
                                  },
                                )
                              else
                                Builder(
                                  builder: (context) {
                                    final currentValue = () {
                                    if (selectedAccountId == null) return null;
                                    return accounts.any((account) => account['id'] == selectedAccountId)
                                        ? selectedAccountId
                                        : null;
                                    }();
                                    
                                    // Get selected account display text
                                    String displayText = 'Select Account';
                                    if (currentValue != null) {
                                      final selectedAccount = accounts.firstWhere(
                                        (acc) => acc['id'] == currentValue,
                                        orElse: () => <String, dynamic>{},
                                      );
                                      if (selectedAccount.isNotEmpty) {
                                        final autoPayStatus = selectedAccount['autoPay'] == true ? 'ON' : 'OFF';
                                        displayText = '${selectedAccount['name'] ?? 'Unknown'} (Auto Pay: $autoPayStatus)';
                                      }
                                    }
                                    
                                    // Calculate button height for proper menu offset
                                    final double buttonHeight = 56.0;
                                    final Offset menuOffset = Offset(0, buttonHeight + 4);
                                    
                                    return Material(
                                      elevation: 8,
                                      color: Colors.transparent,
                                      shadowColor: Colors.transparent,
                                      child: PopupMenuButton<String?>(
                                        offset: menuOffset, // Position menu at bottom of button
                                        elevation: 8,
                                        shadowColor: Colors.black.withOpacity(0.08),
                                        surfaceTintColor: Colors.transparent,
                                        color: Colors.white,
                                        constraints: const BoxConstraints(
                                          minWidth: 300,
                                          maxWidth: 400,
                                          maxHeight: 300,
                                        ),
                                        shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                        onSelected: (String? newValue) {
                                          if (newValue != null) {
                                            setDialogState(() {
                                              selectedAccountId = newValue;
                                              final selectedAccount = accounts.firstWhere(
                                                (acc) => acc['id'] == newValue,
                                              );
                                              selectedMode = selectedAccount['mode'];
                                            });
                                          } else {
                                            setDialogState(() {
                                              selectedAccountId = null;
                                            });
                                          }
                                        },
                                        itemBuilder: (context) {
                                          return [
                                    // Add "None" option
                                            PopupMenuItem<String?>(
                                      value: null,
                                              padding: const EdgeInsets.symmetric(
                                                horizontal: 12,
                                                vertical: 8,
                                              ),
                                      child: Row(
                                        children: [
                                          Icon(Icons.payment, size: 20, color: AppTheme.primaryColor),
                                          const SizedBox(width: 12),
                                                  const Expanded(
                                                    child: Text('Select Payment Mode Only'),
                                                  ),
                                        ],
                                      ),
                                    ),
                                    ...accounts.map((account) {
                                      final autoPayStatus = account['autoPay'] == true ? 'ON' : 'OFF';
                                              final isSelected = account['id'] == currentValue;
                                              return PopupMenuItem<String?>(
                                        value: account['id'],
                                                padding: const EdgeInsets.symmetric(
                                                  horizontal: 12,
                                                  vertical: 8,
                                                ),
                                        child: Row(
                                          children: [
                                                    if (isSelected)
                                                      Icon(
                                                        Icons.check,
                                                        size: 18,
                                                        color: AppTheme.primaryColor,
                                                      )
                                                    else
                                                      const SizedBox(width: 18),
                                                    if (isSelected) const SizedBox(width: 8),
                                            Icon(
                                              _getModeIcon(account['mode']),
                                              size: 20,
                                              color: AppTheme.primaryColor,
                                            ),
                                            const SizedBox(width: 12),
                                                    Expanded(
                                              child: Text(
                                                '${account['name'] ?? 'Unknown'} (Auto Pay: $autoPayStatus)',
                                                overflow: TextOverflow.ellipsis,
                                                        style: TextStyle(
                                                          color: isSelected ? AppTheme.primaryColor : AppTheme.textPrimary,
                                                          fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                                                        ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      );
                                    }).toList(),
                                          ];
                                        },
                                        // Child: Button that looks exactly like DropdownButtonFormField
                                        child: InputDecorator(
                                          decoration: InputDecoration(
                                            labelText: 'Account',
                                            prefixIcon: const Icon(Icons.account_balance),
                                            border: OutlineInputBorder(
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            suffixIcon: const Icon(Icons.arrow_drop_down),
                                          ),
                                          isFocused: false,
                                          isEmpty: false,
                                          child: Text(
                                            displayText,
                                            overflow: TextOverflow.ellipsis,
                                          ),
                                        ),
                                      ),
                                    );
                                  },
                                ),
                              const SizedBox(height: 20),

                              // Proof Image
                              Text(
                                'Proof:',
                                style: AppTheme.labelMedium.copyWith(
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                              const SizedBox(height: 8),
                              InkWell(
                                onTap: _pickProofImage,
                                child: Container(
                                  height: 120,
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color: AppTheme.borderColor,
                                      width: 2,
                                      style: BorderStyle.solid,
                                    ),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: proofImage != null
                                      ? Stack(
                                          children: [
                                            ClipRRect(
                                              borderRadius: BorderRadius.circular(10),
                                              child: Image.file(
                                                proofImage!,
                                                width: double.infinity,
                                                height: double.infinity,
                                                fit: BoxFit.cover,
                                              ),
                                            ),
                                            Positioned(
                                              top: 8,
                                              right: 8,
                                              child: IconButton(
                                                icon: const Icon(Icons.close),
                                                color: Colors.white,
                                                style: IconButton.styleFrom(
                                                  backgroundColor: Colors.black54,
                                                ),
                                                onPressed: () {
                                                  setDialogState(() {
                                                    proofImage = null;
                                                  });
                                                },
                                              ),
                                            ),
                                          ],
                                        )
                                      : existingProofUrl != null && existingProofUrl!.isNotEmpty
                                          ? Stack(
                                              children: [
                                                ClipRRect(
                                                  borderRadius: BorderRadius.circular(10),
                                                  child: Image.network(
                                                    existingProofUrl!,
                                                    width: double.infinity,
                                                    height: double.infinity,
                                                    fit: BoxFit.cover,
                                                    errorBuilder: (context, error, stackTrace) {
                                                      return Center(
                                                        child: Column(
                                                          mainAxisAlignment: MainAxisAlignment.center,
                                                          children: [
                                                            Icon(
                                                              Icons.broken_image,
                                                              size: 40,
                                                              color: AppTheme.textSecondary,
                                                            ),
                                                            const SizedBox(height: 8),
                                                            Text(
                                                              'Failed to load image',
                                                              style: TextStyle(
                                                                color: AppTheme.textSecondary,
                                                              ),
                                                            ),
                                                          ],
                                                        ),
                                                      );
                                                    },
                                                  ),
                                                ),
                                                Positioned(
                                                  top: 8,
                                                  right: 8,
                                                  child: IconButton(
                                                    icon: const Icon(Icons.close),
                                                    color: Colors.white,
                                                    style: IconButton.styleFrom(
                                                      backgroundColor: Colors.black54,
                                                    ),
                                                    onPressed: () {
                                                      setDialogState(() {
                                                        existingProofUrl = null;
                                                      });
                                                    },
                                                  ),
                                                ),
                                              ],
                                            )
                                          : Center(
                                              child: Column(
                                                mainAxisAlignment: MainAxisAlignment.center,
                                                children: [
                                                  Icon(
                                                    Icons.add_photo_alternate_outlined,
                                                    size: 40,
                                                    color: AppTheme.textSecondary,
                                                  ),
                                                  const SizedBox(height: 8),
                                                  Text(
                                                    'Tap to add proof image',
                                                    style: TextStyle(
                                                      color: AppTheme.textSecondary,
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),

                      // Action Buttons
                      Container(
                        padding: const EdgeInsets.all(20),
                        decoration: BoxDecoration(
                          border: Border(
                            top: BorderSide(color: AppTheme.borderColor),
                          ),
                        ),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            TextButton(
                              onPressed: isLoading
                                  ? null
                                  : () => Navigator.of(context).pop(),
                              child: Text(
                                'Cancel',
                                style: TextStyle(color: AppTheme.primaryColor),
                              ),
                            ),
                            const SizedBox(width: 12),
                            ElevatedButton(
                              onPressed: isLoading ? null : () async {
                                if (!formKey.currentState!.validate()) {
                                  return;
                                }

                                // Validate: Either account or mode must be selected
                                if (selectedAccountId == null && selectedMode == null) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content: Text('Please select an account or payment mode'),
                                      backgroundColor: AppTheme.errorColor,
                                    ),
                                  );
                                  return;
                                }

                                setDialogState(() {
                                  isLoading = true;
                                });

                                try {
                                  // TODO: Upload proof image if available
                                  String? finalProofUrl = existingProofUrl;
                                  if (proofImage != null) {
                                    // Implement image upload logic here
                                    // finalProofUrl = await uploadImage(proofImage!);
                                  } else if (existingProofUrl == null) {
                                    finalProofUrl = null;
                                  }

                                  // Determine mode: use selected mode if no account, otherwise use account's mode
                                  String finalMode;
                                  if (selectedAccountId != null) {
                                    final selectedAccount = accounts.firstWhere(
                                      (acc) => acc['id'] == selectedAccountId,
                                    );
                                    finalMode = selectedAccount['mode'] ?? selectedMode ?? 'Cash';
                                  } else {
                                    finalMode = selectedMode ?? 'Cash';
                                  }

                                  // Prepare notes: combine receipt no and notes
                                  String? finalNotes;
                                  final receiptNoText = receiptNoController.text.trim();
                                  final notesText = notesController.text.trim();
                                  
                                  if (receiptNoText.isNotEmpty || notesText.isNotEmpty) {
                                    finalNotes = '';
                                    if (receiptNoText.isNotEmpty) {
                                      finalNotes = 'Receipt No: $receiptNoText';
                                    }
                                    if (notesText.isNotEmpty) {
                                      if (finalNotes.isNotEmpty) {
                                        finalNotes += '\n$notesText';
                                      } else {
                                        finalNotes = notesText;
                                      }
                                    }
                                  }

                                  final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
                                  // Check if from All Wallet Report
                                  final bool fromAllWalletReport = _selectedItem == NavItem.accountReports;
                                  
                                  final result = await CollectionService.editCollection(
                                    itemId,
                                    customerName: customerNameController.text.trim(),
                                    amount: double.parse(amountController.text),
                                    mode: finalMode,
                                    paymentModeId: selectedAccountId,
                                    proofUrl: finalProofUrl,
                                    notes: finalNotes,
                                    fromAllWalletReport: fromAllWalletReport,
                                  );

                                  if (mounted) {
                                    setDialogState(() {
                                      isLoading = false;
                                    });

                                    if (result['success'] == true) {
                                      // If editing from flagged item, also resubmit to change status to Pending
                                      if (item['fromFlaggedItem'] == true) {
                                        final flaggedItemId = item['flaggedItemId']?.toString() ?? '';
                                        final flaggedItemCategory = item['flaggedItemCategory']?.toString() ?? '';
                                        if (flaggedItemId.isNotEmpty) {
                                          // Resubmit to change status to Pending
                                          final resubmitResult = await CollectionService.resubmitCollection(
                                            flaggedItemId,
                                            'Updated and resubmitted for approval',
                                          );
                                          if (resubmitResult['success'] == true) {
                                            // Track this item as resubmitted (safeguard)
                                            _resubmittedItemIds.add(flaggedItemId);
                                            
                                            // Remove from local flagged items immediately (it's now Pending, not Flagged)
                                            _removeFlaggedItem(flaggedItemId, category: flaggedItemCategory);
                                            
                                            // Wait longer for backend to process and save the status change
                                            await Future.delayed(Duration(milliseconds: 1000));
                                            
                                            // Reload flagged items to ensure sync
                                            await _loadTimelineEntries();
                                            
                                            // Clear the resubmitted tracking after a delay (cleanup)
                                            Future.delayed(Duration(seconds: 5), () {
                                              _resubmittedItemIds.remove(flaggedItemId);
                                            });
                                            
                                            // Stay on the same page (don't navigate to Smart Approvals)
                                            print('üö© [FLAGGED ITEMS] Staying on current page for collection (not navigating to Smart Approvals)');
                                            
                                            // Refresh dashboard data to update approvals list
                                            _loadDashboardData();
                                            _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
                                          }
                                        }
                                      }
                                      
                                      Navigator.pop(context);
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: Text(result['message'] ?? 'Collection updated successfully'),
                                          backgroundColor: AppTheme.secondaryColor,
                                        ),
                                      );
                                      _loadDashboardData();
                                      _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
                                    } else {
                                      ScaffoldMessenger.of(context).showSnackBar(
                                        SnackBar(
                                          content: Text(result['message'] ?? 'Failed to update collection'),
                                          backgroundColor: AppTheme.errorColor,
                                        ),
                                      );
                                    }
                                  }
                                } catch (e) {
                                  if (mounted) {
                                    setDialogState(() {
                                      isLoading = false;
                                    });

                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(
                                        content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                        backgroundColor: AppTheme.errorColor,
                                      ),
                                    );
                                  }
                                }
                              },
                              style: ElevatedButton.styleFrom(
                                backgroundColor: AppTheme.secondaryColor,
                                foregroundColor: Colors.white,
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 32,
                                  vertical: 14,
                                ),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                              ),
                              child: isLoading
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor:
                                            AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    )
                                  : const Text(
                                      'Save',
                                      style: TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _showEditExpenseDialog(Map<String, dynamic> item) async {
    // For All Wallet Report, use the expense dialog instead of showing error
    final bool isAllWalletReport = _selectedItem == NavItem.accountReports || _selectedItem == NavItem.walletOverview;
    
    if (isAllWalletReport) {
      // Extract expense data and open expense dialog in edit mode
      final expenseId = item['id']?.toString() ?? item['_id']?.toString() ?? item['expenseId']?.toString() ?? '';
      if (expenseId.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Expense ID not found'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
        return;
      }
      
      // Extract expense data
      final amount = (item['amount'] as num?)?.toDouble() ?? 0.0;
      final paymentMode = item['mode']?.toString() ?? 'Cash';
      final expenseType = item['category']?.toString() ?? item['expenseType']?.toString() ?? '';
      final description = item['description']?.toString() ?? '';
      final proofUrl = item['proofUrl']?.toString();
      final accountId = item['accountId']?.toString();
      
      // Prepare expense data for edit mode
      final existingExpenseData = {
        'expenseId': expenseId,
        'id': expenseId,
        'amount': amount,
        'mode': paymentMode,
        'category': expenseType,
        'description': description,
        'proofUrl': proofUrl,
        'accountId': accountId,
      };
      
      // Open expense form in edit mode
      await _showNewAddExpensesDialog(
        existingExpenseData: existingExpenseData,
        isEditMode: true,
      );
    } else {
      // For other views, show message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Expense editing is not available. Please reject and create a new expense.'),
        ),
      );
    }
  }

  Future<void> _handleDelete(Map<String, dynamic> item) async {
    final itemId = item['id']?.toString() ?? item['_id']?.toString() ?? '';
    final itemType = item['type'] as String? ?? '';
    final bool isSelfWallet = _selectedItem == NavItem.walletSelf;
    
    if (itemId.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Item ID not found')),
      );
      return;
    }

    // Check permissions for Self Wallet (Super Admin bypass)
    if (isSelfWallet) {
      final bool isSuperAdmin = await UIPermissionChecker.isSuperAdmin();
      if (!isSuperAdmin) {
        if (itemType == 'Transactions' && !_canDeleteTransaction) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You do not have permission to delete transactions'),
              backgroundColor: AppTheme.errorColor,
            ),
          );
          return;
        } else if (itemType == 'Expenses' && !_canDeleteExpenses) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You do not have permission to delete expenses'),
              backgroundColor: AppTheme.errorColor,
            ),
          );
          return;
        } else if (itemType == 'Collections' && !_canDeleteCollection) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You do not have permission to delete collections'),
              backgroundColor: AppTheme.errorColor,
            ),
          );
          return;
        }
      }
    }

    String title = 'Delete Item';
    String content = 'Are you sure you want to delete this item? This action cannot be undone.';
    
    if (itemType == 'Transactions') {
      title = 'Delete Transaction';
      content = 'Are you sure you want to delete this transaction? This action cannot be undone.';
    } else if (itemType == 'Expenses') {
      title = 'Delete Expense';
      content = 'Are you sure you want to delete this expense? This action cannot be undone.';
    } else if (itemType == 'Collections') {
      title = 'Delete Collection';
      content = 'Are you sure you want to delete this collection? This action cannot be undone.';
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: Colors.white,
        title: Text(title),
        content: Text(content),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              Navigator.pop(context);
              try {
                Map<String, dynamic> result;
                String successMessage = 'Item cancelled successfully';
                String errorMessage = 'Failed to cancel item';

                // Check if from All Wallet Report
                final bool fromAllWalletReport = _selectedItem == NavItem.accountReports;
                
                if (itemType == 'Transactions') {
                  result = await TransactionService.deleteTransaction(itemId, fromAllWalletReport: fromAllWalletReport);
                  successMessage = 'Transaction deleted successfully';
                  errorMessage = 'Failed to delete transaction';
                } else if (itemType == 'Expenses') {
                  result = await ExpenseService.deleteExpense(itemId, fromAllWalletReport: fromAllWalletReport);
                  successMessage = 'Expense deleted successfully';
                  errorMessage = 'Failed to delete expense';
                } else if (itemType == 'Collections') {
                  result = await CollectionService.deleteCollection(itemId, fromAllWalletReport: fromAllWalletReport);
                  successMessage = 'Collection deleted successfully';
                  errorMessage = 'Failed to delete collection';
                } else {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Unknown item type')),
                    );
                  }
                  return;
                }

                if (mounted) {
                  if (result['success'] == true) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(result['message'] ?? successMessage),
                        backgroundColor: Colors.green,
                      ),
                    );
                    // Refresh both dashboard and financial data
                    _loadDashboardData();
                    _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
                  } else {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(result['message'] ?? errorMessage),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  }
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              }
            },
            child: const Text('Delete', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  String _normalizeStatusKey(String status) {
    final trimmed = status.trim();
    if (trimmed.isEmpty || trimmed == '-') {
      return '';
    }

    final lower = trimmed.toLowerCase();
    if (_statusAliases.containsKey(lower)) {
      return _statusAliases[lower]!;
    }

    final sanitized = lower.replaceAll(RegExp(r'[^a-z]'), '');
    if (_statusAliases.containsKey(sanitized)) {
      return _statusAliases[sanitized]!;
    }

    return lower;
  }

  String _formatStatusLabel(String value) {
    final trimmed = value.trim();
    if (trimmed.isEmpty || trimmed == '-') {
      return '';
    }

    final lower = trimmed.toLowerCase();
    if (lower == 'accounted') {
      return 'Accounted';
    }
    if (lower == 'unaccounted') {
      return 'Unaccounted';
    }

    final parts = lower.split(RegExp(r'[\s_\-]+')).where((segment) => segment.isNotEmpty);
    return parts
        .map((segment) => segment[0].toUpperCase() + segment.substring(1))
        .join(' ');
  }

  _RowActionConfig _resolveRowActions(String status, String itemType) {
    final key = _normalizeStatusKey(status);
    final canEditType = itemType.isNotEmpty;

    if (key == 'approved' || key == 'completed') {
      return _RowActionConfig(
        canApprove: false,
        canUnapprove: true,
        canReject: true,
        canEdit: canEditType,
        canFlag: true,
        canDelete: true,
      );
    }

    if (key == 'accounted') {
      return _RowActionConfig(
        canApprove: true,
        canUnapprove: false,
        canReject: true,
        canEdit: canEditType,
        canFlag: true,
        canDelete: true,
      );
    }

    if (key == 'unaccounted') {
      return _RowActionConfig(
        canApprove: true,
        canUnapprove: false,
        canReject: true,
        canEdit: canEditType,
        canFlag: true,
        canDelete: true,
      );
    }

    if (key == 'flagged') {
      return _RowActionConfig(
        canApprove: true,
        canUnapprove: false,
        canReject: true,
        canEdit: canEditType,
        canFlag: true,
        canDelete: true,
      );
    }

    // Treat pending, viewed, processing, or unknown statuses as unapproved
    return _RowActionConfig(
      canApprove: true,
      canUnapprove: false,
      canReject: true,
      canEdit: canEditType,
      canFlag: true,
      canDelete: true,
    );
  }

  Widget _buildStatusChip(String status) {
    final resolvedKey = _normalizeStatusKey(status);

    if (resolvedKey.isEmpty || !_statusBadgeStyles.containsKey(resolvedKey)) {
      return const SizedBox.shrink();
    }

    final badgeStyle = _statusBadgeStyles[resolvedKey];
    final label = badgeStyle?.label ?? _formatStatusLabel(status);

    if (label.isEmpty) {
      return const SizedBox.shrink();
    }

    final color = badgeStyle?.color ?? AppTheme.textSecondary;
    final icon = badgeStyle?.icon ?? Icons.info_outline;
    final backgroundOpacity = badgeStyle?.backgroundOpacity ?? 0.15;
    final letterSpacing = badgeStyle?.labelLetterSpacing ?? 0.5;

    return Container(
      constraints: const BoxConstraints(minWidth: 64),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(backgroundOpacity),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: color.withOpacity(0.4)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 16, color: color),
          const SizedBox(width: 6),
          Flexible(
            child: Text(
            label,
            style: TextStyle(
              color: color,
              fontWeight: FontWeight.w700,
              fontSize: 12,
              letterSpacing: letterSpacing,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
        ],
      ),
    );
  }

  void _showQuickActionsMenu(BuildContext context, bool isMobile, bool isTablet) {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => FutureBuilder<String?>(
        future: AuthService.getUserRole(),
        builder: (context, snapshot) {
          final userRole = snapshot.data;
          final isSuperAdmin = userRole == 'SuperAdmin' || userRole == 'Super Admin';
          
          return Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
          Text(
                  'Quick Actions',
            style: AppTheme.headingMedium.copyWith(
                    fontSize: isMobile ? 18 : 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: const Icon(Icons.close),
                ),
              ],
            ),
            const SizedBox(height: 20),
            // Mobile: Use scrollable list layout
            // Desktop/Tablet: Use wrap grid layout
            if (isMobile)
              Flexible(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      _buildQuickActionListItem(
                        context,
                        'Add Expenses',
                        Icons.receipt,
                        Colors.orange,
                        () {
                          Navigator.pop(context);
                          _showNewAddExpensesDialog();
                        },
                      ),
                      const SizedBox(height: 12),
                      _buildQuickActionListItem(
                        context,
                        'Add Transaction',
                        Icons.swap_horiz,
                        Colors.purple,
                        () {
                          Navigator.pop(context);
                          _showNewAddTransactionDialog();
                        },
                      ),
                      const SizedBox(height: 12),
                      _buildQuickActionListItem(
                        context,
                        'Add Collection',
                        Icons.payment,
                        Colors.green,
                        () {
                          Navigator.pop(context);
                          _showNewAddCollectionDialog();
                        },
                      ),
                      // Only show Add Amount and Withdraw if user has permissions
                      if (_canAddAmount) ...[
                        const SizedBox(height: 12),
                        _buildQuickActionListItem(
                          context,
                          'Add Amount',
                          Icons.add_circle,
                          AppTheme.primaryColor,
                          () {
                            Navigator.pop(context);
                            _showNewAddAmountDialog();
                          },
                        ),
                      ],
                      if (_canWithdraw) ...[
                        const SizedBox(height: 12),
                        _buildQuickActionListItem(
                          context,
                          'Withdraw',
                          Icons.remove_circle,
                          Colors.red,
                          () {
                            Navigator.pop(context);
                            _showNewWithdrawDialog();
                          },
                        ),
                      ],
                    ],
                  ),
                ),
              )
            else
              Wrap(
                spacing: 12,
                runSpacing: 12,
                children: [
                  _buildQuickActionItem(
                    context,
                    'Add Expenses',
                    Icons.receipt,
                    Colors.orange,
                    () {
                      Navigator.pop(context);
                      _showNewAddExpensesDialog();
                    },
                  ),
                  _buildQuickActionItem(
                    context,
                    'Add Transaction',
                    Icons.swap_horiz,
                    Colors.purple,
                    () {
                      Navigator.pop(context);
                      _showNewAddTransactionDialog();
                    },
                  ),
                  _buildQuickActionItem(
                    context,
                    'Add Collection',
                    Icons.payment,
                    Colors.green,
                    () {
                      Navigator.pop(context);
                      _showNewAddCollectionDialog();
                    },
                  ),
                  // Only show Add Amount and Withdraw if user has permissions
                  if (_canAddAmount)
                    _buildQuickActionItem(
                      context,
                      'Add Amount',
                      Icons.add_circle,
                      AppTheme.primaryColor,
                      () {
                        Navigator.pop(context);
                        _showNewAddAmountDialog();
                      },
                    ),
                  if (_canWithdraw)
                    _buildQuickActionItem(
                      context,
                      'Withdraw',
                      Icons.remove_circle,
                      Colors.red,
                      () {
                        Navigator.pop(context);
                        _showNewWithdrawDialog();
                      },
                    ),
                ],
              ),
            const SizedBox(height: 20),
          ],
        ),
          );
        },
      ),
    );
  }

  void _openAddExpenses() {
    _showOldAddExpensesDialog();
  }

  // Old simple version - single step dialog without expense type selection
  Future<void> _showOldAddExpensesDialog({Map<String, dynamic>? existingExpenseData, bool isEditMode = false}) async {
    try {
      // Load accounts in background if needed
      if (_allAccountsList.isEmpty && !_isLoadingAccounts) {
        _loadAccountsList();
      }
      
      bool dialogIsSubmitting = false;
      final String? preservedAccountId = _selectedExpenseAccountId;
      
      if (isEditMode && existingExpenseData != null) {
        final amount = existingExpenseData['amount'] ?? 0.0;
        final mode = existingExpenseData['mode']?.toString() ?? 'Cash';
        final category = existingExpenseData['category']?.toString() ?? '';
        final description = existingExpenseData['description']?.toString() ?? '';
        final accountId = existingExpenseData['accountId']?.toString();
        
        _expenseAmountController.text = amount.toString();
        _expenseDescriptionController.text = description;
        
        setState(() {
          _selectedExpenseCategory = category.isNotEmpty ? category : 'Office';
          _selectedExpenseMode = mode;
          _selectedExpensePaymentAccountId = accountId;
          _selectedExpenseProofImage = null;
        });
      } else {
        _expenseAmountController.clear();
        _expenseDescriptionController.clear();
        
        setState(() {
          _selectedExpenseCategory = 'Office';
          _selectedExpenseMode = 'Cash';
          _selectedExpensePaymentAccountId = null;
          _selectedExpenseProofImage = null;
        });
      }
      _addExpenseFormKey.currentState?.reset();

      final isMobile = Responsive.isMobile(context);
      final isTablet = Responsive.isTablet(context);
      final ImagePicker imagePicker = ImagePicker();

      if (!mounted) return;
      
      await showDialog(
        context: context,
        barrierDismissible: true,
        builder: (dialogContext) {
          return StatefulBuilder(
            builder: (context, setDialogState) {
              final filteredPaymentAccounts = _selectedExpenseMode != 'Cash'
                  ? _allAccountsList.where((account) {
                      final accountType = account['type']?.toString() ?? '';
                      return accountType == _selectedExpenseMode;
                    }).toList()
                  : <Map<String, dynamic>>[];

              return Dialog(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
                backgroundColor: Colors.white,
                child: Container(
                  constraints: BoxConstraints(
                    maxWidth: isMobile ? double.infinity : (isTablet ? 600 : 700),
                    maxHeight: MediaQuery.of(context).size.height * (isMobile ? 0.95 : 0.85),
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                  ),
                  padding: EdgeInsets.zero,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Header
                      Container(
                        padding: EdgeInsets.all(isMobile ? 16 : 20),
                        decoration: BoxDecoration(
                          color: AppTheme.warningColor,
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(20),
                            topRight: Radius.circular(20),
                          ),
                        ),
                        child: Row(
                          children: [
                            const Icon(
                              Icons.receipt_long,
                              color: Colors.white,
                              size: 28,
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                isEditMode ? 'Edit Expense' : 'Add Expense',
                                style: AppTheme.headingMedium.copyWith(
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            if (_userName != null && !isMobile)
                              Row(
                                children: [
                                  const Icon(
                                    Icons.person,
                                    color: Colors.white,
                                    size: 18,
                                  ),
                                  const SizedBox(width: 6),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                      horizontal: 12,
                                      vertical: 6,
                                    ),
                                    decoration: BoxDecoration(
                                      color: Colors.white.withOpacity(0.2),
                                      borderRadius: BorderRadius.circular(8),
                                    ),
                                    child: Text(
                                      _userName!,
                                      style: const TextStyle(
                                        color: Colors.white,
                                        fontWeight: FontWeight.w600,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            const SizedBox(width: 12),
                            IconButton(
                              onPressed: () => Navigator.pop(dialogContext),
                              icon: const Icon(
                                Icons.close_rounded,
                                color: Colors.white,
                                size: 24,
                              ),
                              tooltip: 'Close',
                              padding: EdgeInsets.zero,
                              constraints: const BoxConstraints(),
                            ),
                          ],
                        ),
                      ),
                      // Form Content
                      Flexible(
                        child: SingleChildScrollView(
                          padding: EdgeInsets.all(isMobile ? 16 : 24),
                          child: Form(
                            key: _addExpenseFormKey,
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.stretch,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                // Category Dropdown
                                DropdownButtonFormField<String>(
                                  value: _selectedExpenseCategory,
                                  decoration: InputDecoration(
                                    labelText: 'Category',
                                    prefixIcon: const Icon(Icons.category),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                  items: _expenseCategories.map((category) {
                                    return DropdownMenuItem<String>(
                                      value: category,
                                      child: Text(category),
                                    );
                                  }).toList(),
                                  onChanged: (value) {
                                    setDialogState(() {
                                      _selectedExpenseCategory = value ?? 'Office';
                                    });
                                  },
                                  validator: (value) {
                                    if (value == null || value.isEmpty) {
                                      return 'Please select a category';
                                    }
                                    return null;
                                  },
                                ),
                                SizedBox(height: isMobile ? 16 : 20),
                                // Amount Input
                                TextFormField(
                                  controller: _expenseAmountController,
                                  keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                  inputFormatters: [
                                    FilteringTextInputFormatter.allow(RegExp(r'^\d+\.?\d{0,2}')),
                                  ],
                                  decoration: InputDecoration(
                                    labelText: 'Amount',
                                    prefixIcon: const Icon(Icons.currency_rupee),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                  validator: (value) {
                                    if (value == null || value.isEmpty) {
                                      return 'Please enter an amount';
                                    }
                                    final amount = double.tryParse(value);
                                    if (amount == null || amount <= 0) {
                                      return 'Please enter a valid amount';
                                    }
                                    return null;
                                  },
                                ),
                                SizedBox(height: isMobile ? 16 : 20),
                                // Payment Mode Selection
                                DropdownButtonFormField<String>(
                                  value: _selectedExpenseMode,
                                  decoration: InputDecoration(
                                    labelText: 'Payment Mode',
                                    prefixIcon: const Icon(Icons.payment),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                  items: _getActiveModeOptions().map((mode) {
                                    return DropdownMenuItem<String>(
                                      value: mode == 'All' ? null : mode,
                                      child: Text(mode),
                                    );
                                  }).toList(),
                                  onChanged: (value) {
                                    setDialogState(() {
                                      _selectedExpenseMode = value ?? 'Cash';
                                      if (value != 'Cash') {
                                        _selectedExpensePaymentAccountId = null;
                                      }
                                    });
                                  },
                                  validator: (value) {
                                    if (value == null || value.isEmpty) {
                                      return 'Please select a payment mode';
                                    }
                                    return null;
                                  },
                                ),
                                // Payment Account Selection (if not Cash)
                                if (_selectedExpenseMode != 'Cash') ...[
                                  SizedBox(height: isMobile ? 16 : 20),
                                  DropdownButtonFormField<String>(
                                    value: _selectedExpensePaymentAccountId,
                                    decoration: InputDecoration(
                                      labelText: 'Select ${_selectedExpenseMode} Account',
                                      prefixIcon: const Icon(Icons.account_balance),
                                      border: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      contentPadding: EdgeInsets.symmetric(
                                        horizontal: 16,
                                        vertical: isMobile ? 16 : 14,
                                      ),
                                    ),
                                    items: filteredPaymentAccounts.map((account) {
                                      final accountId = (account['_id'] ?? account['id'])?.toString() ?? '';
                                      final accountName = account['accountName']?.toString() ?? 'Unknown';
                                      return DropdownMenuItem<String>(
                                        value: accountId,
                                        child: Text(accountName),
                                      );
                                    }).toList(),
                                    onChanged: (value) {
                                      setDialogState(() {
                                        _selectedExpensePaymentAccountId = value;
                                      });
                                    },
                                    validator: (value) {
                                      if (_selectedExpenseMode != 'Cash' && (value == null || value.isEmpty)) {
                                        return 'Please select an account';
                                      }
                                      return null;
                                    },
                                  ),
                                ],
                                SizedBox(height: isMobile ? 16 : 20),
                                // Description Input
                                TextFormField(
                                  controller: _expenseDescriptionController,
                                  maxLines: 3,
                                  decoration: InputDecoration(
                                    labelText: 'Description',
                                    hintText: 'Enter description (optional)',
                                    prefixIcon: const Icon(Icons.description),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: isMobile ? 16 : 14,
                                    ),
                                  ),
                                ),
                                SizedBox(height: isMobile ? 16 : 20),
                                // Proof Image Upload
                                Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Proof Image (Optional)',
                                      style: AppTheme.labelMedium.copyWith(
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    if (_selectedExpenseProofImage != null)
                                      Container(
                                        margin: const EdgeInsets.only(bottom: 8),
                                        child: Stack(
                                          children: [
                                            ClipRRect(
                                              borderRadius: BorderRadius.circular(12),
                                              child: FutureBuilder<Uint8List>(
                                                future: _selectedExpenseProofImage!.readAsBytes(),
                                                builder: (context, snapshot) {
                                                  if (snapshot.connectionState == ConnectionState.waiting) {
                                                    return const Center(
                                                      child: CircularProgressIndicator(strokeWidth: 2),
                                                    );
                                                  }
                                                  if (snapshot.hasData) {
                                                    return Image.memory(
                                                      snapshot.data!,
                                                      width: double.infinity,
                                                      height: 200,
                                                      fit: BoxFit.cover,
                                                    );
                                                  }
                                                  return const Center(
                                                    child: Icon(Icons.error_outline, size: 20),
                                                  );
                                                },
                                              ),
                                            ),
                                            Positioned(
                                              top: 8,
                                              right: 8,
                                              child: IconButton(
                                                onPressed: () {
                                                  setDialogState(() {
                                                    _selectedExpenseProofImage = null;
                                                  });
                                                },
                                                icon: const Icon(Icons.close, color: Colors.white),
                                                style: IconButton.styleFrom(
                                                  backgroundColor: Colors.black54,
                                                ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    OutlinedButton.icon(
                                      onPressed: () async {
                                        final XFile? image = await imagePicker.pickImage(
                                          source: ImageSource.gallery,
                                          imageQuality: 85,
                                        );
                                        if (image != null) {
                                          setDialogState(() {
                                            _selectedExpenseProofImage = image;
                                          });
                                        }
                                      },
                                      icon: const Icon(Icons.upload_file),
                                      label: Text(_selectedExpenseProofImage != null ? 'Change Image' : 'Upload Image'),
                                      style: OutlinedButton.styleFrom(
                                        padding: EdgeInsets.symmetric(
                                          horizontal: 16,
                                          vertical: isMobile ? 12 : 14,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                      // Action Buttons
                      Container(
                        padding: EdgeInsets.all(isMobile ? 16 : 20),
                        decoration: BoxDecoration(
                          border: Border(
                            top: BorderSide(color: AppTheme.borderColor),
                          ),
                        ),
                        child: isMobile
                            ? Column(
                                children: [
                                  SizedBox(
                                    width: double.infinity,
                                    child: ElevatedButton(
                                      onPressed: dialogIsSubmitting ? null : () async {
                                        if (_addExpenseFormKey.currentState!.validate()) {
                                          setDialogState(() {
                                            dialogIsSubmitting = true;
                                            _isSubmitting = true;
                                          });

                                          try {
                                            final amount = double.parse(_expenseAmountController.text);
                                            final description = _expenseDescriptionController.text.trim();
                                            String? proofImageUrl;

                                            // Upload proof image if provided
                                            if (_selectedExpenseProofImage != null) {
                                              final uploadResult = await ExpenseService.uploadProofImage(
                                                _selectedExpenseProofImage!,
                                              );
                                              if (uploadResult['success'] == true) {
                                                proofImageUrl = uploadResult['imageUrl']?.toString();
                                              } else {
                                                if (mounted) {
    ScaffoldMessenger.of(context).showSnackBar(
                                                    SnackBar(
                                                      content: Text(uploadResult['message']?.toString() ?? 'Failed to upload image'),
                                                      backgroundColor: AppTheme.errorColor,
                                                    ),
                                                  );
                                                }
                                                setDialogState(() {
                                                  dialogIsSubmitting = false;
                                                  _isSubmitting = false;
                                                });
                                                return;
                                              }
                                            }

                                            final result = isEditMode && existingExpenseData != null
                                                ? await ExpenseService.updateExpense(
                                                    existingExpenseData['_id']?.toString() ?? existingExpenseData['id']?.toString() ?? '',
                                                    category: _selectedExpenseCategory,
                                                    amount: amount,
                                                    mode: _selectedExpenseMode,
                                                    description: description.isEmpty ? null : description,
                                                    proofUrl: proofImageUrl,
                                                  )
                                                : await ExpenseService.createExpense(
                                                    category: _selectedExpenseCategory,
                                                    amount: amount,
                                                    mode: _selectedExpenseMode,
                                                    description: description.isEmpty ? null : description,
                                                    proofUrl: proofImageUrl,
                                                  );

                                            if (mounted) {
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                                _isSubmitting = false;
                                              });

                                              if (result['success'] == true) {
                                                Navigator.of(dialogContext).pop();
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  SnackBar(
                                                    content: Text(result['message'] ?? (isEditMode ? 'Expense updated successfully' : 'Expense created successfully')),
                                                    backgroundColor: AppTheme.secondaryColor,
                                                    duration: const Duration(seconds: 2),
                                                  ),
                                                );
                                                _expenseAmountController.clear();
                                                _expenseDescriptionController.clear();
                                                setState(() {
                                                  _selectedExpenseCategory = 'Office';
                                                  _selectedExpenseMode = 'Cash';
                                                  _selectedExpensePaymentAccountId = null;
                                                  _selectedExpenseProofImage = null;
                                                });
                                                _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                              } else {
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  SnackBar(
                                                    content: Text(result['message'] ?? 'Operation failed'),
                                                    backgroundColor: AppTheme.errorColor,
                                                    duration: const Duration(seconds: 3),
                                                  ),
                                                );
                                              }
                                            }
                                          } catch (e) {
                                            if (mounted) {
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                                _isSubmitting = false;
                                              });
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                                  backgroundColor: AppTheme.errorColor,
                                                  duration: const Duration(seconds: 3),
                                                ),
                                              );
                                            }
                                          }
                                        }
                                      },
                                      style: ElevatedButton.styleFrom(
                                        backgroundColor: AppTheme.warningColor,
                                        foregroundColor: Colors.white,
                                        padding: EdgeInsets.symmetric(
                                          horizontal: 32,
                                          vertical: isMobile ? 16 : 14,
                                        ),
                                        shape: RoundedRectangleBorder(
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                      ),
                                      child: dialogIsSubmitting
                                          ? const SizedBox(
                                              width: 20,
                                              height: 20,
                                              child: CircularProgressIndicator(
                                                strokeWidth: 2,
                                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                              ),
                                            )
                                          : Text(
                                              isEditMode ? 'Update' : 'Submit',
                                              style: TextStyle(
                                                fontSize: isMobile ? 16 : 16,
                                                fontWeight: FontWeight.w600,
                                              ),
      ),
                                    ),
                                  ),
                                  const SizedBox(height: 12),
                                  SizedBox(
                                    width: double.infinity,
                                    child: TextButton(
                                      onPressed: dialogIsSubmitting
                                          ? null
                                          : () {
                                            Navigator.of(dialogContext).pop();
                                            _expenseAmountController.clear();
                                            _expenseDescriptionController.clear();
                                            _expenseRemarkController.clear();
                                            setState(() {
                                              _selectedExpenseCategory = 'Office';
                                              _selectedExpenseMode = 'Cash';
                                              _selectedExpensePaymentAccountId = null;
                                              _selectedExpenseProofImage = null;
                                            });
                                          },
                                      style: TextButton.styleFrom(
                                        padding: EdgeInsets.symmetric(
                                          vertical: isMobile ? 16 : 12,
                                        ),
                                      ),
                                      child: Text(
                                        'Cancel',
                                        style: TextStyle(
                                          color: AppTheme.primaryColor,
                                          fontSize: isMobile ? 16 : 15,
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              )
                            : Row(
                                mainAxisAlignment: MainAxisAlignment.end,
                                children: [
                                  TextButton(
                                    onPressed: dialogIsSubmitting
                                        ? null
                                        : () {
                                          Navigator.of(dialogContext).pop();
                                          _expenseAmountController.clear();
                                          _expenseDescriptionController.clear();
                                          setState(() {
                                            _selectedExpenseCategory = 'Office';
                                            _selectedExpenseMode = 'Cash';
                                            _selectedExpensePaymentAccountId = null;
                                            _selectedExpenseProofImage = null;
                                          });
                                        },
                                    style: TextButton.styleFrom(
                                      padding: EdgeInsets.symmetric(
                                        vertical: isMobile ? 16 : 12,
                                      ),
                                    ),
                                    child: Text(
                                      'Cancel',
                                      style: TextStyle(
                                        color: AppTheme.primaryColor,
                                        fontSize: isMobile ? 16 : 15,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(width: 12),
                                  ElevatedButton(
                                    onPressed: dialogIsSubmitting ? null : () async {
                                      if (_addExpenseFormKey.currentState!.validate()) {
                                        setDialogState(() {
                                          dialogIsSubmitting = true;
                                          _isSubmitting = true;
                                        });

                                        try {
                                          final amount = double.parse(_expenseAmountController.text);
                                          final description = _expenseDescriptionController.text.trim();
                                          String? proofImageUrl;

                                          if (_selectedExpenseProofImage != null) {
                                            final uploadResult = await ExpenseService.uploadProofImage(
                                              _selectedExpenseProofImage!,
                                            );
                                            if (uploadResult['success'] == true) {
                                              proofImageUrl = uploadResult['imageUrl']?.toString();
                                            } else {
                                              if (mounted) {
                                                ScaffoldMessenger.of(context).showSnackBar(
                                                  SnackBar(
                                                    content: Text(uploadResult['message']?.toString() ?? 'Failed to upload image'),
                                                    backgroundColor: AppTheme.errorColor,
                                                  ),
                                                );
                                              }
                                              setDialogState(() {
                                                dialogIsSubmitting = false;
                                                _isSubmitting = false;
                                              });
                                              return;
                                            }
                                          }

                                          final result = isEditMode && existingExpenseData != null
                                              ? await ExpenseService.updateExpense(
                                                  existingExpenseData['_id']?.toString() ?? existingExpenseData['id']?.toString() ?? '',
                                                  category: _selectedExpenseCategory,
                                                  amount: amount,
                                                  mode: _selectedExpenseMode,
                                                  description: description.isEmpty ? null : description,
                                                  proofUrl: proofImageUrl,
                                                )
                                              : await ExpenseService.createExpense(
                                                  category: _selectedExpenseCategory,
                                                  amount: amount,
                                                  mode: _selectedExpenseMode,
                                                  description: description.isEmpty ? null : description,
                                                  proofUrl: proofImageUrl,
                                                );

                                          if (mounted) {
                                            setDialogState(() {
                                              dialogIsSubmitting = false;
                                              _isSubmitting = false;
                                            });

                                            if (result['success'] == true) {
                                              Navigator.of(dialogContext).pop();
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text(result['message'] ?? (isEditMode ? 'Expense updated successfully' : 'Expense created successfully')),
                                                  backgroundColor: AppTheme.secondaryColor,
                                                  duration: const Duration(seconds: 2),
                                                ),
                                              );
                                              _expenseAmountController.clear();
                                              _expenseDescriptionController.clear();
                                              setState(() {
                                                _selectedExpenseCategory = 'Office';
                                                _selectedExpenseMode = 'Cash';
                                                _selectedExpensePaymentAccountId = null;
                                                _selectedExpenseProofImage = null;
                                              });
                                              _loadFinancialData(forceRefresh: true, isSelfWallet: _selectedItem == NavItem.walletSelf);
                                            } else {
                                              ScaffoldMessenger.of(context).showSnackBar(
                                                SnackBar(
                                                  content: Text(result['message'] ?? 'Operation failed'),
                                                  backgroundColor: AppTheme.errorColor,
                                                  duration: const Duration(seconds: 3),
                                                ),
                                              );
                                            }
                                          }
                                        } catch (e) {
                                          if (mounted) {
                                            setDialogState(() {
                                              dialogIsSubmitting = false;
                                              _isSubmitting = false;
                                            });
                                            ScaffoldMessenger.of(context).showSnackBar(
                                              SnackBar(
                                                content: Text('Error: ${e.toString().replaceFirst('Exception: ', '')}'),
                                                backgroundColor: AppTheme.errorColor,
                                                duration: const Duration(seconds: 3),
                                              ),
                                            );
                                          }
                                        }
                                      }
                                    },
                                    style: ElevatedButton.styleFrom(
                                      backgroundColor: AppTheme.warningColor,
                                      foregroundColor: Colors.white,
                                      padding: EdgeInsets.symmetric(
                                        horizontal: 32,
                                        vertical: isMobile ? 16 : 14,
                                      ),
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                    ),
                                    child: dialogIsSubmitting
                                        ? const SizedBox(
                                            width: 20,
                                            height: 20,
                                            child: CircularProgressIndicator(
                                              strokeWidth: 2,
                                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                            ),
                                          )
                                        : Text(
                                            isEditMode ? 'Update' : 'Submit',
                                            style: TextStyle(
                                              fontSize: isMobile ? 16 : 16,
                                              fontWeight: FontWeight.w600,
                                            ),
                                          ),
                                  ),
                                ],
                              ),
                      ),
                    ],
                  ),
                ),
              );
            },
          );
        },
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error opening dialog: ${e.toString()}'),
            backgroundColor: AppTheme.errorColor,
          ),
        );
      }
    }
  }

  void _openAddCollection() {
    _showNewAddCollectionDialog();
  }


  void _openAddTransaction() {
    context.push('/transfer').then((_) {
      if (!mounted) return;
      _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
    });
  }

  void _openAddAmount() {
    context.push('/add-account').then((_) {
      if (!mounted) return;
      _loadFinancialData(isSelfWallet: _selectedItem == NavItem.walletSelf);
    });
  }

  void _openWithdrawAmount() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Withdraw feature is currently unavailable'),
      ),
    );
  }
  /// Builds a list-style quick action item for mobile view
  /// Full-width button with icon on left and text on right
  Widget _buildQuickActionListItem(
    BuildContext context,
    String label,
    IconData icon,
    Color color,
    VoidCallback onTap,
  ) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: color.withOpacity(0.3)),
        ),
        child: Row(
          children: [
            Icon(icon, color: color, size: 32),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                label,
                style: AppTheme.bodyMedium.copyWith(
                  color: color,
                  fontWeight: FontWeight.w600,
                  fontSize: 16,
                ),
              ),
            ),
            Icon(Icons.chevron_right, color: color.withOpacity(0.5), size: 24),
          ],
        ),
      ),
    );
  }

  Widget _buildQuickActionItem(
    BuildContext context,
    String label,
    IconData icon,
    Color color,
    VoidCallback onTap,
  ) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        width: 120,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: color.withOpacity(0.3)),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color, size: 32),
            const SizedBox(height: 8),
            Text(
              label,
              textAlign: TextAlign.center,
              style: AppTheme.bodySmall.copyWith(
                color: color,
                fontWeight: FontWeight.w600,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatsGrid({
    required double totalBalance,
    required double cashBalance,
    required double upiBalance,
    required double bankBalance,
    required int pendingCollections,
    required int pendingTransactions,
    required int pendingExpenses,
    required int totalPending,
  }) {
    final isMobile = Responsive.isMobile(context);

    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: isMobile ? 2 : 4,
      crossAxisSpacing: 8,
      mainAxisSpacing: 8,
      childAspectRatio: isMobile ? 1.5 : 1.2,
      children: [
        _buildStatCard(
          title: 'Total Balance',
          value: '‚Çπ${_formatAmount(totalBalance)}',
          icon: Icons.account_balance_wallet,
          color: AppTheme.primaryColor,
        ),
        _buildStatCard(
          title: 'Smart Approvals',
          value: totalPending.toString(),
          icon: Icons.hourglass_bottom,
          color: AppTheme.warningColor,
          onTap: () => _navigateToRoute(NavItem.dashboard),
        ),
        _buildStatCard(
          title: 'Collections',
          value: pendingCollections.toString(),
          icon: Icons.payment_outlined,
          color: AppTheme.secondaryColor,
          subtitle: 'Pending',
        ),
        _buildStatCard(
          title: 'Transactions',
          value: pendingTransactions.toString(),
          icon: Icons.swap_horiz_outlined,
          color: AppTheme.secondaryColor,
          subtitle: 'Pending',
        ),
      ],
    );
  }

  Widget _buildStatCard({
    required String title,
    required String value,
    required IconData icon,
    required Color color,
    String? subtitle,
    VoidCallback? onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Container(
                    padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                      color: color.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(12),
              ),
                    child: Icon(icon, color: color, size: 24),
                  ),
                ],
              ),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: AppTheme.bodySmall.copyWith(
                      color: AppTheme.textSecondary,
                      fontSize: 12,
                    ),
                  ),
                  const SizedBox(height: 4),
            Text(
              value,
              style: AppTheme.headingMedium.copyWith(
                      fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
                  if (subtitle != null)
            Text(
                      subtitle,
              style: AppTheme.bodySmall.copyWith(
                color: AppTheme.textSecondary,
                        fontSize: 11,
              ),
            ),
          ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildQuickActions(BuildContext context) {
    final isMobile = Responsive.isMobile(context);

    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children: [
        _buildActionCard(
          context,
          'Add Amount',
          'Add funds to wallet',
          Icons.add_circle_outline,
          AppTheme.primaryColor,
          () async {
            final result = await context.push('/add-account');
            if (result == true && mounted) {
              // Refresh dashboard data after successful addition
              _loadDashboardData();
            }
          },
        ),
        _buildActionCard(
          context,
          'Withdraw',
          'Withdraw from wallet',
          Icons.remove_circle_outline,
          AppTheme.errorColor,
          () {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Withdraw feature is currently unavailable'),
              ),
            );
          },
        ),
        _buildActionCard(
          context,
          'Add Collection',
          'Create new collection',
          Icons.payment_outlined,
          AppTheme.secondaryColor,
          () {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Add Collection feature is currently unavailable'),
              ),
            );
          },
        ),
        _buildActionCard(
          context,
          'Create Transfer',
          'Transfer between users',
          Icons.swap_horiz_outlined,
          AppTheme.secondaryColor,
          () async {
            final result = await context.push('/transfer');
            if (result == true && mounted) {
              // Refresh dashboard data after successful transfer
              _loadDashboardData();
            }
          },
        ),
        _buildActionCard(
          context,
          'Add Expense',
          'Create new expense',
          Icons.receipt_outlined,
          AppTheme.warningColor,
          () {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Expenses feature is currently unavailable'),
              ),
            );
          },
        ),
        _buildActionCard(
          context,
          'Add User',
          'Create new user account',
          Icons.person_add_outlined,
          AppTheme.primaryColor,
          () async {
            final result = await context.push('/registration');
            if (result == true && mounted) {
              // Refresh dashboard data after successful user creation
              _loadDashboardData();
            }
          },
        ),
      ],
    );
  }

  Widget _buildActionCard(
    BuildContext context,
    String title,
    String subtitle,
    IconData icon,
    Color color,
    VoidCallback onTap,
  ) {
    final isMobile = Responsive.isMobile(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: AppTheme.borderColor),
      ),
        child: Container(
          width: isMobile ? double.infinity : 200,
          padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(icon, color: color, size: 28),
              ),
              const SizedBox(height: 16),
              Text(
                title,
                style: AppTheme.headingSmall.copyWith(fontSize: 16),
            ),
            const SizedBox(height: 4),
              Text(
                subtitle,
                style: AppTheme.bodySmall.copyWith(
                  color: AppTheme.textSecondary,
                  fontSize: 12,
                ),
              ),
          ],
        ),
      ),
      ),
    );
  }

  Widget _buildRecentActivity(BuildContext context) {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Recent Activity',
                  style: AppTheme.headingMedium,
                ),
                TextButton.icon(
                  onPressed: _isRefreshing ? null : () => _refreshDashboardAndFinancialData(),
                  icon: _isRefreshing
                      ? SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(AppTheme.primaryColor),
                          ),
                        )
                      : const Icon(Icons.refresh, size: 18),
                  label: const Text('Refresh'),
                ),
              ],
            ),
            const SizedBox(height: 16),
            _buildRecentActivityTable(context),
          ],
        ),
      ),
    );
  }

  Widget _buildRecentActivityTable(BuildContext context) {
    final isMobile = Responsive.isMobile(context);
    final recentActivities = _getRecentActivities();

    if (recentActivities.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            children: [
              Icon(
                Icons.history_outlined,
                size: 48,
                color: AppTheme.textSecondary.withValues(alpha: 0.5),
              ),
              const SizedBox(height: 16),
              Text(
                'No recent activity',
                style: AppTheme.bodyMedium.copyWith(
                  color: AppTheme.textSecondary,
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Column(
      children: [
        // Table Header
        if (!isMobile) _buildActivityTableHeader(),
        if (!isMobile) const Divider(),
        // Table Content
        ...recentActivities.take(10).map((activity) {
          return isMobile
              ? _buildActivityCard(context, activity)
              : _buildActivityRow(activity);
        }).toList(),
      ],
    );
  }

  Widget _buildActivityTableHeader() {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 0),
      child: Row(
        children: [
          Expanded(flex: 2, child: Text('Date/Time', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
          Expanded(flex: 2, child: Text('Type', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
          Expanded(flex: 3, child: Text('User', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
          Expanded(flex: 4, child: Text('Action', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
          Expanded(flex: 2, child: Text('Status', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
        ],
      ),
    );
  }

  Widget _buildActivityRow(Map<String, dynamic> activity) {
    final timestamp = activity['timestamp'] is DateTime
        ? activity['timestamp'] as DateTime
        : (activity['timestamp'] is String
            ? DateTime.parse(activity['timestamp']).toLocal()
            : DateTime.now());
    final user = activity['user'];
    final userName = user?['name'] ?? activity['from'] ?? 'Unknown';
    final userRole = user?['role'] ?? '';
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 0),
      child: Row(
        children: [
          Expanded(
            flex: 2,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(activity['date'] ?? _formatDate(timestamp), style: AppTheme.bodyMedium),
                Text(
                  '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}',
                  style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary),
                ),
              ],
            ),
          ),
          Expanded(flex: 2, child: _buildTypeChip(activity['type'] ?? 'Unknown')),
          Expanded(
            flex: 3,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(userName, style: AppTheme.bodyMedium),
                if (userRole.isNotEmpty)
                  Text(
                    userRole,
                    style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary),
                  ),
              ],
            ),
          ),
          Expanded(
            flex: 4,
            child: Text(
              activity['action'] ?? activity['purpose'] ?? '-',
              style: AppTheme.bodySmall,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          Expanded(flex: 2, child: _buildStatusChip(activity['action'] ?? 'Unknown')),
        ],
      ),
    );
  }

  Widget _buildActivityCard(BuildContext context, Map<String, dynamic> activity) {
    final timestamp = activity['timestamp'] is DateTime
        ? activity['timestamp'] as DateTime
        : (activity['timestamp'] is String
            ? DateTime.parse(activity['timestamp']).toLocal()
            : DateTime.now());
    final user = activity['user'];
    final userName = user?['name'] ?? activity['from'] ?? 'Unknown';
    final userRole = user?['role'] ?? '';
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '${activity['date'] ?? _formatDate(timestamp)} ‚Ä¢ ${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}',
                  style: AppTheme.bodySmall,
                ),
                Row(
                  children: [
                    _buildTypeChip(activity['type'] ?? 'Unknown'),
                    const SizedBox(width: 8),
                    _buildStatusChip(activity['action'] ?? 'Unknown'),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 6),
            Text('User: $userName', style: AppTheme.bodyMedium),
            if (userRole.isNotEmpty) ...[
              const SizedBox(height: 2),
              Text('Role: $userRole', style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary)),
            ],
            if (activity['action'] != null || activity['purpose'] != null) ...[
              const SizedBox(height: 6),
              Text(
                activity['action'] ?? activity['purpose'] ?? '-',
                style: AppTheme.bodySmall,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildTypeChip(String type) {
    Color color;
    switch (type) {
      case 'Add Amount':
        color = AppTheme.secondaryColor;
        break;
      case 'Withdraw':
        color = AppTheme.errorColor;
        break;
      case 'Transfer':
        color = AppTheme.primaryColor;
        break;
      case 'Collection':
        color = AppTheme.secondaryColor;
        break;
      case 'Expense':
        color = AppTheme.warningColor;
        break;
      default:
        color = AppTheme.textSecondary;
    }
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        type,
        style: AppTheme.bodySmall.copyWith(
          color: color,
          fontWeight: FontWeight.w600,
          fontSize: 11,
        ),
      ),
    );
  }

  List<Map<String, dynamic>> _getRecentActivities() {
    final List<Map<String, dynamic>> activities = [];
    
    // Use audit log data from dashboard API
    if (_recentActivities != null && _recentActivities!.isNotEmpty) {
      for (var activity in _recentActivities!) {
        final timestamp = activity['timestamp'] != null
            ? (activity['timestamp'] is String 
                ? DateTime.parse(activity['timestamp']).toLocal()
                : activity['timestamp'] as DateTime?)
            : DateTime.now();
        
        final user = activity['user'];
        final userName = user?['name'] ?? 'Unknown';
        final actionText = activity['actionText'] ?? activity['action'] ?? 'Unknown';
        final type = activity['type'] ?? 'Unknown';
        final action = activity['action'] ?? 'Unknown';
        
        activities.add({
          'date': _formatDate(timestamp),
          'type': type,
          'action': actionText,
          'from': userName,
          'to': null,
          'amount': '-', // Audit logs don't always have amounts
          'mode': '-',
          'purpose': actionText,
          'status': action,
          'timestamp': timestamp,
          'user': user,
        });
      }
    }

    // Sort by timestamp (most recent first)
    activities.sort((a, b) {
      try {
        final aTime = a['timestamp'] is DateTime
            ? (a['timestamp'] as DateTime).millisecondsSinceEpoch
            : (a['timestamp'] is String
                ? DateTime.parse(a['timestamp']).millisecondsSinceEpoch
                : 0);
        final bTime = b['timestamp'] is DateTime
            ? (b['timestamp'] as DateTime).millisecondsSinceEpoch
            : (b['timestamp'] is String
                ? DateTime.parse(b['timestamp']).millisecondsSinceEpoch
                : 0);
        return bTime.compareTo(aTime);
      } catch (e) {
        return 0;
      }
    });

    return activities.take(10).toList();
  }

  String _formatDate(dynamic date) {
    if (date == null) return 'N/A';
    try {
      final dateTime = date is String ? DateTime.parse(date).toLocal() : date as DateTime;
      return '${dateTime.day}-${_getMonthAbbr(dateTime.month)}-${dateTime.year.toString().substring(2)}';
    } catch (e) {
      return 'N/A';
    }
  }

  String _getMonthAbbr(int month) {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return months[month - 1];
  }

  String _formatDateForTable(dynamic date) {
    if (date == null) return '';
    try {
      DateTime dateTime;
      if (date is DateTime) {
        dateTime = date;
      } else if (date is String) {
        dateTime = DateTime.parse(date);
      } else {
        return '';
      }
      return DateFormat('dd-MMM-yyyy').format(dateTime);
    } catch (e) {
      return '';
    }
  }

  String _formatTimeForTable(dynamic date) {
    if (date == null) return '';
    try {
      DateTime dateTime;
      if (date is DateTime) {
        dateTime = date;
      } else if (date is String) {
        dateTime = DateTime.parse(date);
      } else {
        return '';
      }
      return DateFormat('hh:mm a').format(dateTime);
    } catch (e) {
      return '';
    }
  }

  Future<void> _handleExpenseAction(String expenseId, String action, {String? reason}) async {
    try {
      Map<String, dynamic> result;
      if (action == 'approve') {
        result = await ExpenseService.approveExpense(expenseId);
      } else if (action == 'reject') {
        result = await ExpenseService.rejectExpense(expenseId, reason);
      } else if (action == 'unapprove') {
        result = await ExpenseService.updateExpenseStatus(expenseId, 'Unapproved');
      } else if (action == 'flag') {
        result = await ExpenseService.flagExpense(expenseId, reason ?? 'Flagged from dashboard');
      } else {
        return;
      }

      if (result['success'] == true && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(result['message'] ?? 'Action completed successfully')),
        );
        // Reload dashboard data
        _loadDashboardData();
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(result['message'] ?? 'Action failed')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _handleTransactionAction(String transactionId, String action, {String? reason}) async {
    try {
      Map<String, dynamic> result;
      if (action == 'approve') {
        result = await TransactionService.approveTransaction(transactionId);
      } else if (action == 'reject') {
        result = await TransactionService.rejectTransaction(transactionId, reason);
      } else if (action == 'unapprove') {
        result = await TransactionService.cancelTransaction(transactionId);
      } else if (action == 'flag') {
        result = await TransactionService.flagTransaction(transactionId, reason ?? 'Flagged from dashboard');
      } else {
        return;
      }

      if (result['success'] == true && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(result['message'] ?? 'Action completed successfully')),
        );
        // Reload dashboard data
        _loadDashboardData();
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(result['message'] ?? 'Action failed')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: ${e.toString()}')),
        );
      }
    }
  }
  Widget _buildRecentTransactionsTable(BuildContext context) {
    final isMobile = Responsive.isMobile(context);

    if (_isLoadingDashboard) {
      return Card(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: AppTheme.borderColor),
        ),
        child: const Padding(
          padding: EdgeInsets.all(32),
          child: Center(child: CircularProgressIndicator()),
        ),
      );
    }

    if (_recentTransactions.isEmpty) {
      return Card(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: AppTheme.borderColor),
        ),
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Center(
            child: Text(
              'No recent transactions',
              style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
            ),
          ),
        ),
      );
    }

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (!isMobile)
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 0),
                child: Row(
                  children: [
                    Expanded(flex: 2, child: Text('Date', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Sender', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Receiver', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Amount', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 1, child: Text('Mode', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Purpose', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Created By', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    Expanded(flex: 2, child: Text('Timestamp', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    SizedBox(width: 80, child: Text('Status', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                    SizedBox(width: 120, child: Text('Actions', style: AppTheme.labelMedium, textAlign: TextAlign.left)),
                  ],
                ),
              ),
            if (!isMobile) const Divider(),
            ..._recentTransactions.map((tx) {
              final date = _formatDateForTable(tx['date'] ?? tx['createdAt']);
              final sender = tx['sender'] != null ? tx['sender']['name'] ?? 'Unknown' : 'Unknown';
              final receiver = tx['receiver'] != null ? tx['receiver']['name'] ?? 'Unknown' : 'Unknown';
              final amount = '‚Çπ${tx['amount']?.toStringAsFixed(0) ?? '0'}';
              final mode = tx['mode'] ?? '';
              final createdBy = tx['initiatedBy'] != null ? tx['initiatedBy']['name'] ?? 'Unknown' : 'Unknown';
              final purpose = tx['purpose'] ?? 'N/A';
              final timestamp = _formatTimeForTable(tx['createdAt']);
              final status = tx['status'] ?? 'Pending';
              final transactionId = tx['id'] ?? '';

              return isMobile
                  ? _buildRecentTransactionCard(context, date, sender, receiver, amount, mode, createdBy, timestamp, status, purpose, transactionId)
                  : _buildTransactionRowFull(date, sender, receiver, amount, mode, purpose, createdBy, timestamp, status, transactionId);
            }).toList(),
          ],
        ),
      ),
    );
  }

  Widget _buildTransactionRowFull(
    String date,
    String sender,
    String receiver,
    String amount,
    String mode,
    String purpose,
    String createdBy,
    String timestamp,
    String status,
    String transactionId,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 0),
      child: Row(
        children: [
          Expanded(flex: 2, child: Text(date, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(sender, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(receiver, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(amount, style: AppTheme.bodyMedium)),
          Expanded(flex: 1, child: Text(mode, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(purpose, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(createdBy, style: AppTheme.bodyMedium)),
          Expanded(flex: 2, child: Text(timestamp, style: AppTheme.bodyMedium)),
          SizedBox(width: 80, child: _buildStatusChip(status)),
          SizedBox(
            width: 240,
            child: Wrap(
              alignment: WrapAlignment.end,
              spacing: 8,
              runSpacing: 8,
              children: _buildRowActions(status, transactionId),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecentTransactionCard(
    BuildContext context,
    String date,
    String sender,
    String receiver,
    String amount,
    String mode,
    String createdBy,
    String timestamp,
    String status,
    String purpose,
    String transactionId,
  ) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(date, style: AppTheme.bodySmall),
                _buildStatusChip(status),
              ],
            ),
            const SizedBox(height: 6),
            Text('From: $sender', style: AppTheme.bodyMedium),
            const SizedBox(height: 2),
            Text('To: $receiver', style: AppTheme.bodyMedium),
            const SizedBox(height: 2),
            Text('Purpose: $purpose', style: AppTheme.bodySmall),
            const SizedBox(height: 6),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(amount, style: AppTheme.headingSmall),
                Text('$mode ‚Ä¢ $timestamp', style: AppTheme.bodySmall),
              ],
            ),
            const SizedBox(height: 4),
            Text('Created by: $createdBy', style: AppTheme.bodySmall),
            const SizedBox(height: 8),
            Wrap(
              alignment: WrapAlignment.end,
              spacing: 8,
              runSpacing: 8,
              children: _buildRowActions(status, transactionId, compact: true),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRecentExpenses(BuildContext context) {
    final isMobile = Responsive.isMobile(context);

    if (_isLoadingDashboard) {
      return Card(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: AppTheme.borderColor),
        ),
        child: const Padding(
          padding: EdgeInsets.all(32),
          child: Center(child: CircularProgressIndicator()),
        ),
      );
    }

    if (_recentExpenses.isEmpty) {
      return Card(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: AppTheme.borderColor),
        ),
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Center(
            child: Text(
              'No recent expenses',
              style: AppTheme.bodyMedium.copyWith(color: AppTheme.textSecondary),
            ),
          ),
        ),
      );
    }

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Table Header
            if (!isMobile) _buildExpenseTableHeader(),
            if (!isMobile) const Divider(height: 24),
            
            // Table Content
            ..._recentExpenses.map((expense) {
              final expenseData = {
                'id': expense['id'] ?? '',
                'date': _formatDateForTable(expense['date'] ?? expense['createdAt']),
                'user': expense['userId'] != null ? expense['userId']['name'] ?? 'Unknown' : 'Unknown',
                'category': expense['category'] ?? '',
                'amount': '‚Çπ${expense['amount']?.toStringAsFixed(0) ?? '0'}',
                'mode': expense['mode'] ?? '',
                'description': expense['description'] ?? '',
                'status': expense['status'] ?? 'Pending',
                'originalExpense': expense, // Store original expense data for edit
              };
              return isMobile
                  ? _buildExpenseCard(context, expenseData)
                  : _buildExpenseRow(context, expenseData);
            }).toList(),
          ],
        ),
      ),
    );
  }

  Widget _buildExpenseTableHeader() {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        children: [
          Expanded(flex: 2, child: Text('Date', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text('User', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text('Category', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text('Amount', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 1, child: Text('Mode', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 3, child: Text('Description', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text('Status', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text('Actions', style: AppTheme.labelMedium, textAlign: TextAlign.center)),
        ],
      ),
    );
  }

  Widget _buildExpenseCard(BuildContext context, Map<String, dynamic> expense) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: AppTheme.borderColor),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header row with date and status
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(expense['date'], style: AppTheme.bodyMedium.copyWith(
                  fontWeight: FontWeight.w600,
                )),
                _buildStatusChip(expense['status']),
              ],
            ),
            const SizedBox(height: 12),
            
            // Expense details
            _buildExpenseDetailRow('User', expense['user']),
            _buildExpenseDetailRow('Category', expense['category']),
            _buildExpenseDetailRow('Mode', expense['mode']),
            
            const SizedBox(height: 8),
            
            // Description
            Text(
              expense['description'],
              style: AppTheme.bodySmall.copyWith(
                color: AppTheme.textSecondary,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            
            const SizedBox(height: 12),
            
            // Amount and actions
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  expense['amount'],
                  style: AppTheme.headingSmall.copyWith(
                    color: AppTheme.errorColor,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                if (expense['status'] != 'Approved' && expense['status'] != 'Completed') 
                  _buildMobileActions(expense['status'], expense),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpenseDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          SizedBox(
            width: 70,
            child: Text('$label:', style: AppTheme.bodySmall.copyWith(
              color: AppTheme.textSecondary,
            )),
          ),
          Expanded(
            child: Text(value, style: AppTheme.bodyMedium),
          ),
        ],
      ),
    );
  }

  Widget _buildExpenseRow(BuildContext context, Map<String, dynamic> expense) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16),
      child: Row(
        children: [
          Expanded(flex: 2, child: Text(expense['date'], style: AppTheme.bodyMedium, textAlign: TextAlign.center)),
          Expanded(flex: 2, child: Text(expense['user'], style: AppTheme.bodyMedium, textAlign: TextAlign.center)),
          Expanded(
            flex: 2,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              decoration: BoxDecoration(
                color: _getCategoryColor(expense['category']).withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                expense['category'],
                style: AppTheme.bodySmall.copyWith(
                  color: _getCategoryColor(expense['category']),
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
          Expanded(
            flex: 2,
            child: Text(
              expense['amount'],
              style: AppTheme.bodyMedium.copyWith(
                color: AppTheme.errorColor,
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          Expanded(
            flex: 1,
            child: Text(
              expense['mode'],
              style: AppTheme.bodyMedium.copyWith(
                fontWeight: FontWeight.w500,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          Expanded(
            flex: 3,
            child: Tooltip(
              message: expense['description'],
              child: Text(
                expense['description'],
                style: AppTheme.bodySmall,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                textAlign: TextAlign.center,
              ),
            ),
          ),
          Expanded(
            flex: 2,
            child: _buildStatusChip(expense['status']),
          ),
          Expanded(
            flex: 2,
            child: _buildExpenseActions(expense['status'], expense),
          ),
        ],
      ),
    );
  }

  Widget _buildActionBadge({
    required IconData icon,
    required String label,
    required Color color,
    required VoidCallback onTap,
    bool compact = false,
  }) {
    final double dimension = compact ? 36 : 40;
    final double iconSize = compact ? 18 : 20;

    final button = InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        width: dimension,
        height: dimension,
        decoration: BoxDecoration(
          color: color.withOpacity(0.12),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: color.withOpacity(0.3)),
        ),
        child: Icon(icon, color: color, size: iconSize),
      ),
    );

    return Tooltip(
      message: label,
      waitDuration: const Duration(milliseconds: 400),
      child: button,
    );
  }

  List<Widget> _buildExpenseActionWidgets({
    required String status,
    required String expenseId,
    required Map<String, dynamic> expenseItem,
    required bool compact,
  }) {
    if (expenseId.isEmpty) {
      return [
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          decoration: BoxDecoration(
            color: AppTheme.surfaceColor,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: AppTheme.borderColor),
          ),
          child: Text(
            'Actions unavailable',
            style: AppTheme.bodySmall.copyWith(color: AppTheme.textSecondary),
          ),
        ),
      ];
    }

    final normalizedStatus = _normalizeStatusKey(status);
    final lowerStatus = status.trim().toLowerCase();
    final isFlagged = lowerStatus == 'flagged';
    final isApprovedState = {
      'approved',
      'verified',
      'Accounted',
    }.contains(normalizedStatus);

    final List<Widget> actions = [];

    void addAction({
      required String key,
      required IconData icon,
      required String label,
      required Color color,
      required Future<void> Function() onExecute,
      Future<void> Function(String reason)? onExecuteWithReason,
    }) {
      if (!_isActionButtonVisible(key)) return;
      actions.add(
        _buildActionBadge(
          icon: icon,
          label: label,
          color: color,
          onTap: () => _handleConfiguredAction(
            key: key,
            label: label,
            color: color,
            action: onExecute,
            actionWithReason: onExecuteWithReason,
          ),
          compact: compact,
        ),
      );
    }

    if (isApprovedState) {
      addAction(
        key: 'unapprove',
        icon: Icons.thumb_down_alt,
        label: 'Unapprove',
        color: AppTheme.textSecondary,
        onExecute: () => _handleExpenseAction(expenseId, 'unapprove'),
      );

      addAction(
        key: 'reject',
        icon: Icons.cancel,
        label: 'Reject',
        color: AppTheme.errorColor,
        onExecute: () => _handleExpenseAction(expenseId, 'reject'),
        onExecuteWithReason: (reason) => _handleExpenseAction(expenseId, 'reject', reason: reason),
      );

      if (!isFlagged) {
        addAction(
          key: 'flag',
          icon: Icons.flag_outlined,
          label: 'Flag',
          color: AppTheme.warningColor,
          onExecute: () => _handleExpenseAction(expenseId, 'flag'),
          onExecuteWithReason: (reason) => _handleExpenseAction(expenseId, 'flag', reason: reason),
        );
      }

      addAction(
        key: 'edit',
        icon: Icons.edit_outlined,
        label: 'Edit',
        color: AppTheme.primaryColor,
        onExecute: () => _handleEdit(expenseItem),
      );

      addAction(
        key: 'delete',
        icon: Icons.delete_outline,
        label: 'Delete',
        color: AppTheme.errorColor,
        onExecute: () => _handleDelete(expenseItem),
      );
    } else {
      final approveLabel = isFlagged ? 'Re-Approve' : 'Approve';

      addAction(
        key: 'approve',
        icon: Icons.thumb_up_alt,
        label: approveLabel,
        color: AppTheme.secondaryColor,
        onExecute: () => _handleExpenseAction(expenseId, 'approve'),
      );

      addAction(
        key: 'reject',
        icon: Icons.cancel,
        label: 'Reject',
        color: AppTheme.errorColor,
        onExecute: () => _handleExpenseAction(expenseId, 'reject'),
        onExecuteWithReason: (reason) => _handleExpenseAction(expenseId, 'reject', reason: reason),
      );

      if (!isFlagged) {
        addAction(
          key: 'flag',
          icon: Icons.flag_outlined,
          label: 'Flag',
          color: AppTheme.warningColor,
          onExecute: () => _handleExpenseAction(expenseId, 'flag'),
          onExecuteWithReason: (reason) => _handleExpenseAction(expenseId, 'flag', reason: reason),
        );
      }

      addAction(
        key: 'edit',
        icon: Icons.edit_outlined,
        label: 'Edit',
        color: AppTheme.primaryColor,
        onExecute: () => _handleEdit(expenseItem),
      );

      addAction(
        key: 'delete',
        icon: Icons.delete_outline,
        label: 'Delete',
        color: AppTheme.errorColor,
        onExecute: () => _handleDelete(expenseItem),
      );
    }

    return actions;
  }

  Widget _buildExpenseActions(String status, Map<String, dynamic> expense) {
    final expenseId = expense['id']?.toString() ?? '';
    final originalExpense = expense['originalExpense'] as Map<String, dynamic>? ?? expense;
    final expenseItem = {
      'id': expenseId,
      'type': 'Expenses',
      'status': status,
      'amount': originalExpense['amount'] ?? double.tryParse(expense['amount']?.toString().replaceAll('‚Çπ', '') ?? '0') ?? 0,
      'category': originalExpense['category'] ?? expense['category'] ?? '',
      'mode': originalExpense['mode'] ?? expense['mode'] ?? '',
      'description': originalExpense['description'] ?? expense['description'] ?? '',
    };

    final actions = _buildExpenseActionWidgets(
      status: status,
      expenseId: expenseId,
      expenseItem: expenseItem,
      compact: false,
    );

    return Wrap(
      alignment: WrapAlignment.center,
      spacing: 8,
      runSpacing: 8,
      children: actions,
    );
  }

  Widget _buildMobileActions(String status, Map<String, dynamic> expense) {
    final expenseId = expense['id']?.toString() ?? '';
    final originalExpense = expense['originalExpense'] as Map<String, dynamic>? ?? expense;
    final expenseItem = {
      'id': expenseId,
      'type': 'Expenses',
      'status': status,
      'amount': originalExpense['amount'] ?? double.tryParse(expense['amount']?.toString().replaceAll('‚Çπ', '') ?? '0') ?? 0,
      'category': originalExpense['category'] ?? expense['category'] ?? '',
      'mode': originalExpense['mode'] ?? expense['mode'] ?? '',
      'description': originalExpense['description'] ?? expense['description'] ?? '',
    };

    final actions = _buildExpenseActionWidgets(
      status: status,
      expenseId: expenseId,
      expenseItem: expenseItem,
      compact: true,
    );

    return Wrap(
      alignment: WrapAlignment.start,
      spacing: 8,
      runSpacing: 8,
      children: actions,
    );
  }
  List<Widget> _buildRowActions(String status, String id, {bool compact = false}) {
    final transactionItem = {'id': id, 'type': 'Transactions'};

    final normalizedStatus = _normalizeStatusKey(status);
    final lowerStatus = status.trim().toLowerCase();
    final isFlagged = lowerStatus == 'flagged';
    final isApprovedState = {
      'approved',
      'verified',
      'Accounted',
    }.contains(normalizedStatus);

    final List<Widget> actions = [];

    void addAction({
      required String key,
      required IconData icon,
      required String label,
      required Color color,
      required Future<void> Function() onExecute,
      Future<void> Function(String reason)? onExecuteWithReason,
    }) {
      if (!_isActionButtonVisible(key)) return;
      actions.add(
        _buildActionBadge(
          icon: icon,
          label: label,
          color: color,
          onTap: () => _handleConfiguredAction(
            key: key,
            label: label,
            color: color,
            action: onExecute,
            actionWithReason: onExecuteWithReason,
          ),
          compact: compact,
        ),
      );
    }

    if (isApprovedState) {
      addAction(
        key: 'unapprove',
        icon: Icons.thumb_down_alt,
        label: 'Unapprove',
        color: AppTheme.textSecondary,
        onExecute: () => _handleTransactionAction(id, 'unapprove'),
      );

      addAction(
        key: 'reject',
        icon: Icons.cancel,
        label: 'Reject',
        color: AppTheme.errorColor,
        onExecute: () => _handleTransactionAction(id, 'reject'),
        onExecuteWithReason: (reason) => _handleTransactionAction(id, 'reject', reason: reason),
      );

      if (!isFlagged) {
        addAction(
          key: 'flag',
          icon: Icons.flag_outlined,
          label: 'Flag',
          color: AppTheme.warningColor,
          onExecute: () => _handleTransactionAction(id, 'flag'),
          onExecuteWithReason: (reason) => _handleTransactionAction(id, 'flag', reason: reason),
        );
      }

      addAction(
        key: 'edit',
        icon: Icons.edit_outlined,
        label: 'Edit',
        color: AppTheme.primaryColor,
        onExecute: () => _handleEdit({'id': id, 'type': 'Transactions'}),
      );

      addAction(
        key: 'delete',
        icon: Icons.delete_outline,
        label: 'Delete',
        color: AppTheme.errorColor,
        onExecute: () => _handleDelete(transactionItem),
      );
    } else {
      final approveLabel = isFlagged ? 'Re-Approve' : 'Approve';

      addAction(
        key: 'approve',
        icon: Icons.thumb_up_alt,
        label: approveLabel,
        color: AppTheme.secondaryColor,
        onExecute: () => _handleTransactionAction(id, 'approve'),
      );

      addAction(
        key: 'reject',
        icon: Icons.cancel,
        label: 'Reject',
        color: AppTheme.errorColor,
        onExecute: () => _handleTransactionAction(id, 'reject'),
        onExecuteWithReason: (reason) => _handleTransactionAction(id, 'reject', reason: reason),
      );

      if (!isFlagged) {
        addAction(
          key: 'flag',
          icon: Icons.flag_outlined,
          label: 'Flag',
          color: AppTheme.warningColor,
          onExecute: () => _handleTransactionAction(id, 'flag'),
          onExecuteWithReason: (reason) => _handleTransactionAction(id, 'flag', reason: reason),
        );
      }

      addAction(
        key: 'edit',
        icon: Icons.edit_outlined,
        label: 'Edit',
        color: AppTheme.primaryColor,
        onExecute: () => _handleEdit({'id': id, 'type': 'Transactions'}),
      );

      addAction(
        key: 'delete',
        icon: Icons.delete_outline,
        label: 'Delete',
        color: AppTheme.errorColor,
        onExecute: () => _handleDelete(transactionItem),
      );
    }

    return actions;
  }
  Color _getCategoryColor(String category) {
    switch (category) {
      case 'Office':
        return AppTheme.primaryColor;
      case 'Travel':
        return AppTheme.secondaryColor;
      case 'Marketing':
        return AppTheme.warningColor;
      case 'Maintenance':
        return Colors.orange;
      default:
        return AppTheme.textSecondary;
    }
  }

}
